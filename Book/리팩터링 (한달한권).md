# 1. 리팩터링에 대한 저자의 전반적인 견해
### 리팩터링 정의
- 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- 리팩터링하다가 코드가 깨졌다면 그것은 리팩터링이 아니다.
- 리팩터링은 그 과정에서의 겉보기 동작 유지가 중요한 것이다.
- 리팩터링의 특징은 무엇을 하느냐가 아니라 어떻게 하느냐이다.

### 두 개의 모자
- 기능 추가와 리팩터링을 명확하게 구분하라.
- 그러나 리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무 많기 때문에 굳이 나누는 것은 시간 낭비일 수 있다는 의견이 있음.
- 최종 commit은 하나로 묶되, 코드 리뷰는 여러 revision으로 나누어 검토하는 것을 추천
- git stach/commit/rebase 등의 기능 잘 활용하기

### 리팩터링, 왜 하는가?
- 소프트웨어 설계가 좋아진다.
- 소프트웨어를 이해하기 쉬워진다.
- 버그를 쉽게 찾을 수 있다.
- -> 프로그래밍 속도를 높일 수 있다.
- 설계 지구력 가설 : 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.

### 리팩터링, 언제 하는가? (실질적으로)
- 3의 법칙 : 3진 아웃 리팩터링 (X)
  - 일단 개발한다.
  - 같은 일을 두번하게 되면, 일단 한다.
  - 또 같은 일을 하게 되면, 이제야 말로 리팩터링 할 때다.
- 준비를 위한 리팩터링 : 기능을 쉽게 추가하게 만들기 (O)
  - 기능을 추가하기 직전에, 리팩터링을 하면 더 쉽게 추가할 수 있지 않을까 고민
- 이해를 위한 리팩터링 - 코드를 이해하기 쉽게 만들기 (X)
  - 코드를 파악해야 할 일이 있을 때, 이해한 내용을 더 잘 반영할 수 있도록 리팩터링
- 쓰레기 줍기 리팩터링 (X)
  - 코드를 파악하다가 비효율적으로 처리하는 모습을 발견하면 리팩터링
- 수시로 하는 리팩터링
  - 따로 하지 않고 일반 개발 과정에서
- 코드 리뷰에 리팩터링 활용하기
  - 코드 리뷰를 할 때, 실제로 리팩터링 해보기
- 리팩터링을 하지 말아야 할 때
  - 지저분해도 굳이 수정할 필요가 없을 경우
  - 차라리 새로 작성하는 것이 쉬울 경우
- 아마존의 실질적인 리팩터링 분포 : 코드리뷰(95%), 기능추가(5%)

### YAGNI (You Aren't Going to Need It)
- 1. 코딩을 시작하기 전에 아키텍쳐를 확정해야
  - but 요구사항 사전 파악이 현실적으로 불가능
- 2. 유연성 메커니즘 심어두기
  - but 되려 대응능력 저해
- 3. YAGNI
  - 추측하지 말고 현재 요구사항만 충족해라
  - 대신 그것을 최대한 멋지게 해결하도록 설계해라
  - 나중에 더 잘 이해하게 되면 리팩터링으로 바꾼다
  - 선제적 아키텍쳐에 소홀하라는 뜻이 아니다.
  - 이미 알고있는 부분을 최대한 미리 준비하는게 좋지만 모르는 것을 미리 대비하기 보다는, 이해하고 나서 반영하는게 더 효율적이다.

### 리팩터링과 성능
- '이렇게 하면 더 느려질 것 같은데...'
- 직관적 설계 vs 성능
- 리팩터링은 이해하기 쉬운 코드를 위해 속도가 느려지는 방향인 경우가 많다.
- 저자의 주장을 요약하자면,
  - 성능이 느려져도 상관없으니 보기 좋은 코드가 좋다. (X)
  - 하드웨어가 발전해서 그 정도 성능저하는 아무 문제 없을 것이다. (X)
  - 성능을 튜닝하기는 쉬워지기 때문에 오히려 성능이 좋아진다. (O)
- 90퍼센트의 시간은 낭비이다.
  - 성능에 신경쓰지 않고, 보기좋게 코딩한다.
  - 성능 최적화 단계가 되면, 프로파일러로 분석하여 오랜 시간을 잡아먹는 코드를 특정한다.
  - 그 부분을 개선한다.
- 리팩터링이 잘 된 코드는 성능 분석에 유리하다.

# 2. 코드에서 나는 악취와 테스트 구축하기
