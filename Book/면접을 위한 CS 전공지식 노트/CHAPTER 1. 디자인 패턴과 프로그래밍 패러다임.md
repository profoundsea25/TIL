# SECTION 1 디자인 패턴
## 1.1 디자인 패턴
### 1.1.1 싱글톤 패턴
- 정의
  - 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
  - 하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용
- 예시 : 보통 데이터베이스 연결 모듈에 많이 사용
- 장점 : 인스턴스를 생성하는 비용이 줄어듬
- 단점
  - 의존성이 높아지는 단점
    - 모듈 간의 결합을 강하게 만든다.
  - TDD에 걸림돌
    - TDD를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며, 테스트를 어떤 순서로든 실행할 수 있어야 한다.
    - 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로, 각 테스트마다 '독립적인' 인스턴스를 만들기 어렵다.
<details>
<summary>간단한 싱글톤 코드</summary>

```java
class Singleton {
    private static class singleInstanceHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static synchronized Singleton getInstance() {
        return singleInstanceHolder.INSTANCE;
    }
}
```

</details>

#### 의존성 주입 (단점 해결)
- 의존성 주입(DI)을 통해 모듈 간의 결합을 조금 더 느슨하게 만들어 해결할 수 있음.
- 의존성 = 종속성, A가 B에 의존성이 있다 = B의 변경 사항에 대해 A 또한 변해야 된다.
- 정의
  - 메인 모듈이 '직접' 다른 하위 모듈에 대한 의존성을 주기보다 중간에 의존성 주입자(dependency injector)가 이 부분을 가로채 메인 모듈이 '간접'적으로 의존성을 주입하는 방식
  - 이를 통해 메인 모듈(상위 모듈)은 하위 모듈에 대한 의존성이 떨어진다. = 디커플링이 된다.
- 의존성 주입의 장점
  - 모듈들이 쉽게 교체할 수 있는 구조가 되어 테스팅이 쉽고, 마이그레이션이 수월하다.
  - 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어 주기 때문에 애플리케이션 의존성 방향이 일관되고,
  - 애플리케이션을 쉽게 추론할 수 있으며, 모듈 간의 관계들이 조금 더 명확해 진다.
- 의존성 주입의 단점
  - 모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있으며,
  - ~약간의 런타임 페널티가 생기기도 합니다.~ (내용 추가 필요)
- 의존성 주입 원칙
  - 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다.
  - 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.
  - 추상화는 세부 사항에 의존하지 말아야 한다.

### 1.1.2 팩토리 패턴
- 정의
  - 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
  - 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴
- 장점
  - 상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가짐
  - 상위 클래스에는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 더 많은 유연성을 갖음
  - 객체 생성 로직이 따로 떼어져 있기 때문에 코드를 리팩터링하더라도 한 곳만 고칠수 있어 유지 보수성 증가

### 1.1.3 전략 패턴
- 정의 (전략 패턴 = 정책 패턴)
  - 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴
- 컨텍스트
  - 상황, 맥락, 문맥을 의미하며, 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보를 뜻함

### 1.1.4 옵저버 패턴

# SECTION 2 프로그래밍 패러다임
