# 10장. 예외
### 아이템 69. 예외는 진짜 예외 상황에서만 사용하라
- 무슨 일을 하는지 전혀 직관적이지 않다는 것 하나만으로도, 코드를 그렇게 작성하면 안 되는 이유는 충분하다.
- 예외는 (그 이름이 말해주듯) 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안 된다.
  - 표준적이고 쉽게 이해되는 관용구를 사용하고, 성능 개선을 목적으로 과하게 머리를 쓴 기법은 자제하라.
  - 실제로 성능이 좋아지더라도 자바 플랫폼이 꾸준히 개선되고 있으니 최적화로 얻은 상대적인 성능 우위가 오래가지 않을 수 있다.
- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.
- 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침 몇 가지
  - 1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 떄문이다.
  - 2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.
  - 3. 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다. 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기가 쉽다. 상태 검사 메서드 호출을 깜빡 잊었다면 상태 의존적 메서드가 예외를 던져 버그를 확실히 드러낼 것이다. 반면 특정 값은 검사하지 않고 지나쳐도 발견하기가 어렵다. (옵셔널은 제외)

#
### 아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라
- 검사 예외
  - 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.
    - 검사/비검사 예외를 구분하는 기본 규칙이다.
  - 검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다.
  - 메서드 선언에 포함된 검사 예외 각각은 그 메서드를 호출했을 때 발생할 수 있는 유력한 결과임을 API 사용자에게 알려주는 것이다.
  - 즉, API 설계자는 API 사용자에게 검사 예외를 던져주어 그 상황에서 회복해내라고 요구한 것이다.
  - 호출자가 예외 상황에서 벗어나는 데 필요한 정보를 알려주는 메서드를 함께 제공하는 것이 중요하다.
- 비검사 `Throwable` : 런타임 예외와 에러
  - 프로그램에서 잡을 필요가 없거나 혹은 통상적으로는 잡지 말아야 한다.
  - 비검사 예외나 에러를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많다는 뜻이다.
- 런타임 예외
  - 프로그래밍 오류를 나타낼 때는 런타입 예외를 사용하자.
  - 런타임 예외의 대부분 전제조건을 만족하지 못했을 때 발생한다. 이는 단순히 클라이언트가 해당 API의 명세에 기록된 제약을 지키지 못했다는 뜻이다.
  - 복구할 수 있는 상황인지 프로그래밍 오류인지가 항상 명확히 구분되지는 않는다. 확신하기 어렵다면 아마도 비검사 예외를 선택하는 편이 낫다.
- 에러
  - 보통 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용
  - `Error` 클래스를 상속해 하위 클래스를 만드는 일은 자제하자.
  - 다시 말해 여러분이 구현하는 비검사 `Throwable`은 모두 `RuntimeException`의 하위 클래스여야 한다.
  - `Error`는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야 한다. (`AssertionError`는 예외)
- 그 이외의 `Throwable`
  - 이로울 것이 없으니 절대로 사용하지 말자.
  - `Throwable`은 정상적인 검사 예외보다 나을 게 하나도 없으면서 API 사용자를 헷갈리게 할 뿐이다.

#
### 아이템 71. 필요없는 검사 예외 사용은 피하라
- 결과로 코드를 반환하거나 비검사 예외를 던지는 것과 달리, 검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게끔 해준다.
  - 물론, 검사 예외를 과하게 사용하면 오히려 쓰기 불편한 API가 된다.
  - 어쨌든 검사 예외를 던지면, 이를 호출하는 코드에서는 catch 블록을 두어 그 예외를 붙잡아 처리하거나 더 바깥으로 던져 문제를 전파해야만 한다. 이는 API 사용자에게 부담을 준다.
  - 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없기 때문에 자바 8부터 부담이 더욱 커졌다.
  - 특히 메서드가 단 하나의 검사 예외만 던질 때가 API 사용자에게 부담이 가장 크다. 호출하는 쪽에서 try 블록과 스트림에서 직접 사용하지 못 하기 때문이다.
- 검사 예외를 회피하는 방법
  - 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다. (가장 쉬운 방법)
    - 검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환하면 된다.
    - 이 방식의 단점은 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다는 것이다.
  - 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꾼다.
    - 첫 번째 메서든 예외가 던져질지 여부를 boolean 값으로 반환하여, if 문을 선언해 처리한다.
    - 그러나 첫 번째 메서드는 상태 검사 메서드의 일종으로 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인에 의해 상태가 변할 수 있다면 적절하지 않다.

#
### 아이템 72. 표준 예외를 사용하라
- 숙련된 프로그래머일수록 더 많은 코드를 재사용한다.
  - 예외도 마찬가지로 재사용하는 것이 좋다.
  - 자바 라이브러리는 대부분  API에서 쓰기에 좋은 충분한 수의 예외를 제공한다.
- 표준 예외를 재사용하면 얻는 것이 많다.
  - 가장 좋은 점은 여러분의 API가 다른 사람이 익히고 사용하기 쉬워진다는 것이다. 많은 프로그래머에게 이미 익숙해진 규약을 그대로 따르기 때문이다.
  - 예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸린다.
- 많이 사용되는 예외들
  - `IllegalArgumentException` - 호출자가 인수로 부적절한 값을 넘길 때,
  - `IllegalStateException` - 대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때, 인수 값이 무엇이었든 어차피 실패했을 때
    - 특수한 경우엔 구분하여 사용하기 : `NullPointerException`, `IndexOutOfBoundException`
  - `ConcurrentModificationException` - 단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때
  - `UnsupportedOperationException` - 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때
- `Exception`, `RuntimeException`, `Throwable`, `Error`는 직접 재사용하지 말자. 이 클래스들은 추상 클래스라고 생각하자.
- 상황에 부합한다면 항상 표준 예외를 사용하자.
  - 이때 API 문서를 참고해 그 예외가 어떤 상황에서 던져지는지 꼭 확인해야 한다.
  - 예외의 이름뿐 아니라 예외가 던져지는 맥락도 부합할 때만 재사용한다.
  - 더 많은 정보를 제공하길 원한다면 표준 예외를 확장해도 좋다. 단, 예외는 직렬화할 수 있다는 사실을 기억하자.

#
### 아이템 73. 추상화 수준에 맞는 예외를 던지라
- 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다. (= exception translation, 예외 번역)
  - 예외를 번역할 때, 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄(exception chaining, 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식)을 사용하는 게 좋다.
- 무턱대로 예외를 전파하는 것보다야 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 곤란하다.
  - 가능하다면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.
  - 때론 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 미리 검사하는 방법으로 이 목적을 달성할 수 있다.
  - 아래 계층에서의 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리하여 문제를 API 호출자에까지 전파하지 않는 방법이 있다. 이때는 로깅을 활용하면 좋다.

#
### 아이템 74. 메서드가 던지는 모든 예욀르 문서화하라
- 예외는 그 메서드를 올바로 사용하는 데 아주 중요한 정보다. 예외 하나하나 문서화하는데 충분한 시간을 들여야 한다.
- 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자.
  - 공통 상위 클래스 하나로 뭉뚱그려 선언하는 일은 삼가자.
- 비검사 예외도 검사 예외처럼 정성껏 문서화하면 좋다.
  - 비검사 예외 = 프로그래밍 오류
  - 자신이 일으킬 수 있는 오류들이 무엇인지 알려주면 프로그래머는 자연스럽게 해당 오류가 나지 않도록 코딩하게 된다.
- 메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.
- 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 (각각의 메서드가 아닌) 클래스 설명에 추가하는 방법도 있다.

#
### 아이템 75. 예외의 상세 메시지에 실패 관련 정보를 담으라
- 사후 분석을 위해 실패 순간의 상황을 정확히 포착해 예외의 상세 메시지에 담아야 한다.
- 실패 순간을 포착하려면 발생하 예외에 관련된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다.
  - 다만 문서와 소스코드에서 얻을 수 있는 정보는 길게 늘어놔봐야 군더더기가 될 뿐이다.
- 예외의 상세 메시지와 최종 사용자에게 보여줄 오류 메시지를 혼동해서는 안 된다.
  - 최종 사용자에게는 친절한 안내 메시지를 보여줘야 하는 반면, 예외 메시지는 가독성보다는 담긴 내용이 훨씬 중요하다.
- 실패를 적절히 포착하려면 필요한 정보를 예외 생성자에 모두 받아서 상세 메시지까지 미리 생성해 놓는 방법도 괜찮다.
- 예외는 실패와 관련한 정보를 얻을 수 있는 접근자 메서드를 적절히 제공하는 것이 좋다.
  - 포착한 실패 정보는 예외 상황을 복구하는데 유용할 수 있으므로 접근자 메서드는 비검사 예외보다는 검사 예외에서 더 빛을 발한다.

#
### 아이템 76. 가능한 한 실패 원자적으로 만들라
- 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다. 이를 실패 원자적(failure-atomic)이라 한다.
- 방법 1. 가장 간단한 방법은 불변 객체로 설계
  - 불변 객체는 태생적으로 실패 원자적이다. 불변 객체는 생성 시점에 고정되어 절대 변하지 않기 때문이다.
- 방법 2. 가변 객체의 메서드를 실패 원자적으로 만드는 가장 흔한 방법은 작업 수행에 앞서 매개변수의 유효성을 검사
  - 객체의 내부 상태를 변경하기 전에 잠재적 예외의 가능성을 대부분 걸러낼 수 있다.
  - 실패할 가능성이 있는 모든 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치하는 방법
- 방법 3. 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 것
  - 데이터를 임시 자료구조에 저장해 작업하는 게 더 빠를 때 적용하기 좋은 방식
- 방법 4. 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리기
  - 주로 내구성(durablility)를 보장해야 하는 자료구조에 쓰임. (자주 사용되지 않음)
- 실패 원자성은 일반적으로 권장되나, 항상 달성할 수 있는 것은 아니다.
- 실패 원자성을 항상 달성해야 하는 것도 아니다.
  - 실패 원자성을 달성하기 위한 비용이나 복잡도가 아주 큰 연산도 존재하기 때문.
- 메서드 명세에 기술한 예외라면 설혹 예외가 발생하더라도 객체의 상태는 메서드 호출 전과 똑같이 유지돼야 한다는 것이 기본 규칙이다.
  - 이를 지키지 못하면 객체 상태를 API 설명에 명시해야 한다. 

#
### 아이템 77. 예외를 무시하지 말라
- API 설계자가 메서드 선언에 예외를 명시하는 까닭은, 그 메서드를 사용할 때 적절한 조치를 취해달라고 말하는 것이다.
- 예외는 문제 상황에 잘 대처하기 위해 존재하는데 catch 블록을 비워두면 예외가 존재할 이유가 없어진다.
- 예외를 무시하기로 했다면 catch 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 ignored로 바꿔놓도록 하자.
```java
Future<Integer> f = exec.submit(planarMap::chromaticNumber);
int numColors = 4;
try {
  numColors = f.get(1L, TimeUnit.SECONDS);
} catch (TimeoutException | ExcutionException ignored) {
}
```
- 예측할 수 있는 예외 상황이든 프로그래밍 오류든, 빈 catch 블록으로 못 본 척 지나치면 그 프로그램은 오류를 내재한 채 동작하게 된다. 그러다 어느 순간 문제의 원인과 아무 상관없는 곳에서 갑자기 죽어버릴 수도 있다.
- 예외를 적절히 처리하면 오류를 완전히 피할 수도 있다. 무시하지 않고 바깥으로 전파되게만 놔둬도 최소한 디버깅 정보를 남긴 채 프로그램이 신속히 중단되게는 할 수 있다.
