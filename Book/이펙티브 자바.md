# 4. 클래스와 인터페이스
### 아이템 15 클래스와 멤버의 접근 권한을 최소화하라
- 잘 설계된 컴포넌트
  - 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 잘 숨긴 컴포넌트
  - 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리
  - 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않음.
  - = 정보 은닉, 캡슐화
- 정보 은닉의 장점
  - 시스템 개발 속도를 높임. 여러 컴포넌트를 병렬로 개발 가능하기 때문
  - 시스템 관리 비용을 낮춤. 각 컴포넌트를 빠르게 파악하고 디버깅 가능하며, 다른 컴포넌트로 교체하는 부담도 적음
  - 성능 최적화에 도움을 줌. 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문
  - 소프트웨어 재사용성을 높임.
  - 큰 시스템을 제작하는 난이도를 낮춤. 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문.
- 자바에서 정보 은닉의 핵심 : 접근 제한자
- 기본 원칙 : 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 함.
  - 패키지 외부에서 쓸 이유가 없다면 package-private으로 선언하기. (public -> package-private)
  - 클래스의 공개 API를 세심히 설계 후, 그 외의 모든 멤버는 private하게 만들기.
  - 그 다음 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private으로 풀어주기.
  - protected부터 그 멤버에 접근할 수 있는 대상 범위가 엄청나게 넓어지므로, protected 멤버의 수는 적을수록 좋다.
  - 테스트만을 위해 클래스, 인터페이스, 멤버를 공개 API로 만들어서는 안 된다.
  - public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
  - public 가변 필드는 갖는 클래스는 일반적으로 스레드 안전하지 않다.
    - 예외 : 해당 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 구성요소로써의 상수라면 public static final 필드로 공개해도 좋음.
  - 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.
#### 질문
- p.98 "Serializable을 구현한 클래스에서는 그 필드도 의도치 않게 공개 API가 될 수도 있다"의 의미 (+ Serializalble이란? 직접 관리하지 않아도 되는 이유?)
  - 참고자료 : **자바 직렬화, 그것이 알고싶다.** [훑어보기편](https://techblog.woowahan.com/2550/), [실무편](https://techblog.woowahan.com/2551/)
  - Serializable(직렬화)란, 자바 시스템 내부에서 사용되는 객체/데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터를 변환하는 기술과, 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)을 아우르는 것.
  - 시스템적으로 표현하자면, JVM(Java Virtual Machine)의 메모리에 상주(힙/스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술과 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태
  - 자바 직렬화 조건 : 자바 기본(primitive) 타입과 `java.io.Serializable` 인터페이스를 상속받은 객체
  - 직렬화방법 : `java.io.ObjectOutputStream` 객체 이용
  - 역직렬화 조건 : 직렬화 대상이 된 객체의 클래스가 Class Path에 존재해야 하며 import 되있어야 함.
    - 중요한 점은 직렬화와 역직렬화를 진행하는 시스템이 서로 다를 수 있음을 고려해야 함.
    - 직렬화 대상 객체는 동일한 serialVersionUID를 가지고 있어야 함.
  - 자바 직렬화를 하는 이유 : 자바 시스템 간의 데이터를 교환하기 위해서 존재.
  - 자바에서 CSV, JSON 대신 자바 직렬화를 써야 하는 이유 : 정답은 없음. 목적에 따라 적절하게 써야 함.
  - 자바 직렬화의 장점 
    - 자바 시스템에서 개발에 최적화되어 있음.
    - 복잡한 데이터 구조의 클래스의 객체라도 직렬화 기본 조건만 지키면 큰 작업 없이 바로 (역)직렬화 가능
  - 자바 직렬화 사용
    - JVA의 메모리에서만 상주되어있는 객체 데이터를 영속화(Persistence)가 필요할 때 사용. 시스템이 종료되더라도 없어지지 않는 장점이 있음. 이는 네트워크로 전송도 가능. 필요할 때 직렬화된 객체 데이터를 가져와서 역직렬화하여 객체를 바로 사용할 수 있게 됨.
  - 자바 직렬화의 단점 : 역직렬화시 클래스 구조 변경 문제
    - SUID(serialVersionUID)는 필수 값이 아니다. 호환 가능한 클래스는 SUID 값이 고정되어 있다. SUID가 선언되어 있지 않으면 클래스의 기본 해쉬값을 사용.
    - "조금이라도 역직렬화 대상 클래수 구조가 바뀌면 에러가 발생해야 한다." 정도의 민감한 시스템이 아닌 이상은 클래스를 변경할 때에 직접 serialVersionUID 값을 관리해주어야 클래스 변경 시 혼란을 줄일 수 있음.
    - 그러나 serialVersionUID가 동일하더라도 멤버의 타입을 변경하면 역직렬화 불가.
  - 자바 직렬화의 단점 : 용량 문제
    - 타입에 대한 정보, 클래스의 메타 정보 등을 가지고 있기 때문에 상대적으로 다른 포맷(CSV, JSON 등)에 비해 용량이 큼.
    - 이를 메모리 서버(Redis 등)에 저장하는 형태의 시스템에서는 문제가 될 가능성이 높음.
    - 자바 개발의 높은 생산성 때문에 사용하더라도, 메모리 서버의 트래픽이 증가한다면 JSON 등 다른 형태의 직렬화로 바꿔주는 것을 고려해야 함.
  - 자바 직렬화의 단점 : 호환성
    - 자바 직렬화를 사용해서 외부 데이터를 저장하면 사실상 자바에서만 읽을 수 있음.
  - 정리
    - 특별한 문제가 없으면 자바 직렬화 버전 serialVersionUID의 값은 개발 시 직접 관리해야 함.
    - serialVersionUID의 값이 동일하면 멤버 변수 및 메서드 추가는 크게 문제가 되지 않음. 멤버 변수 제거 및 이름 변경은 오류는 발생하지 않지만 데이터는 누락됨.
    - 역직렬화 대상의 클래스의 멤버 변수 타입 변경을 지양해야 함. 자바 역직렬화는 타입에 엄격함.
    - 외부(DB, 캐시 서버 등)에 장기간 저장될 정보는 자바 직렬화 사용을 지양해야 함. 역직렬화 대상의 클래스가 언제 변경이 일어날지 모르는 환경에서 긴 시간 동안 외부에 존재했던 직렬화된 데이터는 쓰레기(Garbage)가 될 가능성이 높음.
    - 개발자가 직접 컨트롤이 가능한 클래스의 객체가 아닌 클래스의 객체(=프레임워크/라이브러리에서 제공하는 객체)에 대해서는 직렬화를 지양해야 함. 버전이 바뀔 때마다 클래스 내용이 바뀌면 대처하기 힘듦.
  - 결론
    - 자바 직렬화를 사용할 때에는 될 수 있으면 자주 변경되는 클래스의 객체는 사용 안 하는 것이 좋음. 변경에 취약하기 때문에 생각지도 못한 예외가 발생할 가능성이 높음.
    - 특히 역직렬화가 되지 않을 때와 같은 예외처리는 기본적으로 해두는 것을 권장.
  - 권장 사항
    - 외부 저장소로 저장되는 데이터는 짧은 만료시간의 데이터를 제외하고 자바 직렬화 사용을 지양
    - 역직렬화시 반드시 예외가 생긴다는 것을 고려하기
    - 자주 변경되는 비즈니스적인 데이터는 자바 직렬화 사용 지양
    - 긴 만료 시간을 가지는 데이터는 JSON 등 다른 포맷을 사용하여  

#
### 아이템 16 public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
- public 클래스는 절대 가변 필드를 직접 노출(public)해서는 안 된다.
- 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다.
- 패키지 바깥에서 접근할 수 있는 클래스(public)라면 접근자(getter)를 제공해서 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 취하자.
- package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다.

#
### 아이템 17 변경 가능성을 최소화하라
- 불변 클래스 
  - 그 인스턴스의 내부 값을 수정할 수 없는 클래스
  - 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전
- 불변 클래스를 만드는 5가지 규칙
  - 객체의 상태를 변경하는 메서드(변경자, setter)를 제공하지 않는다.
  - 클래스를 확장할 수 없도록 한다.
  - 모든 필드를 final로 선언한다. (설계자의 의도를 명확히 드러내기)
  - 모든 필드를 private으로 선언한다. (직접 수정을 막는다.)
  - 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
- 함수형 프로그래밍
  - 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴
  - 그 반대는 절차적/명령형 프로그래밍 (= 메서드에서 피연산자인 자신을 수정해 자신의 상태가 변하게 함)
  - 함수형 프로그래밍을 하면 코드에서 불변이 되는 영역의 비율이 높아지는 장점을 누릴 수 있다.
- "불변 객체는 단순하다." 
  - 따라서 불변 객체는 근본적으로 스레드 안전하며 따로 동기화할 필요가 없다. 여러 스레드가 동시에 사용해도 절대 훼손되지 않는다. 불변 객체는 안심하고 공유할 수 있다.
  - 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용하기 (ex. public static final)
  - 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
  - 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.
  - 불변 객체는 그 자체로 실패 원자성(메서드에서 예외가 발생한 후에도 그 객체는 여전히 메서드 호출 전과 같은 유효한 상태인 성질)을 제공한다.
  - 단점이라면 값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이다.
- 불변 클래스를 만드는 또 다른 설계 방법
  - 가장 쉬운 방법 : final 클래스 선언
  - 더 유연한 방법 : 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공하는 방법
- 모든 필드가 final이고 어떤 메서드도 그 객체를 수정할 수 없어야 한다는 규칙은 과한 감이 있음.
  - 살짝 완화하자면, 어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없어야 한다.
  - 계산 비용이 큰 값을 처음 쓰일 때 계산하여 final이 아닌 필드에 캐싱하는 방법을 쓸 수도 있다.
#### 정리
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
  - 불변으로 인해 계산 등의 특정 상황에서 잠재적 성능 문제가 있는 경우 가변 동반 클래스를 고려하자.
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
- 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
  - 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안 된다.
#### 질문
- p.110 다단계 연산(multistep opertaion)과 가변 동반 클래스(companion class)란?

#
### 아이템 18 상속보다는 컴포지션을 사용하라
- 상속은 코드 재사용성이 좋지만 항상 최선은 아니다.
  - 일반적인 구체 클래스를 패키지 경계를 넘어, 즉 다른 패키지의 구체 클래스를 상속하는 일은 위험하다. (인터페이스 상속과는 무관)
- 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다. 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
  - 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있다.
  - 그 여파로 하위 클래스가 오작동할 수 있다.
  - 상위 클래스 설계자가 확장을 충분히 고려하고 문서화도 제대로 해두지 않으면 하위 클래스는 상위 클래스의 변화에 발맞춰 수정돼야만 한다.
- 해결책 : 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자.
  - 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 컴포지션(composition)이라고 함.
  - 새 클래스의 인스턴스 메서드들은 기존 클래스에 대응하는 메서드를 호출해 그 결과를 반환함. 이를 전달(forwarding)이라고 하며, 새 클래스의 메서드들은 전달 메서드(forwarding method)라고 함.
  - 그 결과 새로운 클래스에 새로운 메서드가 추가되더라도 전혀 영향을 받지 않음.
  - 래퍼 클래스 (다른 인스턴스를 감싼다는 의미) + 데코레이터 패턴(기능을 덧씌움)
  - 컴포지션과 전달의 조합은 넓은 의미로 위임이라고 부름. (래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우)
  - 래퍼 클래스는 단점이 거의 없으나, 콜백(callback) 프레임워크와는 어울리지 않는다는 점만 주의하면 된다.
  - 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 컴포지션을 활용하라.
- 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다. 즉 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 한다. 
  - "B가 정말 A인가?"
  - 그렇다고 확신할 수 없다면 B는 A를 상속하면 안 된다. A를 private 인스턴스로 두고, A와는 다른 API를 제공해야 하는 상황이 대다수
  - 즉, A는 B의 필수 구성요소가 아니라 구현하는 방법 중 하나
  - 컴포지션을 써야 할 상황에서 상속을 사용하는 것은 내부 구현을 불필요하게 노출하는 꼴이다.
  - 상속을 사용하기로 결정했다면, 확장하려는 클래스의 API에 아무런 결함이 없는가? 결함이 있다면 이 결함이 우리 클래스의 API까지 전파돼도 괜찮은가? 자문하자.
  - 컴포지션으로는 결함을 숨기는 새로운 API를 설계할 수 있지만, 상속은 상위 클래스의 API를 그 결함까지도 그대로 승계한다.
#### 질문
- p.119 콜백 프레임워크란? (대표적인 콜백 프레임워크와 예시 코드) 그리고 래퍼 클래스가 콜백 프레임워크와 어울리지 않는 상세한 이유.
- 
