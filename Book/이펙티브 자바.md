# 4. 클래스와 인터페이스
### 아이템 15 클래스와 멤버의 접근 권한을 최소화하라
- 잘 설계된 컴포넌트
  - 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 잘 숨긴 컴포넌트
  - 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리
  - 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않음.
  - = 정보 은닉, 캡슐화
- 정보 은닉의 장점
  - 시스템 개발 속도를 높임. 여러 컴포넌트를 병렬로 개발 가능하기 때문
  - 시스템 관리 비용을 낮춤. 각 컴포넌트를 빠르게 파악하고 디버깅 가능하며, 다른 컴포넌트로 교체하는 부담도 적음
  - 성능 최적화에 도움을 줌. 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문
  - 소프트웨어 재사용성을 높임.
  - 큰 시스템을 제작하는 난이도를 낮춤. 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문.
- 자바에서 정보 은닉의 핵심 : 접근 제한자
- 기본 원칙 : 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 함.
  - 패키지 외부에서 쓸 이유가 없다면 package-private으로 선언하기. (public -> package-private)
  - 클래스의 공개 API를 세심히 설계 후, 그 외의 모든 멤버는 private하게 만들기.
  - 그 다음 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private으로 풀어주기.
  - protected부터 그 멤버에 접근할 수 있는 대상 범위가 엄청나게 넓어지므로, protected 멤버의 수는 적을수록 좋다.
  - 테스트만을 위해 클래스, 인터페이스, 멤버를 공개 API로 만들어서는 안 된다.
  - public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
  - public 가변 필드는 갖는 클래스는 일반적으로 스레드 안전하지 않다.
    - 예외 : 해당 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 구성요소로써의 상수라면 public static final 필드로 공개해도 좋음.
  - 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.

#
### 아이템 16 public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
- public 클래스는 절대 가변 필드를 직접 노출(public)해서는 안 된다.
- 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다.
- 패키지 바깥에서 접근할 수 있는 클래스(public)라면 접근자(getter)를 제공해서 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 취하자.
- package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다.

#
### 아이템 17 변경 가능성을 최소화하라
- 불변 클래스 
  - 그 인스턴스의 내부 값을 수정할 수 없는 클래스
  - 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전
- 불변 클래스를 만드는 5가지 규칙
  - 객체의 상태를 변경하는 메서드(변경자, setter)를 제공하지 않는다.
  - 클래스를 확장할 수 없도록 한다.
  - 모든 필드를 final로 선언한다. (설계자의 의도를 명확히 드러내기)
  - 모든 필드를 private으로 선언한다. (직접 수정을 막는다.)
  - 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
- 함수형 프로그래밍
  - 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴
  - 그 반대는 절차적/명령형 프로그래밍 (= 메서드에서 피연산자인 자신을 수정해 자신의 상태가 변하게 함)
  - 함수형 프로그래밍을 하면 코드에서 불변이 되는 영역의 비율이 높아지는 장점을 누릴 수 있다.
- "불변 객체는 단순하다." 
  - 따라서 불변 객체는 근본적으로 스레드 안전하며 따로 동기화할 필요가 없다. 여러 스레드가 동시에 사용해도 절대 훼손되지 않는다. 불변 객체는 안심하고 공유할 수 있다.
  - 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용하기 (ex. public static final)
  - 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
  - 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.
  - 불변 객체는 그 자체로 실패 원자성(메서드에서 예외가 발생한 후에도 그 객체는 여전히 메서드 호출 전과 같은 유효한 상태인 성질)을 제공한다.
  - 단점이라면 값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이다.
- 불변 클래스를 만드는 또 다른 설계 방법
  - 가장 쉬운 방법 : final 클래스 선언
  - 더 유연한 방법 : 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공하는 방법
- 모든 필드가 final이고 어떤 메서드도 그 객체를 수정할 수 없어야 한다는 규칙은 과한 감이 있음.
  - 살짝 완화하자면, 어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없어야 한다.
  - 계산 비용이 큰 값을 처음 쓰일 때 계산하여 final이 아닌 필드에 캐싱하는 방법을 쓸 수도 있다.
#### 정리
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
  - 불변으로 인해 계산 등의 특정 상황에서 잠재적 성능 문제가 있는 경우 가변 동반 클래스를 고려하자.
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
- 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
  - 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안 된다.
#
### 아이템 18 상속보다는 컴포지션을 사용하라
- 상속은 코드 재사용성이 좋지만 항상 최선은 아니다.
  - 일반적인 구체 클래스를 패키지 경계를 넘어, 즉 다른 패키지의 구체 클래스를 상속하는 일은 위험하다. (인터페이스 상속과는 무관)
- 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다. 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
  - 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있다.
  - 그 여파로 하위 클래스가 오작동할 수 있다.
  - 상위 클래스 설계자가 확장을 충분히 고려하고 문서화도 제대로 해두지 않으면 하위 클래스는 상위 클래스의 변화에 발맞춰 수정돼야만 한다.
- 해결책 : 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자.
  - 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 컴포지션(composition)이라고 함.
  - 새 클래스의 인스턴스 메서드들은 기존 클래스에 대응하는 메서드를 호출해 그 결과를 반환함. 이를 전달(forwarding)이라고 하며, 새 클래스의 메서드들은 전달 메서드(forwarding method)라고 함.
  - 그 결과 새로운 클래스에 새로운 메서드가 추가되더라도 전혀 영향을 받지 않음.
  - 래퍼 클래스 (다른 인스턴스를 감싼다는 의미) + 데코레이터 패턴(기능을 덧씌움)
  - 컴포지션과 전달의 조합은 넓은 의미로 위임이라고 부름. (래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우)
  - 래퍼 클래스는 단점이 거의 없으나, 콜백(callback) 프레임워크와는 어울리지 않는다는 점만 주의하면 된다.
  - 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 컴포지션을 활용하라.
- 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다. 즉 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 한다. 
  - "B가 정말 A인가?"
  - 그렇다고 확신할 수 없다면 B는 A를 상속하면 안 된다. A를 private 인스턴스로 두고, A와는 다른 API를 제공해야 하는 상황이 대다수
  - 즉, A는 B의 필수 구성요소가 아니라 구현하는 방법 중 하나
  - 컴포지션을 써야 할 상황에서 상속을 사용하는 것은 내부 구현을 불필요하게 노출하는 꼴이다.
  - 상속을 사용하기로 결정했다면, 확장하려는 클래스의 API에 아무런 결함이 없는가? 결함이 있다면 이 결함이 우리 클래스의 API까지 전파돼도 괜찮은가? 자문하자.
  - 컴포지션으로는 결함을 숨기는 새로운 API를 설계할 수 있지만, 상속은 상위 클래스의 API를 그 결함까지도 그대로 승계한다.
