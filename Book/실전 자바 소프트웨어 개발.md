# CHAPTER 2 입출금 내역 분석기

# CHAPTER 3 입출금 내역 분석기 확장판
- 배울 내용
  - 개방/폐쇄 원칙 (OCP, open/closed principle)
    - 코드 베이스에 유연성을 추가하고 유지보수성을 개선하는 데 도움을 준다.
  - 인터페이스에 대한 일반적인 가이드라인
  - 높은 결합도를 피하는 기법
  - 자바의 예외 처리 방법
    - 언제 API에 예외를 포함하거나 포함하지 않을지를 결정
  - 자바 프로젝트를 시스템적systematically으로 빌드하는 방법
    - Maven, Gradle 같은 검증된 빌드 도구를 사용

### 개방/폐쇄 원칙
- '이 메서드를 어디에 정의해야 할까?'에 대한 고민
  - 이미 새로 클래스를 이미 추가한 상황에서,
  - 여러 이름이 생기면서 다양한 동작 간의 관계를 이해하기가 어려워지고,
  - 전체 프로젝트가 복잡해진다면,
  - -> 메서드를 추가하려고 클래스를 새로 만들어도 크게 좋은 것이 없다.
  - 조금만 더 넓게 생각해서, 현재 있는 클래스 중에 가장 유사한 기능을 처리하는 클래스 안에 정의하면, 나중에 관련 메서드를 더 쉽게 찾을 수 있다.
- 중복 코드는 소프트웨어를 불안정하게 만든다.
  - 특히 요구 사항이 자주 바뀔수록 영향이 커진다.
  - 반복하면서 수행하는 로직을 바꾸려면 여러 장소에서 이를 모두 찾아 바꿔야 한다.
- OCP의 장점
  - 기존 코드를 바꾸지 않으므로 기존 코드가 잘못될 가능성이 줄어든다.
  - 코드가 중복되지 않으므로 기존 코드의 재사용성이 높아진다.
  - 결합도가 낮아지므로 유지보수성이 좋아진다.

#### 개방/폐쇄 원칙은 이런 상황에 적용한다.
- 예제(입출금 내역 분석기)의 문제 상황
  - 요구 사항이 복잡해질수록, 객체(엔티티)의 여러 속성을 조합할수록 코드가 점점 복잡해진다.
  - 반복 로직과 비즈니스 로직이 결합되어 분리하기가 어려워진다.
  - 코드를 반복한다.
- OCP를 통해서,
  - 코드를 직접 바꾸지 않고 해당 메서드나 클래스의 동작을 바꿀 수 있다.
  - 반복 로직과 비즈니스 로직이 결합되어 있을 때에는 인터페이스를 이용해 이런 결합을 제거할 수 있다.
- 예시 - `Predicate<T>`와 같은 함수형 인터페이스
  - 기존 메서드의 바디를 바꿀 필요 없이 새로운 구현을 인수로 전달
    - 새로운 구현을 인수로 전달할 때는 그때마다 구현 클래스를 만들지 않고, 람다 표현식을 사용한다.
    - 즉, 이름 없이 인터페이스 구현 객체를 코드 블록 형태로 전달한다.
  - 따라서 변경 없이도closed 확장성은 개방open된다.
  - 이러한 방식으로 기능을 확장하면 기존에 이미 구현하고 검증한 코드를 바꾸는 일을 최소화할 수 있으므로 새로운 버그가 발생할 만한 대상을 줄일 수 있다.
  - 예전 코드를 바꾸지 않고도 새로운 기능을 추가할 수 있기 때문이다.

### 인터페이스 문제
- 한 인터페이스에 모든 기능을 추가하는 갓 인터페이스를 만드는 일은 피해야 한다.
