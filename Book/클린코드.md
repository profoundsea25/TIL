> [한달한권 클린코드](https://zero-base.co.kr/category_dev_camp/cleancode_1book)를 보며 공부한 것을 정리한 내용입니다.

# 1. 클린 코드와 그 첫걸음 네이밍 p.1~38
### 나쁜 코드
- 성능이 나쁜 코드
  - 불필요한 연산이 들어가서 개선의 여지가 있는 코드
- 의미가 모호한 코드
  - 이해하기 어려운 코드
  - 네이밍과 그 내용이 다른 코드
- 중복된 코드
  - 비슷한 내용인데 중복되는 코드들은 버그를 낳는다.
### 나쁜 코드가 나쁜 이유
- 깨진 유리창 법칙
  - 나쁜 코드는 깨진 유리창처럼 계속 나쁜 코드가 만들어지도록 한다. 쇠퇴의 시작.
- 생산성 저하
  - 나쁜 코드는 팀 생산성을 저하시킨다. 
  - 기술부채를 반들어 수정을 더 어렵게 한다.
- 새로운 시스템을 만들어야 한다
  - 현 시스템을 유지보수하여 대체할 새로운 시스템 개발은 현실적으로 매우 어렵다.
### 나쁜 코드를 짜는 이유
- 일정이 촉박해서
  - 일정 안에 새로운 기능을 완성해야 한다.
  - 하지만, 나쁜 코드는 생산성을 저하하기 때문에 오히려 일정을 못 맞춘다.
- 영향 범위가 넓어서
  - 생각보다 영향 범위가 넓어서 건드렸다가 다른 부분에 버그가 발생할까봐
  - 하지만 기술부채는 부메랑처럼 다시 돌아온다.
##
### 클린 코드
- "깨끗한 코드는 한 가지를 제대로 한다."
- "깨끗한 코드는 잘 쓴 문장처럼 읽힌다."
- 성능이 좋은 코드
- 의미가 명확한 코드 = 가독성이 좋은 코드
- 중복이 제거된 코드
### 보이스카우트 룰
- 캠프장은 처음 왔을 때보다 전보다 더 깨끗하게 해야 한다.
- 전보다 더 깨끗한 코드로 만든다.
##
### 의미 있는 이름 짓기
- 의미가 분명한 이름 짓기
- 루프 속 i j k 사용하지 않기
  - advanced for문으로 i를 사용하지 않을 수 있다.
  - lamda를 사용할 수도 있다.
  - 최대한 의미를 찾을 수 있다. i j k 대신 맥락에 맞는 이름이 있다.
- 통일성 있는 단어 사용하기
  - 팀에서 협의해서 단어를 정해서 사용해야 한다.
- 변수명에 타입 넣지 않기
  - Map, List는 예외인 듯.. 특히 Map은 표현을 대체할 단어가 많지 않아서 Map을 그대로 써서 표현함.
  - Impl도 현업에서 많이 쓰기는 하는데, 구현체 이름을 명확하게 지어주는 것이 더 좋다.
  - 팀 간의 약속을 지키는 것이 좋다.
##
### Google Java Naming Guide
- Package Naming Guide
  - All lower case, no underscores
- Class Nmaing Guide
  - UpperCamelCase (대문자로 시작하는 카멜케이스)
  - 클래스는 명사, 명사구
  - 인터페이스는 명사, 명사구, (형용사)
  - 테스트 클래스는 Test로 끝나기
- Method Naming Guide
  - LowerCamelCase (소문자로 시작하는 카멜케이스)
  - 메서드는 동사, 동사구
  - jUnit 테스트에 underscore이 사용되기도 함

# 2. 함수를 안전하고 간결하게 작성하기 p.39~66
### SOLID
- SRP 단일 책임 원칙
- OCP 개방-폐쇄 원칙
- LSP 리스코프 치환 원칙
- ISP 인터페이스 분리 원칙
- DIP 의존성 역전 원칙
#### SRP 단일 책임 원칙
- 한 클래스는 하나의 책임만 가져야 한다.
- 클래스는 하나의 하나의 기능만 가지며, 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
- SRP 책임이 분명해지기 때문에, 변경에 의한 연쇄작용에서 자유로워질 수 있다.
- 가독성 향상과 유지보수가 용이해진다.
- 실전에서는 쉽지 않지만 늘 상기해야 한다!
#### OCP 개방-폐쇄 원칙
- 소프트웨어 요소는 확장에는 열러 있으나 변경에는 닫혀 있어야 한다.
- 변경을 위한 비용은 가능한 줄이고, 확장을 위한 비용은 가능한 극대화 해야 한다.
- 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소에는 수정이 일어나지 않고, 기존 구성 요소를 쉽게 확장해서 재사용한다.
- 객체 지향의 추상화와 다형성을 활용한다.
#### LSP 리스코프 치환 원칙
- 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.
- 서브 타입은 기반 타입이 약속한 규약(접근제한자, 예외 포함)을 지켜야 한다.
- 클래스 상속, 인터페이스 상속을 이용해 확장성을 획득한다.
- 다형성과 확장성을 극대화하기 위해 인터페이스를 사용하는 것이 더 좋다.
- 합성(composition)을 이용할 수도 있다.
#### ISP 인터페이스 분리 원칙
- 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
- 가능한 최소한의 인터페이스만 구현한다.
- 만약 어떤 클래스를 이용하는 클라이언트가 여러 개고, 이들이 클래스의 특정 부분만 이용한다면, 여러 인터페이스로 분류하여 클라이언트가 필요한 기능만 전달한다.
- SRP가 클래스의 단일 책임이라면, ISP는 인터페이스의 단일 책임
#### DIP 의존성 역전 원칙
- 상위 모델은 하위 모델에 의존하면 안된다. 둘 다 추상화에 의존해야 한다.
- 추상화는 세부 사항에 의존해서는 안된다. 세부 사항은 추상화에 따라 달라진다.
- 하위 모델의 변경이 상위 모듈의 변경을 요구하는 위계관계를 끊는다.
- 실제 사용관계는 그대로이지만, 추상화를 매개로 메시지를 주고 받으면서 관계를 느슨하게 만든다. 

#
### 간결한 함수 작성하기
- 작게 쪼갠다.
- 함수 내 추상화 수준을 동일하게 맞춘다.
- 한 가지만 하기(SRP), 변경에 닫게 만들기(OCP)
  - 타입에 대한 처리(혹은 분기를 나누는 행위)는 최대한 Factory에서만 (Factory 객체는 Mapping하는 객체라고 생각하자)
- 함수 인수의 갯수는 0~2개가 적당하다.
- 3개 이상인 경우는 객체를 인자로 넘기기. (추천)
  - 가변 인자(예: `String.format(String format, Object... args)`)를 넘기는 방법이 있기는 한데, 특별한 경우가 아니면 잘 사용하지 않음. 

#
### 안전한 함수 작성하기
- 안전한 함수 = 부수 효과(Side Effect) 없는 함수
- 부수 효과란, 값을 반환하는 함수가 그와 관계 없는 외부 상태를 변경하는 경우
  - 예 : 패스워드를 체크하는 함수에서 Session을 초기화

#
### 함수 리팩터링
- 기능을 구현하는 서투른 함수를 작성한다.
  - 길고, 복잡하고, 중복도 있다.
- 테스트 코드를 작성한다.
  - 함수 내부의 분기와 엣지값마다 빠짐없이 테스트하는 코드를 짠다.
- 리팩터링 한다.
  - 코드를 다듬고, 함수를 쪼개고, 이름을 바꾸고, 중복을 제거한다.

# 3. 코드를 보조하는 주석 p.67~94
### 주석을 최대한 쓰지 말자
#### 주석은 나쁜 코드를 보완하지 못한다.
- 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.
- 자신이 저지른 난장판을 주석으로 설명하지 말고 개선하는데 시간을 보내야 한다.
- 코드로도 의도를 표현할 수 있다!
#### 주석은 방치된다.
- 코드의 변화에 따라가지 못하고, 주석은 방치된다.
- 코드는 컴파일되어 호출되지만, 주석은 그저 주석이기 때문에 그 자리에 방치되고 결국 의미없는 텍스트가 되어버린다.

#
### 좋은 주석
- 구현에 대한 정보를 제공한다. (정규식의 포맷 예시 등)
- 의도와 중요성을 설명한다.
- TODO, FIXME 주석
  - TODO : 앞으로 할 일. 지금 해결하지 않지만 나중에 해야할 일을 미리 적어둘 때.
  - FIXME : 문제가 있지만, 당장 수정할 필요는 없을 때. 가능하면 빨리 수정하는게 좋다.
  - IDE에서 하이라이팅되고, 별도의 윈도우에서 볼 수 있다.

#
### 주석보다 Annotation
- Annotation = 코드에 대한 메타 데이터
- 코드의 실행 흐름에 간섭을 주기도 하고, 주석처럼 코드에 대한 정보를 줄 수 있다.
- `@Deprecated` : 컴파일러가 warning을 발생시킴. IDE에서 사용시 표시됨
- `@NotThreadSafe` : Thread Safe 하지 않음을 나타냄. (책에서는 주석으로 표현했지만 어노테이션을 많이 사용)

#
### JavaDoc
- Java 코드에서 API 문서를 HTML 형식으로 생성해주는 도구
- 클래스, 필드, 메서드 레벨에 따라 사용법이 조금씩 다르다.
- JavaDoc 빌드를 실행하면 HTML 문서가 만들어진다.
- IDE에서 Reader Mode를 사용하면 설명만 깔끔하게 볼 수 있다.

# 4. 코드의 가독성에 필수적인 포맷팅 p.95~116
### 포맷팅이 중요한 이유
- 가독성에 필수적이다.
- 코드를 수월하게 읽어나갈 수 있다.
- 아마추어처럼 보이지 않는다.
- 포맷팅으로 인해 코드를 잘못해석해 버그를 발생할 위험을 줄인다!

#
### 클린코드 포맷팅
- 적절한 길이 유지 : 200라인
  - 엄격한 규칙은 아니지만, 일반적으로 큰 파일보다는 작은 파일이 이해하기 쉽다.
  - 현업에서는 대부분의 코드들도 200라인 정도를 유지한다.
  - 코드 길이가 200라인을 넘어간다면, 클래스가 여러 개의 일을 하고 있을 수 있다. SRP 위배!
- 밀접한 개념은 서로 가까이 둔다.
  - 행 묶음은 완결된 생각 하나를 표현하기 때문에 개념은 빈 행으로 분리한다.
  - 변수는 사용되는 위치에서 최대한 가까이 선언한다.

#
### Java Class Declarations
- Class 내부 코드 순서
  - 1. static 변수
    - public -> protected -> package -> private 순서
  - 2. instance 변수
    - public -> protected -> package -> private 순서
  - 3. 생성자
  - 4. 메서드
    - public 메서드에서 호출되는 private 메서드는 그 아래에 둔다. 
    - 가독성 위주로 그룹핑

#
### Team Coding Convention
- 코딩 스타일에 관한 약속
- 개발 언어의 컨벤션이 우선인지만, 애매한 부분은 팀 컨벤션을 따른다.
- 없다면, 함께 만들어 가는 것도 좋다.
  - MySQL Convention : 컬럼명은 snake_case로 네이밍한다.
  - Team Convention : enum 타입으로 사용하는 varchar 타입의 경우 컬럼명은 \_type으로 끝나도록 네이밍한다.
- 참고할 만한 컨벤션
  - Google Java Style Guide
  - Naver Hackday Java Convention

# 5. 객체와 자료구조로 데이터 표현하기 p.117~128
### 자료구조 vs 객체
- 자료구조(Data Structure)
  - 데이터 그 자체
  - 자료를 공개한다.
  - 변수 사이에 조회 함수와 설정 함수로 변수를 다룬다고 객체가 되지 않는다. (getter, setter)
- 객체(Object)
  - 비즈니스 로직과 관련
  - 자를 숨기고, 추상화한다. 자료를 다루는 함수만 공개한다.
  - 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있다.
- 예시
```java
// 자료 구조 - 가진 프로퍼팀만 단순히 조회, 비즈니스 로직 없음
public interface Vehicle {
  double getFuelTankCapacityInGallons();
  double getGallonsOfGasoline();
}

public class Car implements Vehicle {
  double fuelTankCapacityInGallons;
  double gallonsOfGasoline;
  
  public double getFuelTankCapacityInGallons() {
    return this.fuelTankCapacityInGallons;
  }
  
  public double getFuelTankCapacityInGallons() {
    return this.gallonsOfGasoline
  }
}

// 객체 - 비즈니스 로직 존재
public interface Vehicle {
  double getPercentFuelRemain();
}

public class Car implements Vehicle {
  double fuelTankCapacityInGallons;
  double gallonsOfGasoline;
  
  public Car(double fuelTankCapacityInGallons, double gallonsOfGasoline) {
    if (fuelTankCapacityInGallons <= 0) {
      throw new IllegalArgumentException("fuelTankCapacityInGallons must be greater than zero");
    }
    this.fuelTankCapacityInGallons = fuelTankCapacityInGallons;
    this.gallonsOfGasoline = gallonsOfGasoline;
  }
  
  public double getPercentFuelRemain() {
    return this.gallonsOfGasoline / this.fuelTankCapacityInGallons * 100;
  }
}
```
- 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 함수를 고쳐야 하기 때문.
- 객체 지향 코드는 새로운 클래스를 추가하기 쉽다. 하지만 함수를 추가해야 한다.
- 상황에 맞는 선택을 하면 된다.
- 자료구조를 사용하는 절차적인 코드는 기본 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.
- 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다.
- 객체지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
- 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.

#
### 객체 - 디미터 법칙
- 휴리스틱 : 경험에 기반하여 문제를 해결하기 위해 발견한 방법
- 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다.
  - 클래스 C
  - 자신이 생성한 객체
  - 자신의 인수로 넘어온 객체
  - C 인스턴스 변수에 저장된 객체
- 쉽게 말해서 친구까지만 호출해야 하지, 친구의 친구까지 호출하지 마라. 그렇게 객체 탐색으로 줄줄이 이어지면 유지보수가 어렵다.
```java
// 객체 - 기차 충돌, 디미터의 법칙 위해
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();

// 자료구조 - OK
final String outputDir = ctxt.options.scratchDir.absolutePath;

// 객체는 자료를 숨기고 자료를 다루는 함수만 공개한다.
```

#
### DTO
- DTO(Data transfer Object) = 자료구조
- 다른 계층 간 데이터를 교환할 때 사용
- 로직 없이 필드만 갖는다.
- 일반적으로 클래스명이 Dto(or DTO)로 끝난다.
- getter/setter를 갖기도 한다.
- 참고) Beans
  - Java Beans : 데이터 표현이 목적인 자바 객체
  - 멤버 변수는 private 속성이다.
  - getter와 setter를 가진다.

#
### Active Record
- Database row를 객체에 매핑하는 패턴
- 비즈니스 로직 메서드를 추가해 객체로 취급하는 건 바람직하지 않다.
- 비즈니스 로직을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다.
- 하지만 객체가 많아지면 복잡하고, 가까운 곳에 관련 로직이 있는 것이 좋으므로 현업에서는 Entity에 간단한 메서드를 추가해 사용한다.
#### Active Record vs Data Mapper
- Active Record
  - 객체가 row를 담을 뿐 아니라 databsse에 대한 접근을 포함한다.
  - 객체의 속성을 담을 뿐 아니라, 생성 수정도 객체 안에서 수행할 수 있다.
  - 사례) Ruby on rails
- Data Mapper
  - row를 담는 객체와 database에 접근할 수 있는 객체가 분리되어 있다.
  - 객체는 값만 답고 있고, 생성, 수정 등 액션은 Mapper에서 담당한다.
  - 사례) Hibernate

# 6. 우아하게 예외 처리하기 p.129~142
### 예외 처리 방식
- 오류 코드를 리턴하지 말고, 예외를 던져라 (당연)
  - 옛날에는 오류를 나타낼 때 에러코드를 던졌다.
  - 하지만 예외를 던지는 것이 명확하고, 처리 흐름이 깔끔해진다.
- 예외를 던지고, 처리하는 방식
  - 1. 오류가 발생한 부분에서 예외를 던진다. (별도의 처리가 필요한 예외라면 checked exception으로 던진다)
  - 2. checked exception에 대한 예외처리를 하지 않는다면 메서드 선언부에 throws를 명시해야 한다.
  - 3. 예외를 처리할 수 있는 곳에서 catch 하여 처리한다.

#
### Unchecked Exception을 사용하라
- Checked vs Unchecked Exception
  - Exception을 상속하면 Checked Exception
  - 명시적인 예외처리가 필요하다.
  - ex) IOException, SQLException
  - RuntimeException을 상속하면 UncheckedException
  - 명시적인 예외처리가 필요하지 않다.
  - ex) NullPointerException, IllegalArgumentException, IndexOutOfBoundException
- 결론 : Unchecked Exception을 사용하라.
- <Effective Java> Exception에 관한 규약
  - 자바 언어 명세가 요구하는 것은 아니지만, 업계에 널리 퍼진 규약으로 Error 클래스를 상속해 하위 클래스를 만드는 일을 자제하자.
  - 즉, 사용자가 직접 구현하는 unchecked throwable은 모두 RuntimeException의 하위 클래스여야 한다.
  - Exception, RuntimeException, Error를 상속하지 않는 throwable을 만들 수도 있지만, 이러한 throwable은 정상적인 사항보다 나을 게 하나도 없으면서 API 사용자를 헷갈리게 할 뿐이므로 절대 사용하지 말자.
- Checked Exception이 나쁜 이유
  - 1. 특정 메소드에서 checked exception을 throw하고 상위 메소드에서 그 exception을 catch한다면 모든 중간단계 메소드에 exception을 throws 해야 한다.
  - 2. OCP(개발 폐쇄 원칙) 위배 : 상위 레벨 메소드에서 하위 레벨 메소드의 디테일에 대해 알아야 하기 때문에 OCP 원칙에 위배된다.
  - 3. 필요한 경우 checked exception을 사용해야 되지만 일반적인 경우 득보다 실이 많다.
- Unchecked Exception을 사용하자.

#
### Exception 잘 쓰기

#
### 실무 예외 처리 패턴

#
### 오픈소스 속 Exception 살펴보기
