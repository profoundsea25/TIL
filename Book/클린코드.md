> [한달한권 클린코드](https://zero-base.co.kr/category_dev_camp/cleancode_1book)를 보며 공부한 것을 정리한 내용입니다.

# 1. 클린 코드와 그 첫걸음 네이밍 p.1~38
### 나쁜 코드
- 성능이 나쁜 코드
  - 불필요한 연산이 들어가서 개선의 여지가 있는 코드
- 의미가 모호한 코드
  - 이해하기 어려운 코드
  - 네이밍과 그 내용이 다른 코드
- 중복된 코드
  - 비슷한 내용인데 중복되는 코드들은 버그를 낳는다.
### 나쁜 코드가 나쁜 이유
- 깨진 유리창 법칙
  - 나쁜 코드는 깨진 유리창처럼 계속 나쁜 코드가 만들어지도록 한다. 쇠퇴의 시작.
- 생산성 저하
  - 나쁜 코드는 팀 생산성을 저하시킨다. 
  - 기술부채를 반들어 수정을 더 어렵게 한다.
- 새로운 시스템을 만들어야 한다
  - 현 시스템을 유지보수하여 대체할 새로운 시스템 개발은 현실적으로 매우 어렵다.
### 나쁜 코드를 짜는 이유
- 일정이 촉박해서
  - 일정 안에 새로운 기능을 완성해야 한다.
  - 하지만, 나쁜 코드는 생산성을 저하하기 때문에 오히려 일정을 못 맞춘다.
- 영향 범위가 넓어서
  - 생각보다 영향 범위가 넓어서 건드렸다가 다른 부분에 버그가 발생할까봐
  - 하지만 기술부채는 부메랑처럼 다시 돌아온다.
##
### 클린 코드
- "깨끗한 코드는 한 가지를 제대로 한다."
- "깨끗한 코드는 잘 쓴 문장처럼 읽힌다."
- 성능이 좋은 코드
- 의미가 명확한 코드 = 가독성이 좋은 코드
- 중복이 제거된 코드
### 보이스카우트 룰
- 캠프장은 처음 왔을 때보다 전보다 더 깨끗하게 해야 한다.
- 전보다 더 깨끗한 코드로 만든다.
##
### 의미 있는 이름 짓기
- 의미가 분명한 이름 짓기
- 루프 속 i j k 사용하지 않기
  - advanced for문으로 i를 사용하지 않을 수 있다.
  - lamda를 사용할 수도 있다.
  - 최대한 의미를 찾을 수 있다. i j k 대신 맥락에 맞는 이름이 있다.
- 통일성 있는 단어 사용하기
  - 팀에서 협의해서 단어를 정해서 사용해야 한다.
- 변수명에 타입 넣지 않기
  - Map, List는 예외인 듯.. 특히 Map은 표현을 대체할 단어가 많지 않아서 Map을 그대로 써서 표현함.
  - Impl도 현업에서 많이 쓰기는 하는데, 구현체 이름을 명확하게 지어주는 것이 더 좋다.
  - 팀 간의 약속을 지키는 것이 좋다.
##
### Google Java Naming Guide
- Package Naming Guide
  - All lower case, no underscores
- Class Nmaing Guide
  - UpperCamelCase (대문자로 시작하는 카멜케이스)
  - 클래스는 명사, 명사구
  - 인터페이스는 명사, 명사구, (형용사)
  - 테스트 클래스는 Test로 끝나기
- Method Naming Guide
  - LowerCamelCase (소문자로 시작하는 카멜케이스)
  - 메서드는 동사, 동사구
  - jUnit 테스트에 underscore이 사용되기도 함

# 2. 함수를 안전하고 간결하게 작성하기 p.39~66
### SOLID
- SRP 단일 책임 원칙
- OCP 개방-폐쇄 원칙
- LSP 리스코프 치환 원칙
- ISP 인터페이스 분리 원칙
- DIP 의존성 역전 원칙
#### SRP 단일 책임 원칙
- 한 클래스는 하나의 책임만 가져야 한다.
- 클래스는 하나의 하나의 기능만 가지며, 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
- SRP 책임이 분명해지기 때문에, 변경에 의한 연쇄작용에서 자유로워질 수 있다.
- 가독성 향상과 유지보수가 용이해진다.
- 실전에서는 쉽지 않지만 늘 상기해야 한다!
#### OCP 개방-폐쇄 원칙
- 소프트웨어 요소는 확장에는 열러 있으나 변경에는 닫혀 있어야 한다.
- 변경을 위한 비용은 가능한 줄이고, 확장을 위한 비용은 가능한 극대화 해야 한다.
- 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소에는 수정이 일어나지 않고, 기존 구성 요소를 쉽게 확장해서 재사용한다.
- 객체 지향의 추상화와 다형성을 활용한다.
#### LSP 리스코프 치환 원칙
- 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.
- 서브 타입은 기반 타입이 약속한 규약(접근제한자, 예외 포함)을 지켜야 한다.
- 클래스 상속, 인터페이스 상속을 이용해 확장성을 획득한다.
- 다형성과 확장성을 극대화하기 위해 인터페이스를 사용하는 것이 더 좋다.
- 합성(composition)을 이용할 수도 있다.
#### ISP 인터페이스 분리 원칙
- 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
- 가능한 최소한의 인터페이스만 구현한다.
- 만약 어떤 클래스를 이용하는 클라이언트가 여러 개고, 이들이 클래스의 특정 부분만 이용한다면, 여러 인터페이스로 분류하여 클라이언트가 필요한 기능만 전달한다.
- SRP가 클래스의 단일 책임이라면, ISP는 인터페이스의 단일 책임
#### DIP 의존성 역전 원칙
- 상위 모델은 하위 모델에 의존하면 안된다. 둘 다 추상화에 의존해야 한다.
- 추상화는 세부 사항에 의존해서는 안된다. 세부 사항은 추상화에 따라 달라진다.
- 하위 모델의 변경이 상위 모듈의 변경을 요구하는 위계관계를 끊는다.
- 실제 사용관계는 그대로이지만, 추상화를 매개로 메시지를 주고 받으면서 관계를 느슨하게 만든다. 

#
### 간결한 함수 작성하기
- 작게 쪼갠다.
- 함수 내 추상화 수준을 동일하게 맞춘다.
- 한 가지만 하기(SRP), 변경에 닫게 만들기(OCP)
  - 타입에 대한 처리(혹은 분기를 나누는 행위)는 최대한 Factory에서만 (Factory 객체는 Mapping하는 객체라고 생각하자)
- 함수 인수의 갯수는 0~2개가 적당하다.
- 3개 이상인 경우는 객체를 인자로 넘기기. (추천)
  - 가변 인자(예: `String.format(String format, Object... args)`)를 넘기는 방법이 있기는 한데, 특별한 경우가 아니면 잘 사용하지 않음. 

#
### 안전한 함수 작성하기
- 안전한 함수 = 부수 효과(Side Effect) 없는 함수
- 부수 효과란, 값을 반환하는 함수가 그와 관계 없는 외부 상태를 변경하는 경우
  - 예 : 패스워드를 체크하는 함수에서 Session을 초기화

#
### 함수 리팩터링
- 기능을 구현하는 서투른 함수를 작성한다.
  - 길고, 복잡하고, 중복도 있다.
- 테스트 코드를 작성한다.
  - 함수 내부의 분기와 엣지값마다 빠짐없이 테스트하는 코드를 짠다.
- 리팩터링 한다.
  - 코드를 다듬고, 함수를 쪼개고, 이름을 바꾸고, 중복을 제거한다.

# 3. 코드를 보조하는 주석 p.67~94
### 주석을 최대한 쓰지 말자
#### 주석은 나쁜 코드를 보완하지 못한다.
- 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.
- 자신이 저지른 난장판을 주석으로 설명하지 말고 개선하는데 시간을 보내야 한다.
- 코드로도 의도를 표현할 수 있다!
#### 주석은 방치된다.
- 코드의 변화에 따라가지 못하고, 주석은 방치된다.
- 코드는 컴파일되어 호출되지만, 주석은 그저 주석이기 때문에 그 자리에 방치되고 결국 의미없는 텍스트가 되어버린다.

#
### 좋은 주석
- 구현에 대한 정보를 제공한다. (정규식의 포맷 예시 등)
- 의도와 중요성을 설명한다.
- TODO, FIXME 주석
  - TODO : 앞으로 할 일. 지금 해결하지 않지만 나중에 해야할 일을 미리 적어둘 때.
  - FIXME : 문제가 있지만, 당장 수정할 필요는 없을 때. 가능하면 빨리 수정하는게 좋다.
  - IDE에서 하이라이팅되고, 별도의 윈도우에서 볼 수 있다.

#
### 주석보다 Annotation
- Annotation = 코드에 대한 메타 데이터
- 코드의 실행 흐름에 간섭을 주기도 하고, 주석처럼 코드에 대한 정보를 줄 수 있다.
- `@Deprecated` : 컴파일러가 warning을 발생시킴. IDE에서 사용시 표시됨
- `@NotThreadSafe` : Thread Safe 하지 않음을 나타냄. (책에서는 주석으로 표현했지만 어노테이션을 많이 사용)

#
### JavaDoc
- Java 코드에서 API 문서를 HTML 형식으로 생성해주는 도구
- 클래스, 필드, 메서드 레벨에 따라 사용법이 조금씩 다르다.
- JavaDoc 빌드를 실행하면 HTML 문서가 만들어진다.
- IDE에서 Reader Mode를 사용하면 설명만 깔끔하게 볼 수 있다.

# 4. 코드의 가독성에 필수적인 포맷팅 p.95~116
### 포맷팅이 중요한 이유
- 가독성에 필수적이다.
- 코드를 수월하게 읽어나갈 수 있다.
- 아마추어처럼 보이지 않는다.
- 포맷팅으로 인해 코드를 잘못해석해 버그를 발생할 위험을 줄인다!

#
### 클린코드 포맷팅
- 적절한 길이 유지 : 200라인
  - 엄격한 규칙은 아니지만, 일반적으로 큰 파일보다는 작은 파일이 이해하기 쉽다.
  - 현업에서는 대부분의 코드들도 200라인 정도를 유지한다.
  - 코드 길이가 200라인을 넘어간다면, 클래스가 여러 개의 일을 하고 있을 수 있다. SRP 위배!
- 밀접한 개념은 서로 가까이 둔다.
  - 행 묶음은 완결된 생각 하나를 표현하기 때문에 개념은 빈 행으로 분리한다.
  - 변수는 사용되는 위치에서 최대한 가까이 선언한다.

#
### Java Class Declarations
- Class 내부 코드 순서
  - 1. static 변수
    - public -> protected -> package -> private 순서
  - 2. instance 변수
    - public -> protected -> package -> private 순서
  - 3. 생성자
  - 4. 메서드
    - public 메서드에서 호출되는 private 메서드는 그 아래에 둔다. 
    - 가독성 위주로 그룹핑

#
### Team Coding Convention
- 코딩 스타일에 관한 약속
- 개발 언어의 컨벤션이 우선인지만, 애매한 부분은 팀 컨벤션을 따른다.
- 없다면, 함께 만들어 가는 것도 좋다.
  - MySQL Convention : 컬럼명은 snake_case로 네이밍한다.
  - Team Convention : enum 타입으로 사용하는 varchar 타입의 경우 컬럼명은 \_type으로 끝나도록 네이밍한다.
- 참고할 만한 컨벤션
  - Google Java Style Guide
  - Naver Hackday Java Convention

# 5. 객체와 자료구조로 데이터 표현하기 p.117~128
### 자료구조 vs 객체
- 자료구조(Data Structure)
  - 데이터 그 자체
  - 자료를 공개한다.
  - 변수 사이에 조회 함수와 설정 함수로 변수를 다룬다고 객체가 되지 않는다. (getter, setter)
- 객체(Object)
  - 비즈니스 로직과 관련
  - 자를 숨기고, 추상화한다. 자료를 다루는 함수만 공개한다.
  - 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있다.
- 예시
```java
// 자료 구조 - 가진 프로퍼팀만 단순히 조회, 비즈니스 로직 없음
public interface Vehicle {
  double getFuelTankCapacityInGallons();
  double getGallonsOfGasoline();
}

public class Car implements Vehicle {
  double fuelTankCapacityInGallons;
  double gallonsOfGasoline;
  
  public double getFuelTankCapacityInGallons() {
    return this.fuelTankCapacityInGallons;
  }
  
  public double getFuelTankCapacityInGallons() {
    return this.gallonsOfGasoline
  }
}

// 객체 - 비즈니스 로직 존재
public interface Vehicle {
  double getPercentFuelRemain();
}

public class Car implements Vehicle {
  double fuelTankCapacityInGallons;
  double gallonsOfGasoline;
  
  public Car(double fuelTankCapacityInGallons, double gallonsOfGasoline) {
    if (fuelTankCapacityInGallons <= 0) {
      throw new IllegalArgumentException("fuelTankCapacityInGallons must be greater than zero");
    }
    this.fuelTankCapacityInGallons = fuelTankCapacityInGallons;
    this.gallonsOfGasoline = gallonsOfGasoline;
  }
  
  public double getPercentFuelRemain() {
    return this.gallonsOfGasoline / this.fuelTankCapacityInGallons * 100;
  }
}
```
- 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 함수를 고쳐야 하기 때문.
- 객체 지향 코드는 새로운 클래스를 추가하기 쉽다. 하지만 함수를 추가해야 한다.
- 상황에 맞는 선택을 하면 된다.
- 자료구조를 사용하는 절차적인 코드는 기본 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.
- 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다.
- 객체지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
- 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.

#
### 객체 - 디미터 법칙
- 휴리스틱 : 경험에 기반하여 문제를 해결하기 위해 발견한 방법
- 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다.
  - 클래스 C
  - 자신이 생성한 객체
  - 자신의 인수로 넘어온 객체
  - C 인스턴스 변수에 저장된 객체
- 쉽게 말해서 친구까지만 호출해야 하지, 친구의 친구까지 호출하지 마라. 그렇게 객체 탐색으로 줄줄이 이어지면 유지보수가 어렵다.
```java
// 객체 - 기차 충돌, 디미터의 법칙 위해
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();

// 자료구조 - OK
final String outputDir = ctxt.options.scratchDir.absolutePath;

// 객체는 자료를 숨기고 자료를 다루는 함수만 공개한다.
```

#
### DTO
- DTO(Data transfer Object) = 자료구조
- 다른 계층 간 데이터를 교환할 때 사용
- 로직 없이 필드만 갖는다.
- 일반적으로 클래스명이 Dto(or DTO)로 끝난다.
- getter/setter를 갖기도 한다.
- 참고) Beans
  - Java Beans : 데이터 표현이 목적인 자바 객체
  - 멤버 변수는 private 속성이다.
  - getter와 setter를 가진다.

#
### Active Record
- Database row를 객체에 매핑하는 패턴
- 비즈니스 로직 메서드를 추가해 객체로 취급하는 건 바람직하지 않다.
- 비즈니스 로직을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다.
- 하지만 객체가 많아지면 복잡하고, 가까운 곳에 관련 로직이 있는 것이 좋으므로 현업에서는 Entity에 간단한 메서드를 추가해 사용한다.
#### Active Record vs Data Mapper
- Active Record
  - 객체가 row를 담을 뿐 아니라 databsse에 대한 접근을 포함한다.
  - 객체의 속성을 담을 뿐 아니라, 생성 수정도 객체 안에서 수행할 수 있다.
  - 사례) Ruby on rails
- Data Mapper
  - row를 담는 객체와 database에 접근할 수 있는 객체가 분리되어 있다.
  - 객체는 값만 답고 있고, 생성, 수정 등 액션은 Mapper에서 담당한다.
  - 사례) Hibernate

# 6. 우아하게 예외 처리하기 p.129~142
### 예외 처리 방식
- 오류 코드를 리턴하지 말고, 예외를 던져라 (당연)
  - 옛날에는 오류를 나타낼 때 에러코드를 던졌다.
  - 하지만 예외를 던지는 것이 명확하고, 처리 흐름이 깔끔해진다.
- 예외를 던지고, 처리하는 방식
  - 1. 오류가 발생한 부분에서 예외를 던진다. (별도의 처리가 필요한 예외라면 checked exception으로 던진다)
  - 2. checked exception에 대한 예외처리를 하지 않는다면 메서드 선언부에 throws를 명시해야 한다.
  - 3. 예외를 처리할 수 있는 곳에서 catch 하여 처리한다.

#
### Unchecked Exception을 사용하라
- Checked vs Unchecked Exception
  - Exception을 상속하면 Checked Exception
  - 명시적인 예외처리가 필요하다.
  - ex) IOException, SQLException
  - RuntimeException을 상속하면 UncheckedException
  - 명시적인 예외처리가 필요하지 않다.
  - ex) NullPointerException, IllegalArgumentException, IndexOutOfBoundException
- 결론 : Unchecked Exception을 사용하라.
- \<Effective Java> Exception에 관한 규약
  - 자바 언어 명세가 요구하는 것은 아니지만, 업계에 널리 퍼진 규약으로 Error 클래스를 상속해 하위 클래스를 만드는 일을 자제하자.
  - 즉, 사용자가 직접 구현하는 unchecked throwable은 모두 RuntimeException의 하위 클래스여야 한다.
  - Exception, RuntimeException, Error를 상속하지 않는 throwable을 만들 수도 있지만, 이러한 throwable은 정상적인 사항보다 나을 게 하나도 없으면서 API 사용자를 헷갈리게 할 뿐이므로 절대 사용하지 말자.
- Checked Exception이 나쁜 이유
  - 1. 특정 메소드에서 checked exception을 throw하고 상위 메소드에서 그 exception을 catch한다면 모든 중간단계 메소드에 exception을 throws 해야 한다.
  - 2. OCP(개발 폐쇄 원칙) 위배 : 상위 레벨 메소드에서 하위 레벨 메소드의 디테일에 대해 알아야 하기 때문에 OCP 원칙에 위배된다.
  - 3. 필요한 경우 checked exception을 사용해야 되지만 일반적인 경우 득보다 실이 많다.
- Unchecked Exception을 사용하자.
  - 안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지 않다는 사실이 분명해졌다.
  - C#은 확인된 예외를 지원하지 않는다. 영웅적인 시도에도 불구하고 C++ 역시 확인된 예외를 지원하지 않는다. 파이썬이나 루비도 마찬가지다.
  - 그럼에도 불구하고 C#, C++, 파이썬, 루비는 안정적인 소프트웨어를 구현하기에 무리가 없다.

#
### Exception 잘 쓰기
- 예외에 메세지를 담아라 : 예외에 의미있는 정보 담기
  - 오류가 발생한 원인과 위치를 찾기 쉽도록, 예외를 던질 때는 전후 상황을 충분히 덧붙인다.
  - 실패한 연산 이름과 유형 등 정보를 담아 예외를 담아 던진다.
- exception wrapper 사용하기
  - 이것을 사용하지 않으면 로그를 찍을 뿐 할 수 있는 일이 없다.
  - 예외를 감싸는 클래스를 만든다.
  - port.open() 시 발생하는 checked exception들을 감싸도록 port를 가지는 LocalPort 클래스를 만든다.
  - port.open()이 던지는 checked exception들을 하나의 PortDeviceFailure exception으로 감싸서 던진다.
```java
LocalPort port = new LocalPort(12);
try {
  port.open();
} catch (PortDeviceFailure e) {
  reportError(e);
  logger.log(e.getMessage(), e);
} finally {
  ...
}

public class LocalPort {
  private ACMEPort innerPort;
  public LocalPort(int portNumber) {
    innerPort = new ACMEPort(portNumber);
  }
  
  public void open() {
    try {
      innerport.open();
    } catch (DeviceResponseException e) {
      throw new PortDeviceFailure(e);
    } catch (ATM1212UnlockedException e) {
      throw new PortDeviceFailure(e);
    } catch  (GMXError e) {
      throw new PortDeviceFailure(e);
    }
  }
  ...
}
```

#
### 실무 예외 처리 패턴
#### `getOrElse` : 예외 대신 기본 값을 리턴한다.
- null이 아닌 기본 값
- 복수형의 데이터를 가져올 때는 데이터의 없음을 의미하는 컬렉션을 리턴하면 된다. null 보다 size가 0인 컬렉션이 훨씬 안전하다.
```java
List<Employee> employees = getEmployees();
  for(Employee e : employees) {
  totalPay += e.getPay();
}

public List<Employee> getEmployees() {
  if( .. there are no employees.. ) {
    return Collections.emptyList();
  }
}
```
- 도메인에 맞는 기본 값
- 예외 처리를 데이터를 제공하는 쪽에서 처리해 호출부 코드가 심플해진다.
- 코드를 읽어가며 논리적인 흐름이 끊기지 않는다.
- 도메인에 맞는 기본값을 도메인 서비스에서 관리한다.
```java
UserLevel userLevel = userService.getUserLevelOrDefault(userId);

public class UserService {
  private static final UserLevel USER_BASIC_LEVEL = UserLevel.BASIC;
  
  public UserLevel getUserLevelOrDefault(Long userId) {
    try {
      User user = userRepository.findByUserId(userId);
      return user.getUserLevel();
    } catch (UserNotFoundException e) {
      return USER_BASIC_LEVEL;
    }
  }
}
```
#### `getOrElseThrow` : (기본값이 없는 경우) null 대신 예외를 던진다.
- null 체크 지옥에서 벗어나자
- 매번 null 체크를 해야한다면 가독성 뿐 아니라 안정성도 떨어진다.
- 데이터를 제공하는 쪽에서 null 체크를 하여, 데이터가 없는 경우엔 예외를 던진다.
- 호출부에서 매번 null체크를 할 필요 없이 안전하게 데이터를 사용할 수 있다.
- 호출부의 가독성이 올라간다.
```java
User user = userService.getUserOrElseThrow(userId);

public class UserService {
  private static final UserLevel USER_BASIC_LEVEL = UserLevel.BASIC;
  
  public User getUserOrElseThrow(Long userId) {
    User user = userRepository.findByUserId(userId);
    if (user == null) {
      throw new IllegalArgumentException("User id not found. userId = " + userId)
    }
    return user;
  }
}
```
- 파라미터의 null을 점검하라.
- null을 리턴하는 것도 나쁘지만, null을 메서드로 넘기는 것은 더 나쁘다.
- null을 메서드의 파라미터로 넣어야 하는 API를 사용하는 경우가 아니라면 null을 메서드로 넘기지 마라.
- null을 파라미터로 받지 못하게 한다.
- null이 들어오면 unchecked exception을 발생시킨다.
```java
public class MetricsCalculator {
  public double xProjection(Point p1, Point p2) {
    if(p1 == null || p2 == null) {
      throw InvalidArgumentException("Invalid argument for MetricsCalculator.xProjection");
    }
    return (p2.x - p1.x) * 1.5;
  }
}
```
- assert를 통해 null이 들어오면 에러를 발생시킨다.
```java
public class MetricsCalculator {
  public double xProjection(Point p1, Point p2) {
    assert p1 != null : "p1 should not be null";
    assert p2 != null : "p2 should not be null";
    return (p2.x - p1.x) * 1.5;
  }
}
```
### 실무에서는 보통 자신의 예외를 정의한다.
- 에러 로그에서 stacktrace해봤을 때 우리가 발생시킨 예외라는 것을 바로 인지할 수 있다.
- 다른 라이브러리에서 발생한 에러와 섞이지 않는다. 우리도 IllegalArgumentException을 던지는 것보다 우리 예외로 던지는게 어느 부분에서 에러가 났는지 파악하기에 용이하다.
- 우리 시스템에서 발생한 에러의 종류를 나열할 수 있다.

#
### 오픈소스 속 Exception 살펴보기
#### from apps-android-commons
```java
/**
 * Find a bookmark from database based on its name
 *
 * @param bookmark : Bookmark to find
 * @return boolean : is bookmark in database ?
 */
public boolean findBookmark(Bookmark bookmark) {
    if (bookmark == null) {//Avoiding NPE's
        return false;
    }


    Cursor cursor = null;
    ContentProviderClient db = clientProvider.get();
    try {
        cursor = db.query(
                BookmarkPicturesContentProvider.BASE_URI,
                Table.ALL_FIELDS,
                Table.COLUMN_MEDIA_NAME + "=?",
                new String[]{bookmark.getMediaName()},
                null);
        if (cursor != null && cursor.moveToFirst()) {
            return true;
        }
    } catch (RemoteException e) {
        // This feels lazy, but to hell with checked exceptions. :)
        throw new RuntimeException(e);
    } finally {
        if (cursor != null) {
            cursor.close();
        }
        db.release();
    }
    return false;
} 
```
- 1. parameter인 bookmark가 null이면 예외를 던지지 않고 false를 리턴한다. -> Bookmark 존재여부에 대한 메서드의 목적에 부합한다.
- 2. db 리소스를 처리할 때 checked exception인 RemoteException을 별도로 처리하지 않고, RuntimeException으로 바꿔서 던졌다.
- 3. finally 블록에서 리소스를 close 처리한다. (리소스를 사용했다면 반드시 finally 블록에서 닫아줘야 한다.)

#### Elastic Search
- parameter로 들어온 format을 validation(null check)하고 IllegalArgumentException을 던진다.
- valueFetcher 메서드를 가진 ScaledFloatFieldMapper 클래스는 format을 지원하지 않기 때문에 format이 null이 아니라 존재하는 경우 예외를 발생시킨다.
- 생성자의 parameter로 들어온 값들을 validation하여 IllegalArgumentException을 던진다.

# 7. 모호한 경계를 적당히 구분짓기 p.143~152
### 경계란
- 우리가 만든 코드와 외부에서 들여온 코드의 경계
- 우리가 만든 코드에 외부에서 들어온 코드를 병합해야 한다.
- 우리 코드와 외부 코드를 깔끔하게 통합시키기 위해 경계를 잘 지어야 한다.

#
### 경계 짓기 (1) 우리 코드를 보호하기
- 캡슐화(Encapsulation) : 객체의 실제 구현을 외부로부터 감추는 방식 (public / private 구분하여 설정하는 것)
- 원하는 기능만 공개한다.
- 적절한 경계로 우리 코드를 보호한다.
```java
Map<Sensor> sensors = new HashMap<Sensor>();
Sensor s = sensors.get(sensorId);

// 위의 코드를 캡슐화를 하면,
public class Sensors {
  private Map<Sensor> sensors = new HashMap<Sensor>();
  
  public Sensor getById(String sensorId) {
    return sensors.get(sensorId);
  }
}
```

#
### 경계 짓기 (2) 외부 코드와 호환하기
- 외부 코드를 호출할 때 우리가 원하는 방식으로 사용하고 싶다! -> `Adpater 패턴` 사용
- 외부 코드를 호출할 때, 우리가 정의한 인터페이스대로 호출하기 위해 사용하는 패턴

#
### 외부 라이브러리 테스트하기 - Learning Test
- Learning Test를 작성해 라이브러리를 테스트한다.
- 외부 코드를 배우고, 안정성도 미리 검증할 수 있다.
- 이해도를 높인다.
- 외부 코드의 버전이 변경되었을 때, 우리 코드와 호환되는지 확인할 수 있다.

# 8. 깨끗한 테스트 코드 p.153~170
### 테스트 코드의 중요성
- 테스트 코드는 중요하다.
- 테스트 코드는 실수를 바로 잡아준다.
- 테스트 코드는 반드시 존재해야하며, 실제 코드 못지 않게 중요하다.
- 테스트 케이스는 변경이 쉽도록 한다. 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위테스트다. 테스트 케이스가 있으면 변경이 두렵지 않다. 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 테스트 커버리지가 높을수록 버그에 대한 공포가 줄어든다.
- 지저분한 테스트 코드는 테스트를 안하니만 못하다.
- 책 \<Effective Unit Test>
- 테스트는 자동화되어야 한다.

#
### 테스트의 종류
#### Test Pyramid
- Unit Test(70%) : 프로그램 내부의 개별 컴포넌트의 동작을 테스트한다. 배포하기 전에 자동으로 실행되도록 많이 사용한다.
- Integration Test(20%) : 프로그램 내부의 개별 컴포넌트들을 합쳐서 동작을 테스트한다. Unit Test는 각 컴포넌트를 고립시켜 테스트하기 때문에 컴포넌트의 interaction을 확인하는 Integration Test가 필요하다.
- E2E Test(10%) : Ent to End Test. 실제 유저의 시나리오대로 네트워크를 통해 서버의 Endpoint를 호출해 테스트한다.
#
### Unit Test 작성
- 테스트 라이브러리를 사용하자. 
- JUnit5 + mockito를 많이 사용한다.
#### Test Double
- 테스트에서 원본 객체를 대신하는 객체
- Stub
  - 원래의 구현을 최대한 단순한 것으로 대체한다.
  - 테스트를 위해 프로그래밍된 항목에만 응답한다.
- Spy
  - Stub의 역할을 하면서 호출에 대한 정보를 기록한다.
  - 이메일 서비스에서 메시지가 몇 번 전송되었는지 확인할 때
- Mock
  - 행위를 검증하기 위해 가짜 객체를 만들어 테스트하는 방법
  - 호출에 대한 동작을 프로그래밍할 수 있다.
  - Stub은 상태를 검증하고 Mock은 행위를 검증한다.
#### given-when-then 패턴을 사용하자.
- given : 테스트에 대한 pre-condition
- when : 테스트를 하고 싶은 동작 호출
- then : 테스트 결과 확인

#
### FIRST 원칙
- Fast : 빠르게
  - 테스트는 빨리 돌아야 한다. 자주 돌려야 하기 때문이다.
- Independent : 독립적으로
  - 각 테스트를 독립적으로 작성한다. 서로에게 의존하면 실패한 원인을 찾기 어려워진다. (다른 테스트의 실패로 인한건지, 코드 오류인지)
- Repeatable : 반복가능하게
  - 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA 환경, 모든 환경에서 돌아가야 한다.
- Self-Validating : 자가 검증하는
  - 테스트는 bool값으로 결과를 내야 한다.
- Timely : 적시에
  - 테스트하려는 실제 코드를 구현하기 직전에 구현한다.
#
### 오픈소스 속 Unit Test
- 테스트 하나에 여러 assert가 사용된다. 책에서 권장하는 방식은 아니지만, '조건'을 달리하며 테스트하는 경우 많이 사용된다.
- 팀 간의 협의(컨벤션)이 일반적인 컨벤션보다 우선이다.

# 9. 클래스 잘 설계하기 p.171~192
### 캡슐화되어야 한다
- 캡슐화(Encapsulation) : 객체의 실제 구현을 외부로부터 감추는 방식
- 클래스를 개발할 때 기본적으로 구현을 감추고, 외부 객체와 상호작용하는 부분만 노출한다.
- 외부의 잘못된 사용을 방지한다.
- 필드를 private 제한, get으로 읽기
- 수정은 특정 메서드를 통해서 일어나도록 제한

#
### 단일 책임 원칙
- 클래스가 맡은 책임이 한 개인가
- 함수와 마찬가지로 클래스도 작아야 한다.
- 함수는 라인 수로 크기를 측정했는데, 클래스는 맡은 책임의 수로 크기를 측정한다.
- 클래스 설명은 만일(if), 그리고(and), 하며(or), 하지만(but)을 사용하지 않고 25단어 내외로 가능해야 한다. = 책임이 한 가지여야 한다.
- SRP 해야한다.
- "도구상자를 어떻게 관리하고 싶은가? 작은 서랍을 많이 두고 기능과 이름이 명확한 컴포넌트를 나눠 넣고 싶은가? 아니면 큰 서랍 몇개를 두고 모두 던져 넣고 싶은가?"
- 큼직한 다목적 클래스 몇 개로 이뤄진 시스템은 (변경을 가할 때) 당장 알 필요가 없는 사실까지 들이밀어 독자를 방해한다.
- 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다.
- 자잘한 단일 클래스가 많아지면 큰 그림을 이해하기 어렵다고 우려한다. 하지만 작은 클래스가 많은 시스템이든 큰 클래스가 몇 개뿐인 시스템이든 돌아가는 부품은 그 수가 비슷하다.

#
### 낮은 결합도, 높은 응집도
- 결합도 : 다른 모듈간의 의존도
- 응집도 : 모듈 내부의 기능 집중도
- 결합도는 낮을 수록 응집도는 높을 수록 유지보수성이 좋다.
- 결합도가 높은 클래스의 문제점
  - 연관된 클래스가 변경되면 수정이 필요하다.
  - 결합도가 높으면 연관된 클래스들을 모두 이해해야 한다.
- 응집도가 낮은 클래스의 문제점
  - 여러 기능이 있으므로 이해하기 어렵다.
  - 재사용하기 어렵다.
- 결합도는 낮아야 한다.
  - 시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다.
  - DIP - 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다.
  - 추상화를 이용하면 테스트 코드 짜기에 용이하다.
  - 테스트 결과가 늘 같도록 한다.
  - 그러나 확장될 가능성이 적다면 일단은 결합하고, 나중에 추상화해도 좋다.
  - 객체를 Mocking 하면 변경되는 클래스도 테스트할 수 있다.
- 응집도는 높아야 한다.
  - 클래스는 인트턴스 변수 수가 적어야 한다. 메서드는 인스턴스 변수를 하나 이상 사용해야 한다. 메서드가 인스턴스 변수를 많이 사용할수록 응집도가 높다.
  - 응집도가 높다 = 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다 = 서로 관계있는 애들만 모여있다.
  - 클래스가 응집도를 잃어간다면 함수를 쪼개야 한다.

#
### 변경하기 쉬워야 한다
- 클래스는 변경하기 쉬워야 한다. (OCP)
- 공개 인터페이스를 전부 파생하는 클래스로 만들고,
- 비공개 메서드는 해당 클래스로 옮기고
- 공통된 인터페이스는 따로 클래스로 뺀다.
- 잘 만들어진 클래스는 수정 사항이 생겼을 때, 기존의 클래스를 건드리지 않아도 된다.

# 10. 시스템 p.193~214
### 관심사 분리
- construction(생성)과 use(사용)은 아주 다르다.
- 소프트웨어 시스템은 어플리케이션 객체를 제작하고 의존성을 서로 '연결'하는 준비 과정과 준비 과정 이후에 이어지는 런타임 로직을 분리해야 한다.
- 객체의 생성과 객체를 사용하는 부분을 분리한다.
### 시작에 대한 관심사 분리
- 객체 생성은 시작 단계에서, 비즈니스 로직은 객체를 사용하는데 집중한다.
- 시작 단계는 모든 어플리케이션이 풀어야 할 관심사이다.
- main 함수에서 시스템에 필요한 객체를 생성한 후 어플리케이션에 넘긴다.
- 어플리케이션은 그저 만들어진 객체를 사용한다.
- 모든 객체가 잘 생성되었다고 가정하고, 객체를 이용한 개발에 집중할 수 있다.
### 요청에 대한 관심사 분리
- Spring 프레임워크를 통해 요청에 대한 관심사를 분리해 요청 처리에 대한 비즈니스 로직에 집중할 수 있다. (Filter, Interceptor, AOP)

#
### Dependency Injection(의존성 주입)
- 객체 의존성을 DI 컨테이너에 맡긴다.
- Setter 메소드 or 생성자 인수를 통해 의존성을 주입한다.
- DI 컨테이너는 요청이 드러올 때 필요한 객체의 인스턴스를 만든 후 의존성을 설정한다.

#
### Cross Cutting Concerns(횡단 관심 분리)
- 어플리케이션 전반에서 가지는 공통적인 관심사를 분리한다.
- 비즈니스 로직 외에 로깅, 트랜잭션 관리, 시큐리티 등 신경써야 할 관심사들이 많다.
- 관심사들은 많은 어플리케이션 레이어에 퍼져있는데, 이 관심사들을 분리해 처리하는 것이 효율적이다.
- 비즈니스 로직에 집중할 수 있도록 관심사를 분리하는 것이 중요하다.

# 11. 창발성 p.215~224
### 창발적 설계란
- 하위 계층에 없는 특성이나 행동이 상위 계층(전체 구조)에서 자발적으로 돌연히 출연하는 현상
- 작은 요소들의 상호작용의 반복이 전체 구조에 영향을 미친다.
- 단순한 4가지를 반복하다 보면 전체적으로 깨끗한 코드가 만들어진다.
  - 1. 모든 테스트를 실행한다.
  - 2. 중복을 없앤다.
  - 3. 프로그래머 의도를 표현한다.
  - 4. ~~클래스와 메서드 수를 최소로 줄인다.~~ 실용적 관점에서 타협한다.

#
### 모든 테스트를 실행한다
- 테스트를 작성할수록 설꼐 품질이 좋아진다.
- 모든 테스트 케이스를 항상 통과하는 시스템은 '테스트가 가능한 시스템'이다. 테스트가 불가능한 시스템은 검증도 불가하고, 절대 출시하면 안 된다.
- 테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 높아진다. 크기가 작고 목적 하나만 수행하는 클래스가 나온다.
- 결합도가 높으면 테스트 케이스를 작성하기 어렵기 때문에 결합도를 낮추는 설계를 하게 된다.
- '모든 테스트를 실행한다.' 규칙을 따르면 시스템은 낮은 결합도와 높은 응집력이라는 목표를 저절로 달성할 수 있다.

#
### 중복을 없앤다
- 기존의 코드를 최대한 재활용한다.
- 중복된 코드를 별도의 메서드로 분리한다.
- 분리 후 목적이 달라지는 메서드가 있다면, 별도의 클래스로 분리하면 추후 재활용성이 높아진다.
#### Template Method 패턴
- 알고리즘의 구조를 상위 클래스의 메서드에 정의하고, 하위 클래스에서 자신에 맞게 세부 알고리즘을 정의한다.
- 구현하려는 알고리즘에 일정한 단계가 있고, 세부 단계마다 조금씩 구현 내용이 다를 때 사용한다.
- 알고리즘의 여러 단계를 각 메서드로 선언하고, 그 알고리즘을 수행할 템플릿 메서드를 만든다.
- 하위 클래스에서는 나눠진 메서드(단계)를 구현한다.

#
### 의도를 표현한다
- 좋은 이름을 선택한다.
- 함수와 클래스 크기를 가능한 줄인다. 작은 클래스와 작은 함수는 이름 짓기도 쉬우기 때문이다.
- 표준 명칭을 사용한다. 다른 개발자가 보고 바로 이해할 수있도록 디자인 패턴을 사용했다면 그 이름을 클래스에 넣어준다.
- 단위 테스트 케이스를 꼼꼼하게 작성한다.
- 다른 사람을 위해 조금이라도 더! 읽게 쉽게 만드려고 노력한다.

#
### 실용적 관점에서 타협한다
- 과도한 설계을 지양한다.
- 여러가지 규칙에 극단적으로 심취해 클래스와 메서드를 무수하게 만들지 말라.
- 결국 좋은 코드를 만드는 이유는 생산성을 올리기 위한 것이다.
- 실용적인 관점에서 타협해야 한다.
- "개집 짓는데 사람 집 지으면 안된다."
- 하나만 있을 클래스에 인터페이스를 만들 필요가 없다. 거의 발생하지 않을 일에 미리 투자하는 비용이 더 크다. 필요하면 그 때 확장하는 설계를 하면 된다.

#### DIP(의존성 역전 원칙)
- 상위 모델은 하위 모델에 의존하면 안된다. 둘 다 추상화에 의존해야 한다.
- 추상화는 세부 사항에 의존해서는 안된다. 세부 사항은 추상화에 따라 달라진다.
- 하위 모델의 변경이 상위 모듈의 변경을 요구하는 위계관계를 끊는다.
- 실제 사용관계는 그대로이지만, 추상화를 매개로 메시지를 주고 받으면서 관계를 느슨하게 만든다.

# 12. 동시성 p.225~244, 407~446
### 동시성 프로그래밍이란
- 어플리케이션을 효율적으로 실행하기 위해 멀티코어를 온전히 활용하도록 구현하는 방식
- 낭비되는 자원을 줄이자!
- 서버가 클라이언트의 요청이 완료되도록 그저 기다리기 때문에 다른 작업이 실행되지 못한다.
- 병렬성을 구현하더라도 동시에 다른 작업을 할 수 없다.
- 동시성을 구현한다고 해서 클라이언트 입장에서 자신의 요청이 빨리 처리되는게 아니다. 어플리케이션 입장에서는 효율적으로 코어를 사용해 처리량을 높일 수 있다.
- 언어 레벨에서는 하드웨어의 멀티코어를 적절하게 사용하도록 지원하기 때문에 동시성만 신경써서 개발하면 된다.
- 동시성과 병렬성이 잘 구현되면 서버를 효율적으로 사용하여 처리량을 최대화할 수 있다.
- 클라이언트가 아닌 어플리케이션 관점에서 봐야 한다. 어플리케이션의 효율성을 높여야 한다.

#
### 동시성 프로그래밍이 필요한 이유
- 동시성은 항상이 아닌 때로 성능을 높여준다.
- 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.
- 동시성을 구현하면 설계를 바꿔야 한다. 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다른다.
- '무엇'과 '언제'를 분리하면 시스템의 구조가 크게 달라진다.
- 컨테이너를 사용해도 동시성을 이해해야 한다. 어플리케이션이 컨테이너를 통해 멀티 쓰레드를 사용하는 것이기 때문에 컨테이너의 동작을 이해해야 한다. 동시 수정, 데드락 같은 문제를 피할 수 있는지를 알아야 한다.

#
### 안전한 동시성 프로그래밍 규칙
#### 단일 책임 원칙(SRP) 설계 
- 동시성 관련 코드는 다른 코드와 분리하라
#### 자료 범위를 제한하라
- 공유 자료를 최대한 줄여라. 
- 동시 수정 문제를 피하기 위해 객체를 사용하는 코드 내 임계영역을 `synchronized` 키워드로 보호하라.
- 보호할 임계영역을 빼먹거나, 모든 임계영역을 보호했는지 확인하느라 수고가 드므로 임계 영역의 수를 최소화해야 한다.
#### 자료 사본을 사용하라
- 공유 자료를 줄이려면, 최대한 공유하지 않는 방법이 제일 좋다.
- 객체를 복사해 읽기 전용으로 사용한다.
- 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져온다.
- 사본을 사용하는 방식으로 내부 잠금을 없애 수행 시간을 절약하는 것이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다.
#### Thread는 가능한 독립적으로 구현하라
- 다른 스레드와 자료를 공유하지 않는다.
- 서블릿처럼 각 쓰레드는 클라이언트 요청 하나를 처리한다.
- 모든 정보는 비공유 출처(client의 request)에서 가져오며 로컬 변수에 저장한다.
- 각 서블릿은 마치 자신이 독자적인 시스템에서 동작하는 양 요청을 처리한다.
#### 라이브러리를 이해하라
- `java.util.concurrent`패키지를 익혀라
- Thread safe한 컬렉션을 사용한다. `ConcurrentHashMap`, `AtomincLong`
- 서로 무관한 작업을 수행할 때는 `executor` 프레임워크를 사용한다.
- 가능하다면 쓰레드가 Blocking 되지 않는 방법을 사용한다.

#### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
- 공유 객체 하나에는 메서드 하나만 사용하라
- 클라이언트에서 잠금 - 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다. 마지막 메서드를 호출할 때까지 잠금을 유지한다. 자원을 사용하는 클라이언트마다 처리 해줘야 하므로 비효율적
- 서버에서 잠금 - 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는" 메서드를 구현한다. 클라이언트는 이 메서드를 호출하기만 하면 된다.
- 연결(Adapter) 서버 - 잠금을 수행하는 중간 단계를 생성한다. '서버에서 잠금' 방식과 유사하지만 원래 서버는 변경하지 않는다. 서버의 코드가 외부 코드라서 수정할 수 없을 때 우리 코드에서 Adapter를 만들어 사용한다.

#
### 동시성 테스트 방법
#### 동시성 코드를 테스트해야 한다.
- 테스트를 했다고 동시성 코드가 100% 올바르다고 증명하기는 불가능하다.
- 하지만 충분한 테스트는 위험을 낮춘다.
- 문제를 노출하는 테스트 케이스를 작성하라.
- 프로그램의 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라.
- 테스트가 실패하면 원인을 추적하라.
- 다시 돌렸더니 통과한다는 이유로 그냥 넘어가면 절대로 안 된다.
#### 코드에 보조 코드를 넣어 돌려라
- 코드에 wait(), sleep(), yield(), priority() 함수를 추가해 직접 구현한다.
- 보조 코드를 넣어주는 도구를 사용해 테스트한다. (무작위로 wait(), sleep() 등을 호출)
- 테스트 환경에서 보조 코드를 돌려본다.
#### 동시성 코드를 실제 환경이나 테스트 환경에서 돌려본다
- 다양한 요청과 상황에 동시성 코드가 정상적으로 동작하는지 확인한다.
- 배포하기 전에 테스트 환경에서 충분히 오랜시간 검증한다.
- 동시성 코드를 배포한 후에 모니터링을 통해 문제가 발생하는지 지켜본다.

#
### 오픈소스 속 동시성 처리
- `AtomicLong` : Long 자료형을 thread safe하게 래핑한 값
- `ReentrantReadWriteLock` : 동시에 읽는 스레드는 허용하지만 읽기&쓰기, 쓰기&쓰기의 경우에는 차단한다. 읽는 작업이 자주 일어나고 쓰는 작업이 적을 때 사용하면 좋다.

# 13.점진적인 개선 p.245~322
### 책의 예제
- '점진적으로' 코드를 개선해나가는 사고 흐름을 따라가면 좋다.
- 자신이 스스로 점진적으로 코드를 개선해보는 경험을 통해 더 많이 배우게 된다.
#### 코드 초안
- 변경 전후 시스템이 동일하게 돌아간다는 사실을 확인하기 위해 테스들을 작성해뒀다.
- 자잘하게 점진적으로 개선
#### 코드 완성본
- 고드만 분리해도 설계가 좋아진다. 
- 관심사를 분리하면 코드를 이해하고 보수하기 훨씬 더 쉬워진다.

#
### 점진적으로 개선하기
- 프로그램을 망치는 가장 좋은 방법 중 하나는 개선이라는 이름 아래 구조를 크게 뒤집는 행위다.
- 코드가 나빠지고 있음을 느꼈을 때 기능을 추가하지 않고 개선을 시작한다.
- 테스트 코드를 작성한다.
- 변경을 가한 후에도 시스템이 변경 전과 똑같이 돌아가야 한다.
- 테스트 코드가 없다면 작성하고, 코드를 수정하기 전 상태에서 모든 테스트가 통과해야 한다.
- 점진적으로 개선한다.
- 책임에 따라 클래스를 나누고, 코드를 옮긴다.
- 테스트가 깨지지 않도록 확인하며 자잘한 변경을 조금씩 진행한다.

#
### IDE를 활용해 점진적으로 개선하기
- 메서드 추출 기능 : 코드 블럭을 메서드로 추출할 수 있다. `Ctrl + Alt + M`
- 메소드 파라미터 추가, 삭제 및 변경 : 메서드의 파라미터를 추가하거나 변경할 수 있다. `Ctrl + F6`
- 이름 변경 : 메서드나 변수 이름을 변경할 수 있다. `Shift + F6`
- 변수 추출 기능 : 변수를 추출할 수 있다. `Ctrl + Alt + V`
- 멤버 변수 추출 기능 : 특정 값을 멤버 변수로 설정할 수 있다. `Ctrl + Alt + F`
- 상수 추출 기능 : 특정 값을 상수로 추출할 수 있다. `Ctrl + Alt + C`
- 하위 클래스의 메서드를 상위로 올리거나, 상위 클래스의 메서드를 하위로 내릴 수 있다. (Pull Members Up & Pull Members Down)

# 14. JUnit 들여다보기 / SerialDate 리팩터링 p.323~366
### 책 내용 요약
- 세상은 완벽한 코드는 없다.
- 의도를 명확하게 표현하기 위해 조건문을 메서드로 분리
- 더 적절한 의미로 네이밍 변경
- 불필요한 연산을 하는 코드 제거
- 남의 코드를 비판하고, 내 코드의 비판을 듣는 건 편안하게 여겨야 할 활동이다.
- 테스트 코드가 모든 경우를 테스트하지 않는다. -> 주석 처리된 테스트 코드들을 모두 동작하도록 손본다.
- 코드의 구조를 개선하기 전에 버그들을 수정한다. 경계 조건 오류, 늘 거짓인 조건문 등


#
### 오픈 소스 접근법
- 제대로 솔루션을 사용하거나 운영하기 위해서는 소스 코드를 봐야 하는 경우가 많다.
- 해당 솔루션에 대한 기본 지식을 먼저 익혀라.
  - 복잡한 분산 컴퓨팅 환경에서 운영되는 솔루션인 경우 더욱 더 그 시스템의 기본 개념과 아키텍처를 이해하고 있어야 한다.
- 본인 PC에 빌드 및 실행 환경을 구축하라. 필수사항. 로그를 추가하여 확인하는 것이 좋다.
- 수정, 실행, 확인 사이클을 짧게 만들어라. 몇번 반복하다 보면 같은 작업 패턴을 찾게 되는데 이때에는 스크립트를 만들어서 반복 작업을 효율적으로 하는 것이 좋다.
- 자신에게 질문을 많이 하라. 특정 기능에 대해서 "나라면 어떻게 개발했을까?" 라고 자신에게 질문을 던지고 머리 속에 어떻게 구현할 것인지를 먼저 그려 보기.
- 분석하면서 문서로 정리하라. 분석을 하면서 그림 또는 문서로 정리를 하면 분석하는 그 시점에도 도움이 되지만 나중에도 도움이 된다.
- 디버거 활용하기
  - Log Level을 DEBUG로 설정하기.
  - 디버거의 breakpoint 기능을 활용하라.
  - System.out.println 보다는 Thread.dumpStack()을 활용하라.
- 코드의 일부를 통해 먼저 파악하기
  - 당장 관심있는 부분부터 집중적으로 파악하기
  - 테스트 코드는 좋은 교본이 된다.
  - 그래도 어려우면 초기 버전을 다운로드 받아 분석하라

#
### Spring 프로젝트 접근법
- repository 이름과 README.md를 보고 프로젝트의 성격을 파악
- 패키지 구조를 살펴본다. 멀티 모듈 프로젝트?
- 빌드 설정 파일(build.gradle)을 보고, 어떤 디펜던시(모듈)을 쓰나 살펴본다.
- config 패키지 하위에 어떤 설정들이 되어 있는지 본다.
- controller 패키지 하위 코드를 보고 어떤 요청들을 처리하는지 감을 잡는다.
- service 패키지 하위를 보고 비즈니스 로직을 추측한다.
- 데이터 구조를 알기 위해 resource 하위의 db 설정 파일을 보고 db에 접근해본다. schema.sql 파일이 있으면 DDL을 읽어본다.
- 세부적인 비즈니스 로직을 확인할 때는 test 코드와 비교하며 이해한다.

# 15. 냄새와 휴리스틱 p.367~406
###
