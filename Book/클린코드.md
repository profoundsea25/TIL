> [한달한권 클린코드](https://zero-base.co.kr/category_dev_camp/cleancode_1book)를 보며 공부한 것을 정리한 내용입니다.

# 1. 클린 코드와 그 첫걸음 네이밍 p.1~38
### 나쁜 코드
- 성능이 나쁜 코드
  - 불필요한 연산이 들어가서 개선의 여지가 있는 코드
- 의미가 모호한 코드
  - 이해하기 어려운 코드
  - 네이밍과 그 내용이 다른 코드
- 중복된 코드
  - 비슷한 내용인데 중복되는 코드들은 버그를 낳는다.
### 나쁜 코드가 나쁜 이유
- 깨진 유리창 법칙
  - 나쁜 코드는 깨진 유리창처럼 계속 나쁜 코드가 만들어지도록 한다. 쇠퇴의 시작.
- 생산성 저하
  - 나쁜 코드는 팀 생산성을 저하시킨다. 
  - 기술부채를 반들어 수정을 더 어렵게 한다.
- 새로운 시스템을 만들어야 한다
  - 현 시스템을 유지보수하여 대체할 새로운 시스템 개발은 현실적으로 매우 어렵다.
### 나쁜 코드를 짜는 이유
- 일정이 촉박해서
  - 일정 안에 새로운 기능을 완성해야 한다.
  - 하지만, 나쁜 코드는 생산성을 저하하기 때문에 오히려 일정을 못 맞춘다.
- 영향 범위가 넓어서
  - 생각보다 영향 범위가 넓어서 건드렸다가 다른 부분에 버그가 발생할까봐
  - 하지만 기술부채는 부메랑처럼 다시 돌아온다.
##
### 클린 코드
- "깨끗한 코드는 한 가지를 제대로 한다."
- "깨끗한 코드는 잘 쓴 문장처럼 읽힌다."
- 성능이 좋은 코드
- 의미가 명확한 코드 = 가독성이 좋은 코드
- 중복이 제거된 코드
### 보이스카우트 룰
- 캠프장은 처음 왔을 때보다 전보다 더 깨끗하게 해야 한다.
- 전보다 더 깨끗한 코드로 만든다.
##
### 의미 있는 이름 짓기
- 의미가 분명한 이름 짓기
- 루프 속 i j k 사용하지 않기
  - advanced for문으로 i를 사용하지 않을 수 있다.
  - lamda를 사용할 수도 있다.
  - 최대한 의미를 찾을 수 있다. i j k 대신 맥락에 맞는 이름이 있다.
- 통일성 있는 단어 사용하기
  - 팀에서 협의해서 단어를 정해서 사용해야 한다.
- 변수명에 타입 넣지 않기
  - Map, List는 예외인 듯.. 특히 Map은 표현을 대체할 단어가 많지 않아서 Map을 그대로 써서 표현함.
  - Impl도 현업에서 많이 쓰기는 하는데, 구현체 이름을 명확하게 지어주는 것이 더 좋다.
  - 팀 간의 약속을 지키는 것이 좋다.
##
### Google Java Naming Guide
- Package Naming Guide
  - All lower case, no underscores
- Class Nmaing Guide
  - UpperCamelCase (대문자로 시작하는 카멜케이스)
  - 클래스는 명사, 명사구
  - 인터페이스는 명사, 명사구, (형용사)
  - 테스트 클래스는 Test로 끝나기
- Method Naming Guide
  - LowerCamelCase (소문자로 시작하는 카멜케이스)
  - 메서드는 동사, 동사구
  - jUnit 테스트에 underscore이 사용되기도 함

# 2. 함수를 안전하고 간결하게 작성하기
### SOLID
- SRP 단일 책임 원칙
- OCP 개방-폐쇄 원칙
- LSP 리스코프 치환 원칙
- ISP 인터페이스 분리 원칙
- DIP 의존성 역전 원칙
#### SRP 단일 책임 원칙
- 한 클래스는 하나의 책임만 가져야 한다.
- 클래스는 하나의 하나의 기능만 가지며, 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
- SRP 책임이 분명해지기 때문에, 변경에 의한 연쇄작용에서 자유로워질 수 있다.
- 가독성 향상과 유지보수가 용이해진다.
- 실전에서는 쉽지 않지만 늘 상기해야 한다!
#### OCP 개방-폐쇄 원칙
- 소프트웨어 요소는 확장에는 열러 있으나 변경에는 닫혀 있어야 한다.
- 변경을 위한 비용은 가능한 줄이고, 확장을 위한 비용은 가능한 극대화 해야 한다.
- 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소에는 수정이 일어나지 않고, 기존 구성 요소를 쉽게 확장해서 재사용한다.
- 객체 지향의 추상화와 다형성을 활용한다.
#### LSP 리스코프 치환 원칙
- 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.
- 서브 타입은 기반 타입이 약속한 규약(접근제한자, 예외 포함)을 지켜야 한다.
- 클래스 상속, 인터페이스 상속을 이용해 확장성을 획득한다.
- 다형성과 확장성을 극대화하기 위해 인터페이스를 사용하는 것이 더 좋다.
- 합성(composition)을 이용할 수도 있다.
#### ISP 인터페이스 분리 원칙
- 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
- 가능한 최소한의 인터페이스만 구현한다.
- 만약 어떤 클래스를 이용하는 클라이언트가 여러 개고, 이들이 클래스의 특정 부분만 이용한다면, 여러 인터페이스로 분류하여 클라이언트가 필요한 기능만 전달한다.
- SRP가 클래스의 단일 책임이라면, ISP는 인터페이스의 단일 책임
#### DIP 의존성 역전 원칙
- 상위 모델은 하위 모델에 의존하면 안된다. 둘 다 추상화에 의존해야 한다.
- 추상화는 세부 사항에 의존해서는 안된다. 세부 사항은 추상화에 따라 달라진다.
- 하위 모델의 변경이 상위 모듈의 변경을 요구하는 위계관계를 끊는다.
- 실제 사용관계는 그대로이지만, 추상화를 매개로 메시지를 주고 받으면서 관계를 느슨하게 만든다. 

#
### 간결한 함수 작성하기
- 작게 쪼갠다.
- 함수 내 추상화 수준을 동일하게 맞춘다.
- 한 가지만 하기(SRP), 변경에 닫게 만들기(OCP)
  - 타입에 대한 처리(혹은 분기를 나누는 행위)는 최대한 Factory에서만 (Factory 객체는 Mapping하는 객체라고 생각하자)
- 함수 인수의 갯수는 0~2개가 적당하다.
- 3개 이상인 경우는 객체를 인자로 넘기기. (추천)
  - 가변 인자(예: `String.format(String format, Object... args)`)를 넘기는 방법이 있기는 한데, 특별한 경우가 아니면 잘 사용하지 않음. 

#
### 안전한 함수 작성하기
- 안전한 함수 = 부수 효과(Side Effect) 없는 함수
- 부수 효과란, 값을 반환하는 함수가 그와 관계 없는 외부 상태를 변경하는 경우
  - 예 : 패스워드를 체크하는 함수에서 Session을 초기화

#
### 함수 리팩터링
- 기능을 구현하는 서투른 함수를 작성한다.
  - 길고, 복잡하고, 중복도 있다.
- 테스트 코드를 작성한다.
  - 함수 내부의 분기와 엣지값마다 빠짐없이 테스트하는 코드를 짠다.
- 리팩터링 한다.
  - 코드를 다듬고, 함수를 쪼개고, 이름을 바꾸고, 중복을 제거한다.
