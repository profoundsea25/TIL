# CHAPTER 3 입출금 내역 분석기 확장판
- 배울 내용
  - 개방/폐쇄 원칙 (OCP, open/closed principle)
    - 코드 베이스에 유연성을 추가하고 유지보수성을 개선하는 데 도움을 준다.
  - 인터페이스에 대한 일반적인 가이드라인
  - 높은 결합도를 피하는 기법
  - 자바의 예외 처리 방법
    - 언제 API에 예외를 포함하거나 포함하지 않을지를 결정
  - 자바 프로젝트를 시스템적systematically으로 빌드하는 방법
    - Maven, Gradle 같은 검증된 빌드 도구를 사용

### 개방/폐쇄 원칙
- '이 메서드를 어디에 정의해야 할까?'에 대한 고민
  - 이미 새로 클래스를 이미 추가한 상황에서,
  - 여러 이름이 생기면서 다양한 동작 간의 관계를 이해하기가 어려워지고,
  - 전체 프로젝트가 복잡해진다면,
  - -> 메서드를 추가하려고 클래스를 새로 만들어도 크게 좋은 것이 없다.
  - 조금만 더 넓게 생각해서, 현재 있는 클래스 중에 가장 유사한 기능을 처리하는 클래스 안에 정의하면, 나중에 관련 메서드를 더 쉽게 찾을 수 있다.
- 중복 코드는 소프트웨어를 불안정하게 만든다.
  - 특히 요구 사항이 자주 바뀔수록 영향이 커진다.
  - 반복하면서 수행하는 로직을 바꾸려면 여러 장소에서 이를 모두 찾아 바꿔야 한다.
- OCP의 장점
  - 기존 코드를 바꾸지 않으므로 기존 코드가 잘못될 가능성이 줄어든다.
  - 코드가 중복되지 않으므로 기존 코드의 재사용성이 높아진다.
  - 결합도가 낮아지므로 유지보수성이 좋아진다.

#### 개방/폐쇄 원칙은 이런 상황에 적용한다.
- 예제(입출금 내역 분석기)의 문제 상황
  - 요구 사항이 복잡해질수록, 객체(엔티티)의 여러 속성을 조합할수록 코드가 점점 복잡해진다.
  - 반복 로직과 비즈니스 로직이 결합되어 분리하기가 어려워진다.
  - 코드를 반복한다.
- OCP를 통해서,
  - 코드를 직접 바꾸지 않고 해당 메서드나 클래스의 동작을 바꿀 수 있다.
  - 반복 로직과 비즈니스 로직이 결합되어 있을 때에는 인터페이스를 이용해 이런 결합을 제거할 수 있다.
- 예시 - `Predicate<T>`와 같은 함수형 인터페이스
  - 기존 메서드의 바디를 바꿀 필요 없이 새로운 구현을 인수로 전달
    - 새로운 구현을 인수로 전달할 때는 그때마다 구현 클래스를 만들지 않고, 람다 표현식을 사용한다.
    - 즉, 이름 없이 인터페이스 구현 객체를 코드 블록 형태로 전달한다.
  - 따라서 변경 없이도closed 확장성은 개방open된다.
  - 이러한 방식으로 기능을 확장하면 기존에 이미 구현하고 검증한 코드를 바꾸는 일을 최소화할 수 있으므로 새로운 버그가 발생할 만한 대상을 줄일 수 있다.
  - 예전 코드를 바꾸지 않고도 새로운 기능을 추가할 수 있기 때문이다.

### 인터페이스 문제
- 자바의 인터페이스는 모든 구현이 지켜야 할 규칙을 정의한다.
  - 즉, 구현 클래스는 인터페이스에서 정의한 모든 연산의 구현 코드를 제공해야 한다.
  - 따라서 인터페이스를 바꾸면 이를 구현한 코드도 바뀐 내용을 지원하도록 갱신되어야 한다.
  - 더 많은 연산을 추가할수록 더 자주 코드가 바뀌며, 문제가 발생할 수 있는 범위도 넓어진다.
- 갓 인터페이스
  - 한 인터페이스에 모든 기능을 추가한 갓 인터페이스
  - 인터페이스가 도메인 객체의 특정 접근자에 종속되는 문제가 생기면, 도메인 객체의 세부 내용이 바뀌면 인터페이스도 바뀌어야 하며 결과적으로 구현 코드도 바뀌어야 한다.
  - 따라서 보통 작은 인터페이스를 권장한다. 
  - 그래야 도메인 객체의 다양한 내부 연산으로 디펜던시를 최소화할 수 있다.
- 지나친 세밀함
  - 인터페이스가 무조건 작다고 또 좋지는 않다.
  - 지나치게 인터페이스가 세밀해도 코드 유지보수에 방해가 된다.
  - 안티 응집도 문제가 발생한다.
    - 즉 기능이 여러 인터페이스로 분산되므로 필요한 기능을 찾기가 어렵다.
    - 자주 사용하는 기능을 쉽게 찾을 수 있어야 유지보수성도 좋아진다.
  - 인터페이스가 너무 세밀하면 복잡도가 높아지며, 새로운 인터페이스가 계속해서 프로젝트에 추가된다.

### 명시적 API vs 암묵적 API - 인터페이스 문제 해결하기
- 개방/폐쇄 원칙을 적용하면 연산에 유연성을 추가하고 가장 공통적인 상황을 클래스로 정의할 수 있다.
#### 인터페이스를 만들지 않아도 될 때
- 어떤 클래스의 다양한 구현을 기대하지 않으면 인터페이스의 필요성이 사라진다.
- 전체 응용프로그램에 도움이 되는 메서드를 제공하지 않을 때
- 코드베이스에 불필요한 추상화를 추가해 일을 복잡하게 만들 필요가 없을 때.
#### 명시적 API vs 암묵적 API 딜레마
- 예를 들면, `findTransactions()`와 같은 일반적인 메서드 vs `findTransactionsGreaterThanEqual()`같은 구체적인 메서드
- 구체적인 메서드
  - 자체적으로 어떤 동작을 수행하는지 잘 설명되어 있고, 사용하기 쉽다.
  - API의 가독성을 높이고 쉽게 이해하도록 메서드 이름이 서술적이다.
  - 하지만 이 메서드의 용도가 특정 상황에 국한되어 각 상황에 맞는 새로운 메서드를 많이 만들어야 하는 상황이 벌어진다.
- 일반적인 메서드
  - 처음 사용하기가 어렵고, 문서화를 잘해놓아야 한다.
  - 필요한 거의 모든 상황을 단순한 API로 처리할 수 있다.
- 어떤 것이 더 좋은지는 정해져있지 않다. 필요한 질문의 종류에 따라 달라진다.
- 구체적인 메서드라도 가장 흔히 사용하는 연산이라면, 사용자가 쉽게 이해하고 사용하도록 이를 명시적 API로 만드는 것이 합리적인 방법이다.

### 도메인 클래스 vs 원싯값
- `double` 같은 원싯값(primitive type)을 반환하는 것은 일반적으로 좋은 방법이 아니다. 다양한 결과를 반환할 수 없어 유연성이 떨어지기 때문이다.
  - 다양한 결과를 포함하도록 메서드 시그니처를 바꾸려면 관련된 모든 구현을 바꿔야 한다.
- 다양한 결과를 받을 수 있도록 하나의 원시 타입이 아닌, 새로운 도메인 클래스를 만들면 해결할 수 있다. (VO, DTO 같은 느낌)
  - 새 클래스에 필요한 필드와 결과를 언제든 추가할 수 있다.
  - 또한 도메인의 다양한 개념 간의 결합을 줄이고, 요구 사항이 바뀔 때 연쇄적으로 코드가 바뀌는 일도 최소화할 수 있다.

### 도메인 객체
- 결과값을 어떠한 형식으로 내보내고 싶은지 명확히 하자. 각 형태에 따른 장단점은 다음과 같다.
- 숫자
  - 가장 간단한 구현
  - 요구사항이 바뀔 때 유연하게 대처할 수 없다.
  - 수정이 될 때, 관련 코드를 모두 바꿔야 하므로 버그의 발생 가능성이 크다.
- 컬렉션
  - `Iterable`를 반환하면 상황에 맞춰서 처리하기 떄문에 유연성을 높일 수 있다.
  - 이때 유연성은 좋아지지만 오직 컬렉션만 반환해야 한다는 제약이 따른다.
- 특별한 도메인 객체
  - 사용자가 내보내려는 요약 정보를 대표하는 새로운 개념을 만들 수 있다.
  - 도메인 객체는 자신의 도메인과 관련된 클래스의 인스턴스이다.
  - 도메인 객체를 이용하면 결합을 깰 수 있다.
  - 새로운 요구 사항이 생겨서 추가 정보를 내보내야 한다면 기존 코드를 바꿀 필요 없이 새로운 클래스의 일부로 이를 구현할 수 있다.
- 더 복잡한 도메인 객체
  - 더 일반적이며 다양한 결과를 저장하는 필드를 포함하는 개념을 만들 수 있다.
  - 사용자의 요구 사항이 무엇이며 더 복잡한 정보를 내보내야 하는지 여부에 따라 사용할 도메인 객체가 달라진다.
  - 어떤 상황이든 이 객체를 생산하는 부분과 이를 소비하는 부분이 서로 결합하지 않는다는 큰 장점이 있다.

#### 적절하게 인터페이스를 정의하고 구현하기
- 내보낼 형식이 정해졌으면 이를 구현하는 API가 필요하다. 인터페이스를 정의해 다양한 내보내기 구현 코드가 다른 코드와 결합하지 않도록 방지한다.
- 내보내는 인터페이스를 정의할 때 주의할 점
  - void 반환 형식은 아무 도움이 되지 않고, 기능을 파악하기도 어렵다. 메서드가 무엇을 반환하는지 알 수 없기 때문이다.
  - void를 반환하면 Assertion으로 결과를 테스트하기도 매우 어렵다. 예상한 값과 실제 결괏값을 어떻게 비교할 것인가?

### 예외 처리
#### 예외를 사용해야 하는 이유
- 고전적인 방법 : 수많은 if문 추가하고 암호 같은 오류 코드 반환하기
  - 전역으로 공유된 가변 상태에 의존해 최근에 발생한 오류를 검색해야 한다. 코드 부분이 따로 분리되어 이해하기가 어려워진다. 즉, 유지보수가 어렵다.
  - 어떤 값이 실제 값인지 아니면 오류를 가리키는 값인지 구분하기 어렵다. (강력한 형식 시스템이 있으면 그나마 낫다.)
  - 제어 흐름이 비즈니스 로직과 섞이면서 코드를 유지보수하거나 프로그램의 일부를 따로 테스트하기도 어려워진다.
- 위의 문제를 해결하기 위해, Java는 예외를 일급 언어 기능으로 추가하여 다음과 같은 장점이 있다.
  - 문서화 : 메서드 시그니처 자체에 예외를 지원한다.
  - 형식 안전성 : 개발자가 예외 흐름을 처리하고 있는지를 형식 시스템이 파악한다.
  - 관심사 분리 : 비즈니스 로직과 예외 회복이 각각 try/catch 블록으로 구분된다.
- 다만, 예외 기능으로 복잡성이 증가한다는 단점이 생긴다.
- 자바의 예외 종류
  - 확인된 예외
    - 회복해야 하는 대상의 예외다.
    - 자바에서는 메서드가 던질 수 있는 확인된 예외 목록을 선언해야 한다.
    - 아니면 해당 예외를 try/catch로 처리해야 한다.
  - 미확인 예외
    - 프로그램을 실행하면서 언제든 발생할 수 있는 종류의 예외이다.
    - 확인된 예외와 달리 메서드 시그니처에 명시적으로 오류를 선언하지 않으면 호출자도 이를 꼭 처리할 필요가 없다.

#### 예외의 패턴과 안티 패턴
- 미확인 예외와 확인된 예외에서 선택하기
  - 구현하는 API에서 예외가 발생했을 때 프로그램이 회복되도록 강제할 것인지를 스스로 생각해보면 답이 나온다.
  - 일시적으로 발생하는 오류라면 동작을 다시 시도하거나 화면에 메시지를 출력해 응용 프로그램의 반응성을 훌륭하게 유지할 수 있다.
  - 보통 비즈니스 로직 검증(잘못된 형식이나 연산 등) 시 발생한 문제는 불필요한 try/catch 구문을 줄일 수 있도록 미확인 예외로 결정한다.
  - 물론 예외가 발생했을 때 응용프로그램을 어떻게 회복시킬 것인지 애매한 상황도 있다. 이런 상황에서는 API 사용자에게 오류를 복구하라고 강제할 필요가 없다.
  - 시스템 오류(저장 공간이 꽉 참 등)가 발생했을 때 사용자가 확인 할 수 있는 일이 없으므로 시스템 오류도 미확인 예외로 지정한다.
  - 즉, 대다수의 예외를 미확인 예외로 지정하고 꼭 필요한 상황에서만 확인된 예외로 지정해 불필요한 코드를 줄여야 한다.
- 검증을 할 때는 전용 `Validator` 클래스를 만들기를 권장한다.
  - 검증 로직을 재사용해 코드를 중복하지 않음.
  - 시스템의 다른 부분도 같은 방법으로 검증할 수 있음.
  - 로직을 독립적으로 유닛 테스트할 수 있음.
  - 프로그램 유지보수와 이해하기 쉬운 SRP를 따름.
- 안티 패턴 : 과도하게 세밀함
  - 발생할 수 있는 모든 경계 상황을 고려하고, 각각의 경계 상황을 별도의 확인된 예외로 변환하는 것.
  - 이 방법은 각각의 예외에 적합하고 정확한 회복 기법을 구현할 수 있찌만 너무 많은 설정 작업이 필요하다.
  - 여러 예외를 선언해야 한다.
  - 사용자가 이 모든 예외를 처리해야 하므로 생산성이 현저하게 떨어진다. 즉, 사용자가 API를 쉽게 사용할 수 없게 된다.
  - 여러 오류가 발생했을 때 모든 오류 목록을 모아 사용자에게 제공할 수도 없다.
- 안티 패턴 : 과도하게 덤덤함
  - 모든 예외를 `IllegalArgumentException` 등의 미확인 예외로 지정하는 극단적인 상황
  - 전부 동일한 예외로 지정하면 구체적인 회복 로직을 만들 수 없는 문제가 생긴다.
  - 마찬가지로 여러 오류가 발생했을 때 모든 오류 목록을 모아 사용자에게 제공할 수도 없다. 

#### 노티피케이션 패턴
- 너무 많은 미확인 예외를 사용하는 상황에 적합한 해결책을 제공한다.
- 이 패턴에서는 도메인 클래스로 오류를 수집한다.
- 한 번에 여러 오류를 수직할 수 있는 검증자를 만든다. 예외를 던지지 않고 `Notification` 객체에 메시지를 추가한다.

#### 예외 사용 가이드라인
- 예외를 무시하지 않음
  - 문제의 근본을 알 수 없다고 예외를 무시하면 안 된다.
  - 예외를 처리할 수 있는 방법이 명확하지 않으면 미확인 예외를 대신 던진다.
  - 확인된 예외를 정말로 처리해야 할 때 런타임에서 어떤 문제가 발생하는지 먼저 확인한 다음, 이전 문제로 돌아와 필요한 작업을 다시 시작할 수 있다.
- 일반적인 예외는 잡지 않음
  - 가능한 구체적으로 예외를 잡으면 가독성이 높아지고 더 세밀하게 예외를 처리할 수 있다.
  - 일반적인 `Exception`은 `RuntimeException`을 포함한다.
- 예외 문서화
  - API 사용자에게 문제 해결의 실마리를 제공한다.
  - 미확인 예외 보고서는 해결해야 할 문제의 원인을 포함한다.
- 특정 구현에 종속된 예외를 주의할 것
  - 특정 구현에 종속된 예외를 던지면 API의 캡슐화가 깨지므로 주의하자.
- 예외를 제어 흐름으로 쓰지 않는다.
  - 가독성이 떨어진다. 코드 의도도 이해하기 어려워진다.
  - 예외를 정말 던져야 하는 상황이 아니라면 예외를 만들지 않아야 한다.
  - 예외가 발생했을 때 스택 트레이스 생성, 보존과 관련된 부담이 생긴다.
- 예외 대안 기능
  - null 사용
    - 쓰지 마라. null은 호출자에게 아무 정보도 제공하지 않는다.
    - API 결과가 항상 null인지 확인해야 하므로 오류가 쉽게 발생한다.
  - null 객체 패턴
    - 객체가 존재하지 않을 때 null 레퍼런스를 반환하는 대신, 필요한 인터페이스를 구현하는 객체를 반환하는 기법이다. (바디는 비어있음)
    - NullPointerException과 null 확인 코드로부터 피할 수 있따.
    - 빈 객체는 아무것도 수행하지 않으므로 동작을 예측하기 쉽다.
    - 데이터에 문제가 있어도 빈 객체를 이용해 실제 문제를 무시할 수 있어 나중에 문제를 해결하기가 더 어려워진다.
  - `Optional<T>`
    - 값이 없음을 표현하는 내장 데이터, 이를 처리하는 다양한 메서드를 제공함.

### 빌드 도구 사용
- 왜 사용할까?
  - 컴파일, 디펜던시 관리, 프로젝트 패키징, 테스트, 배포 등을 스크립트로 만들고 자동화하여, 개발에 집중할 수 있도록 도와준다.
  - 프로젝트에 적용되는 공통적인 구조를 제공, 동료 개발자가 여러분의 프로젝트를 좀 더 편안하게 받아들인다.
  - 응용프로그램을 빌드하고 실행하는 반복적이고, 표준적인 작업을 설정한다.
  - 저수준 설정과 초기화에 들이는 시간을 줄여 개발에 집중할 수 있게 한다.
  - 잘못된 설정이나 일부 빌드 과정 생략 등으로 발생하는 오류의 범위를 줄여 준다.
  - 공통 빌드 작업을 재사용해 이를 다시 구현할 필요가 없으므로 시간을 절약한다.
- maven 대신 gradle의 강점
  - XML보다 가독성이 좋다.
  - 그루비, 코틀린 같은 DSL을 적용한다. 더 자연스럽게 빌드를 지정하고, 쉽게 커스터마이징할 수 있으며 쉽게 이해할 수도 있다.
  - 캐시, 점진적 컴파일 등 빌드 시간을 단축하는 기능이 있다.
