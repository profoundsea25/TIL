# 10장. 예외
### 아이템 69. 예외는 진짜 예외 상황에서만 사용하라
- 무슨 일을 하는지 전혀 직관적이지 않다는 것 하나만으로도, 코드를 그렇게 작성하면 안 되는 이유는 충분하다.
- 예외는 (그 이름이 말해주듯) 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안 된다.
  - 표준적이고 쉽게 이해되는 관용구를 사용하고, 성능 개선을 목적으로 과하게 머리를 쓴 기법은 자제하라.
  - 실제로 성능이 좋아지더라도 자바 플랫폼이 꾸준히 개선되고 있으니 최적화로 얻은 상대적인 성능 우위가 오래가지 않을 수 있다.
- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.
- 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침 몇 가지
  - 1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 떄문이다.
  - 2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.
  - 3. 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다. 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기가 쉽다. 상태 검사 메서드 호출을 깜빡 잊었다면 상태 의존적 메서드가 예외를 던져 버그를 확실히 드러낼 것이다. 반면 특정 값은 검사하지 않고 지나쳐도 발견하기가 어렵다. (옵셔널은 제외)

#
### 아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라
- 검사 예외
  - 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.
    - 검사/비검사 예외를 구분하는 기본 규칙이다.
  - 검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다.
  - 메서드 선언에 포함된 검사 예외 각각은 그 메서드를 호출했을 때 발생할 수 있는 유력한 결과임을 API 사용자에게 알려주는 것이다.
  - 즉, API 설계자는 API 사용자에게 검사 예외를 던져주어 그 상황에서 회복해내라고 요구한 것이다.
  - 호출자가 예외 상황에서 벗어나는 데 필요한 정보를 알려주는 메서드를 함께 제공하는 것이 중요하다.
- 비검사 `Throwable` : 런타임 예외와 에러
  - 프로그램에서 잡을 필요가 없거나 혹은 통상적으로는 잡지 말아야 한다.
  - 비검사 예외나 에러를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많다는 뜻이다.
- 런타임 예외
  - 프로그래밍 오류를 나타낼 때는 런타입 예외를 사용하자.
  - 런타임 예외의 대부분 전제조건을 만족하지 못했을 때 발생한다. 이는 단순히 클라이언트가 해당 API의 명세에 기록된 제약을 지키지 못했다는 뜻이다.
  - 복구할 수 있는 상황인지 프로그래밍 오류인지가 항상 명확히 구분되지는 않는다. 확신하기 어렵다면 아마도 비검사 예외를 선택하는 편이 낫다.
- 에러
  - 보통 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용
  - `Error` 클래스를 상속해 하위 클래스를 만드는 일은 자제하자.
  - 다시 말해 여러분이 구현하는 비검사 `Throwable`은 모두 `RuntimeException`의 하위 클래스여야 한다.
  - `Error`는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야 한다. (`AssertionError`는 예외)
- 그 이외의 `Throwable`
  - 이로울 것이 없으니 절대로 사용하지 말자.
  - `Throwable`은 정상적인 검사 예외보다 나을 게 하나도 없으면서 API 사용자를 헷갈리게 할 뿐이다.

#
### 아이템 71. 필요없는 검사 예외 사용은 피하라
- 결과로 코드를 반환하거나 비검사 예외를 던지는 것과 달리, 검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게끔 해준다.
  - 물론, 검사 예외를 과하게 사용하면 오히려 쓰기 불편한 API가 된다.
  - 어쨌든 검사 예외를 던지면, 이를 호출하는 코드에서는 catch 블록을 두어 그 예외를 붙잡아 처리하거나 더 바깥으로 던져 문제를 전파해야만 한다. 이는 API 사용자에게 부담을 준다.
  - 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없기 때문에 자바 8부터 부담이 더욱 커졌다.
  - 특히 메서드가 단 하나의 검사 예외만 던질 때가 API 사용자에게 부담이 가장 크다. 호출하는 쪽에서 try 블록과 스트림에서 직접 사용하지 못 하기 때문이다.
- 검사 예외를 회피하는 방법
  - 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다. (가장 쉬운 방법)
    - 검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환하면 된다.
    - 이 방식의 단점은 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다는 것이다.
  - 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꾼다.
    - 첫 번째 메서든 예외가 던져질지 여부를 boolean 값으로 반환하여, if 문을 선언해 처리한다.
    - 그러나 첫 번째 메서드는 상태 검사 메서드의 일종으로 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인에 의해 상태가 변할 수 있다면 적절하지 않다.

#
### 아이템 72. 표준 예외를 사용하라
- 숙련된 프로그래머일수록 더 많은 코드를 재사용한다.
  - 예외도 마찬가지로 재사용하는 것이 좋다.
  - 자바 라이브러리는 대부분  API에서 쓰기에 좋은 충분한 수의 예외를 제공한다.
- 표준 예외를 재사용하면 얻는 것이 많다.
  - 가장 좋은 점은 여러분의 API가 다른 사람이 익히고 사용하기 쉬워진다는 것이다. 많은 프로그래머에게 이미 익숙해진 규약을 그대로 따르기 때문이다.
  - 예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸린다.
- 많이 사용되는 예외들
  - `IllegalArgumentException` - 호출자가 인수로 부적절한 값을 넘길 때,
  - `IllegalStateException` - 대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때, 인수 값이 무엇이었든 어차피 실패했을 때
    - 특수한 경우엔 구분하여 사용하기 : `NullPointerException`, `IndexOutOfBoundException`
  - `ConcurrentModificationException` - 단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때
  - `UnsupportedOperationException` - 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때
- `Exception`, `RuntimeException`, `Throwable`, `Error`는 직접 재사용하지 말자. 이 클래스들은 추상 클래스라고 생각하자.
- 상황에 부합한다면 항상 표준 예외를 사용하자.
  - 이때 API 문서를 참고해 그 예외가 어떤 상황에서 던져지는지 꼭 확인해야 한다.
  - 예외의 이름뿐 아니라 예외가 던져지는 맥락도 부합할 때만 재사용한다.
  - 더 많은 정보를 제공하길 원한다면 표준 예외를 확장해도 좋다. 단, 예외는 직렬화할 수 있다는 사실을 기억하자.
