# 5장. 제네릭
- Java 5~
- 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려주게 된다. 
- 그래서 컴파일러는 알아서 형변환 코드를 추가할 수 있게 되고, 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단하여 더 안전하고 명확한 프로그램을 만들어준다.

#
### 아이템 26. 로 타입(raw type)은 사용하지 말라
- 클래스와 인터페이스 선언에 타입 매개변수(type parameter)가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라 한다. 이를 통틀어 제네릭 타입(generic type)이라 한다.
- 각각의 제네릭 타입은 일련의 매개변수화 타입(parameterized type)을 정의한다.
  - 먼저 클래스(혹은 인터페이스) 이름이 나오고, 이어서 꺾쇠괄호 안에 실제 타입 매개변수들을 나열한다.
  - 예를 들어, `List<String>`은 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다.
- 제네릭 타입을 하나 정의하면 그에 딸린 로 타입(raw type)도 함께 정의한다.
  - 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. (ex. `List<E>`의 로 타입은 `List`)
  - 로 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책
- 제네릭을 활용하면 특정 인스턴스만 취급한다는 정보를 주석이 아닌 타입 선언 자체에 녹아들 수 있도록 할 수 있다.
  - 오류는 가능한 한 발생 즉시, 이상적으로는 컴파일할 때 발견하는 것이 좋다.
  - 오류가 발생하고 한참 뒤인 런타임에야 알아챌 수 있는 경우에는, 런타임에 문제를 겪는 코드와 원인을 제공한 코드가 물리적으로 상당히 떨어져 있을 가능성이 커진다.
  - 제네릭으로 선언하면 컴파일러는 특정 인스턴스만 넣어야 함을 인지하게 된다.
  - 따라서 아무런 경고 없이 컴파일된다면 의도대로 동작할 것임을 보장한다. (컴파일러 경고를 숨기지 않았어야 한다.)
  - 엉뚱한 타입의 인스턴스를 넣으려 하면 컴파일 오류가 발생하며, 무엇이 잘못됐는지 정확히 알려준다.
  - 컴파일러는 보이지 않는 형변환을 추가하여 절대 실패하지 않음을 보장한다.
- 로 타입(타입 매개변수가 없는 제네릭 타입)을 쓰는 걸 언어 차원에서 막아 놓지는 않았지만 절대로 써서는 안 된다.
  - 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.
  - 로 타입을 만들어놓은 이유는 (이전 버전의 자바와의) 호환성 때문.
- `List` 같은 로 타입은 사용해서는 안 되나, `List<Object>` 처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다.
  - `List`는 제네릭 타입에서 완전히 발을 뺀 것.
  - `List<Object>`는 모든 타입을 허용한다는 의미를 컴파일러에게 명확히 전달할 것.
  - 매개변수로 `List`를 받는 메서드에 `List<String>`을 넘길 수는 있지만, `List<Object>`를 받는 메서드에는 넘길 수 없다. 제네릭의 하위 타입 규칙 때문
  - 즉, `List<String>`은 `List`의 하위 타입이지만, `List<Object>`의 하위 타입은 아니다.
  - 그 결과, `List<Object>` 같은 매개변수화 타입을 사용할 때와 달리 `List` 같은 로 타입을 사용하면 타입 안정성을 잃게 된다.
- 비한정적 와일드카드 타입(unbounded wildcard type)
  - 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 `?`(물음표)를 사용하기.
  - ex. 제네릭 타입인 `Set<E>`의 비한정적 와일드카드 타입은 `Set<?>`
  - 둘의 차이는, 와일트카드 타입은 안전하고, 로 타입은 안전하지 않다.
  - 로 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다.
  - 반면 `Collection<?>`에는 null 외에는 어떤 원소도 넣을 수 없다. 다른 원소를 넣으려고 하면 컴파일 에러가 발생.
  - null 이외의 어떤 원소도 `Collection<?>`에 넣지 못하게 했으며 컬렉션에서 꺼낼 수 있는 객체의 타입도 전혀 알 수 없게 만든다. (-> 대안은 아이템 30, 아이템 31 참고)
- 예외적으로, 
  - class 리터럴에는 로 타입을 써야 한다. (ex. `List.class`)
  - `instance of` 연산자를 사용할 때 (ex. `instance of Set`)

#
### 아이템 27. 비검사 경고를 제거하라
- 제네릭을 사용하기 시작하면 수많은 컴파일러 경고를 보게 된다.
  - 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등
  - 제네릭에 익숙해질수록 마주치는 경고 수는 줄겠지만 새로 작성한 코드가 한번에 깨끗하게 컴파일되리라 기대는 말자.
- 대부분의 비검사 경고는 쉽게 제거할 수 있다.
  - 컴파일러가 알려준 대로 수정하면 경고가 사라진다.
  - 컴파일러가 알려준 타입 매개변수를 명시하지 않고, 다이아몬드 연산자(`<>`)만으로 해결할 수 있다. 그러면 컴파일러가 올바른 실제 타입 매개변수를 추론해준다.
- 할 수 있는 한 모든 비검사 경고를 제거하라. 모두 제거한다면 그 코드는 타입 안전성이 보장된다.
- 경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 `@SuppressWarnings("unchecked")` 애너테이션을 달아 경고를 숨기자.
  - `@SuppressWarnings("unchecked")`는 개별 지역변수 선언부터 클래스 전체까지 어떤 선언에도 달 수 있다.
  - 하지만 항상 가능한 한 좁은 범위에 적용하자. 보통 변수 선언, 아주 짧은 메서드, 혹은 생성자가 될 것이다.
  - 자칫 심각한 경고를 놓칠 수 있으니 절대로 클래스 전체에 적용해서는 안 된다.
  - 이 애너테이션을 사용할 때면 그 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야 한다.
