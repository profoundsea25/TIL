# 5장. 제네릭
- Java 5~
- 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려주게 된다. 
- 그래서 컴파일러는 알아서 형변환 코드를 추가할 수 있게 되고, 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단하여 더 안전하고 명확한 프로그램을 만들어준다.

#
### 아이템 26. 로 타입(raw type)은 사용하지 말라
- 클래스와 인터페이스 선언에 타입 매개변수(type parameter)가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라 한다. 이를 통틀어 제네릭 타입(generic type)이라 한다.
- 각각의 제네릭 타입은 일련의 매개변수화 타입(parameterized type)을 정의한다.
  - 먼저 클래스(혹은 인터페이스) 이름이 나오고, 이어서 꺾쇠괄호 안에 실제 타입 매개변수들을 나열한다.
  - 예를 들어, `List<String>`은 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다.
- 제네릭 타입을 하나 정의하면 그에 딸린 로 타입(raw type)도 함께 정의한다.
  - 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. (ex. `List<E>`의 로 타입은 `List`)
  - 로 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책
- 제네릭을 활용하면 특정 인스턴스만 취급한다는 정보를 주석이 아닌 타입 선언 자체에 녹아들 수 있도록 할 수 있다.
  - 오류는 가능한 한 발생 즉시, 이상적으로는 컴파일할 때 발견하는 것이 좋다.
  - 오류가 발생하고 한참 뒤인 런타임에야 알아챌 수 있는 경우에는, 런타임에 문제를 겪는 코드와 원인을 제공한 코드가 물리적으로 상당히 떨어져 있을 가능성이 커진다.
  - 제네릭으로 선언하면 컴파일러는 특정 인스턴스만 넣어야 함을 인지하게 된다.
  - 따라서 아무런 경고 없이 컴파일된다면 의도대로 동작할 것임을 보장한다. (컴파일러 경고를 숨기지 않았어야 한다.)
  - 엉뚱한 타입의 인스턴스를 넣으려 하면 컴파일 오류가 발생하며, 무엇이 잘못됐는지 정확히 알려준다.
  - 컴파일러는 보이지 않는 형변환을 추가하여 절대 실패하지 않음을 보장한다.
- 로 타입(타입 매개변수가 없는 제네릭 타입)을 쓰는 걸 언어 차원에서 막아 놓지는 않았지만 절대로 써서는 안 된다.
  - 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.
  - 로 타입을 만들어놓은 이유는 (이전 버전의 자바와의) 호환성 때문.
- `List` 같은 로 타입은 사용해서는 안 되나, `List<Object>` 처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다.
  - `List`는 제네릭 타입에서 완전히 발을 뺀 것.
  - `List<Object>`는 모든 타입을 허용한다는 의미를 컴파일러에게 명확히 전달할 것.
  - 매개변수로 `List`를 받는 메서드에 `List<String>`을 넘길 수는 있지만, `List<Object>`를 받는 메서드에는 넘길 수 없다. 제네릭의 하위 타입 규칙 때문
  - 즉, `List<String>`은 `List`의 하위 타입이지만, `List<Object>`의 하위 타입은 아니다.
  - 그 결과, `List<Object>` 같은 매개변수화 타입을 사용할 때와 달리 `List` 같은 로 타입을 사용하면 타입 안정성을 잃게 된다.
- 비한정적 와일드카드 타입(unbounded wildcard type)
  - 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 `?`(물음표)를 사용하기.
  - ex. 제네릭 타입인 `Set<E>`의 비한정적 와일드카드 타입은 `Set<?>`
  - 둘의 차이는, 와일트카드 타입은 안전하고, 로 타입은 안전하지 않다.
  - 로 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다.
  - 반면 `Collection<?>`에는 null 외에는 어떤 원소도 넣을 수 없다. 다른 원소를 넣으려고 하면 컴파일 에러가 발생.
  - null 이외의 어떤 원소도 `Collection<?>`에 넣지 못하게 했으며 컬렉션에서 꺼낼 수 있는 객체의 타입도 전혀 알 수 없게 만든다. (-> 대안은 아이템 30, 아이템 31 참고)
- 예외적으로, 
  - class 리터럴에는 로 타입을 써야 한다. (ex. `List.class`)
  - `instance of` 연산자를 사용할 때 (ex. `instance of Set`)

#
### 아이템 27. 비검사 경고를 제거하라
- 제네릭을 사용하기 시작하면 수많은 컴파일러 경고를 보게 된다.
  - 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등
  - 제네릭에 익숙해질수록 마주치는 경고 수는 줄겠지만 새로 작성한 코드가 한번에 깨끗하게 컴파일되리라 기대는 말자.
- 대부분의 비검사 경고는 쉽게 제거할 수 있다.
  - 컴파일러가 알려준 대로 수정하면 경고가 사라진다.
  - 컴파일러가 알려준 타입 매개변수를 명시하지 않고, 다이아몬드 연산자(`<>`)만으로 해결할 수 있다. 그러면 컴파일러가 올바른 실제 타입 매개변수를 추론해준다.
- 할 수 있는 한 모든 비검사 경고를 제거하라. 모두 제거한다면 그 코드는 타입 안전성이 보장된다.
- 경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 `@SuppressWarnings("unchecked")` 애너테이션을 달아 경고를 숨기자.
  - `@SuppressWarnings("unchecked")`는 개별 지역변수 선언부터 클래스 전체까지 어떤 선언에도 달 수 있다.
  - 하지만 항상 가능한 한 좁은 범위에 적용하자. 보통 변수 선언, 아주 짧은 메서드, 혹은 생성자가 될 것이다.
  - 자칫 심각한 경고를 놓칠 수 있으니 절대로 클래스 전체에 적용해서는 안 된다.
  - 이 애너테이션을 사용할 때면 그 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야 한다.

#
### 아이템 28. 배열보다는 리스트를 사용하라
- 배열과 제네릭의 차이점 두 가지
  - 배열은 공변(covariant), 제네릭은 불공변(invariant)
    - 공변 : Sub가 Super의 하위 타입이면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다.
    - 불공변 : 서로 다른 Type1과 Type2가 있을 때, List\<Type1\>은 List\<Type2\>의 하위 타입도 아니고 상위 타입도 아니다.
    - 문제가 되는 것은 배열 쪽
  - 배열은 실체화(reify)된다.
    - 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.
    - 제네릭은 타입 정보가 런타임에는 소거(erasure)된다. 원소 타입을 컴파일타임에만 검사하며 런타임에는 알 수조차 없다.
  - 이러한 차이로 인해 배열과 제네릭은 잘 어우러지지 못한다.
    - 예를 들면, 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.
    - 즉, `new List<E>[]`, `new List<String>[]`, `new E[]` 식으로 작성하면 컴파일할 때 제네릭 배열 생성 오류를 일으킨다.
- 제네릭 배열을 만들지 못하게 막은 이유는, 타입 안전하지 않기 때문이다.
  - `E`, `List<E>`, `List<String>` 같은 타입을 실체화 불가 타입(non-reifiable type)이라 한다.
  - 실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입이다.
  - 매개변수화 타입 가운데 실체화될 수 있는 타입은 `List<?>`와 `Map<?,?>` 같은 비한정적 와일드카드 타입뿐이다.
- 배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우 대부분은 배열인 `E[]` 대신 컬렉션인 `List<E>`를 사용하면 해결된다. 코드가 조금 복잡해지고 성능이 살짝 나빠질 수도 있지만, 그 대신 타입 안전성과 상호운영성은 좋아진다.
- 정리 : 배열은 런타임에는 타입 안전하지만 컴파일타임에는 그렇지 않다. 제네릭은 그 반대다. 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방법을 적용해보자.

#
### 아이템 29. 이왕이면 제네릭 타입으로 만들라
```java
public class Stack {
  private Object[] elements;
  private int size = 0;
  private static final int DEFAULT_INITIAL_CAPACITY = 16;
  
  public Stack() {
    elements = new Object[DEFAULT_INITIAL_CAPACITY];
  }
  
  public void push(Object e) {
    ensureCapacity();
    elements[size++] = e;
  }
  
  public Object pop() {
    if (size == 0) {
      throw new EmptyStackException();
    }
    Object result = elements[--size];
    elements[size] = null;
    return result;
  }
  
  public boolean isEmpty() {
    return size == 0;
  }
  
  private void ensureCapacity() {
    if (elements.length == size) {
      elements = Arrays.copyOf(elements, 2 * size + 1)
    }
  }
}

```
- 일반 클래스를 제네릭 클래스로 만드는 첫 단계는 클래스 선언에 타입 매개변수(보통 `E`)를 추가하는 일이다. 그런 다음 코드에 쓰인 `Object`를 적절한 타입 매개변수`E`로 바꾸고 컴파일한다.
- `E` 같은 실체화 불가 타입으로는 배열을 만들 수 없다.
  - 해결책 1) 제네릭 배열 생성을 금지하는 제약을 대놓고 우회
    - `Object` 배열을 생성한 다음 제네릭 배열로 형변환. (경고 발생)
    - 일반적으로 타입 안전하지 않지만, 해당 배열이 private이고, 클라이언트로 반환되거나, 다른 메서드에 전달되는 일이 전혀 없으며, 원소의 타입이 항상 `E`를 보장함을 안다면, `@SuppressWarnings`로 해당 경고를 숨기자.
    - 가독성이 더 좋고, 코드도 더 짧다.
    - 그러나 배열의 런타임 타입이 컴파일타임 타입과 달라 힙 오염(heap pollution)을 일으킨다.
    - 제네릭 타입 안에서 리스트를 사용하는 게 항상 가능하지도, 꼭 더 좋은 것도 아니다. 자바가 리스트를 기본 타입으로 제공하지 않으므로 `ArrayList` 같은 제네릭 타입도 결국 기본 타입인 배열을 사용해 구현해야 한다. 또한 `HashMap` 같은 제네릭 타입은 성능을 높일 목적으로 배열을 사용하기도 한다.
```java
@SuppressWarnings("unchecked")
public Stack() {
  elements = (E[]) new Object[DEFAULT_INITAIL_CAPACITY];
}
```
  - 해결책 2) 필드 타입을 `E[]`에서 `Object[]`로 변경
```java
@SuppressWarnings("unchecked") E result = (E) elements[--size];
```
#### 정리
- 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다. 그러니 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 하라.
- 그렇게 하려면 제네릭 타입으로 만들어야 할 경우가 많다. 기존 타입 중 제네릭이었어야 하는 게 있다면 제네릭 타입으로 변경하자.

#
### 아이템 30. 이왕이면 제네릭 메서드로 만들라
- 메서드도 제네릭으로 만들 수 있다. 매개변수화 타입을 받는 정적 유틸리티 메서드는 보통 제네릭이다.
- (타입 매개변수들을 선언하는) 타입 매개변수 목록(`<E>`)은 메서드의 제한자와 반환 타입(`Set<E>`) 사이에 온다.
- 제네릭 싱글턴 팩터리
  - 제네릭은 런타임에 타입 정보가 소거되므로 하나의 객체를 어떤 타입으로든 매개변수화할 수 있다.
  - 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 정적 팩터리
  - ex. `Collections.reverseOrder`, `Collections.emptySet`, 항등함수
- 재귀적 타입 한정(recursive type bound) 
  - 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정하는 것
  - 주로 타입의 자연적 순서를 정하는 `Comparable` 인터페이스와 함께 쓰인다.
  - `<E extends Comparable<E>>` = "모든 타입 E는 자신과 비교할 수 있다."
- 제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기도 쉽다.
- 타입과 마찬가지로, 메서드도 형변환 없이 사용할 수 있는 편이 좋으며, 많은 경우 그렇게 하려면 제네릭 메서드가 되어야 한다.
- 역시 타입과 마찬가지로, 형변환을 해줘야 하는 기존 메서드는 제네릭하게 만들자.

#### 질문
- 타입 매개변수 목록은 '이 메서드에서는 이러한 타입 매개변수만을 사용하다'고 선언하는 용도로 이해하면 ?

#
### 아이템 31. 한정적 와일드카드를 사용해 API 유연성을 높이라
- 매개변수화 타입은 불공변(invariant). 즉, 서로 다른 타입 Type1과 Type2가 있을 때 `List<Type1>`은 `List<Type2>`의 하위 타입도 상위 타입도 아니다.
- 하지만 때론 불공변 방식보다 유연한 무언가가 필요하다. 그것이 바로 한정적 와일드카드 타입이라는 특별한 매개변수화 타입이다. 
- 예를 들면,
  - `Iterable<? extends E>` = E의 하위 타입의 Iterable (참고로 하위 타입은 자기 자신도 포함한다. extends라는 키워드가 엄밀히 어울리는 단어는 아니다.)
  - `Collection<? super E>` = E의 상위 타입의 Collection (상위 타입 또한 자기 자신을 포함한다.)
- 유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하라.
- 타입을 정확히 지정해야 할 때는 (예를 들면 입력 매개변수가 생산자와 소비자 역할을 동시에 한다면,) 와일드카드 타입을 쓰지 말아야 한다.
- 와일드카드 타입 사용 기본 원칙 PECS = producer-`extends`, consumer-`super`
  - 즉 매개변수화 타입 T가 생산자라면 `<? extends T>`를 사용하고, 소비자라면 `<? super T>`를 사용하라.
- 반환 타입에는 한정적 와일드카드 타입을 사용하면 안 된다. 유연성을 높여주기는커녕 클라이언트 코드에서도 와일드카드 타입을 써야 하기 때문이다.
- 제대로만 사용한다면 클래스 사용자는 와일드카드 타입이 쓰였다는 사실조차 의식하지 못할 것이다. 받아들여야 할 매개변수를 받고 거절해야 할 매개변수는 거절하는 작업이 알아서 이뤄진다. 클래스 사용자가 와일드카드 타입을 신경 써야 한다면 그 API에 무슨 문제가 있을 가능성이 크다.
- `Comparable`이나 `Comparator`는 언제나 소비자이므로, 일반적으로 `Comparable<? super E>`, `Comparator<? super E>`를 사용하는 편이 낫다.
  - `Comparable`(혹은 `Compatator`)를 직접 구현하지 않고, 직접 구현한 다른 타입을 확장한 타입을 지원하기 위해 와일드카드가 필요하다.
- 타입 매개변수와 와일드카드에는 공통되는 부분이 있어서, 메서드를 정의할 때 둘 중 어느 것을 사용해도 괜찮을 때가 많다.
  - 기본 규칙 : 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하라.
  - 이때 비한정적 타입 매개변수라면 비한정적 와일드카드로 바꾸고, 한정적 타입 매개변수라면 한정적 와일드카드로 바꾸면 된다.
  - 와일드카드 타입의 실제 타입을 알려주는 메서드를 private 도우미 메서드로 따로 작성하여 활용하면, 형변환이나 리스트의 로 타입을 사용하지 않고도 해결할 수 있다.
  - 실제 타입을 알아내려면 이 도우미 메서드는 제네릭 메서드여야 한다.
  - 내부에서는 더 복잡한 제네릭 메서드가 생기지만, 덕분에 외부에는 와일드카드 기반의 멋진 선언을 유지할 수 있다.
- 조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다. 그러나 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해줘야 한다.

#### 질문
- 와일드카드를 사용했는데, 만약 복잡한 내부 로직을 구현해야 한다면 결국 특정 제네릭으로 바꿔서 구현해야 한다는 의미인가?
- 타입 매개변수의 종류와 각각의 용도
