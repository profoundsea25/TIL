# 7장. 람다와 스트림
### 아이템 42. 익명 클래스보다는 람다를 사용하라
- 함수형 인터페이스
  - 추상 메서드 하나짜리 인터페이스
  - 이 인터페이스들의 인스턴스를 람다식(lambda expression)을 사용해 만들 수 있음
- 람다
  - 매개변수, 반환값의 타입은 컴파일러가 문맥을 살펴 타입을 추론한다.
  - 컴파일러가 타입을 결정하지 못할 경우, 프로그래머가 직접 명시하면 된다.
  - 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자.
  - 람다에서의 타입 추론 측면에서 제네릭을 사용하는 것은 매우 중요하다.
  - 메서드나 클래스와 달리, 람다는 이름이 없고 문서화도 못 하기 때문에 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.
  - 람다는 한 줄일 때 가장 좋고 길어야 세 줄 안에 끝내는 게 좋다.
  - 람다는 함수형 클래스에서만 쓰인다.
    - 예컨대 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니, 익명 클래스를 써야 한다.
    - 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명 클래스를 쓸 수 있다.
  - 람다는 자신을 참조할 수 없다. 람다에서의 `this` 키워드는 바깥 인스턴스를 가리킨다.
    - 익명 클래스에서의 `this`는 익명 클래스의 인스턴스 자신을 가리킨다.
    - 따라서 함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 써야 한다.
  - 람다를 직렬화하는 일은 극히 삼가야 한다. (익명 클래스의 인스턴스도 마찬가지다.)
    - 직렬화해야한다면 private 정적 중첩 클래스의 인스턴스를 사용하라.
- 익명 클래스는 (함수형 인터페이스가 아닌) 타입의 인스턴스를 만들 때만 사용하라.

#
### 아이템 43. 람다보다는 메서드 참조를 사용하라
- 매개변수 수가 늘어날수록 메서드 참조로 제거할 수 있는 코드양도 늘어난다.
  - 하지만 어떤 람다에서는 매개변수의 이름 자체가 프로그래머에게 좋은 가이드가 되기도 한다.
  - 이런 람다는 길이는 더 길지만 메서드 참조보다 읽기 쉽고 유지보수도 쉬울 수 있다.
- 람다로 할 수 없는 일이라면 메서드 참조로도 할 수 없다.
- 람다로 구현했을 때 너무 길거나 복잡하다면 메서드 참조가 좋은 대안이 된다.
  - 즉 람다로 작성할 코드를 새로운 메서드에 담은 다음, 람다 대신 그 메서드 참조를 사용하는 식이다.
- 때론 람다가 메서드 참조보다 간결할 때가 있다. 주로 메서드와 람다가 같은 클래스에 있을 때 그렇다.
- 메서드 참조 유형 5가지
  - 정적 메서드를 가리키는 메서드 참조
  - 인스턴스 메서드를 참조하는 유형
    - 수신 객체(참조 대상 인스턴스)를 특정하는 적 인스턴스 메서드 참조
    - 수신 객체를 특정하지 않는 비한정적 인스턴스 메서드 참조
  - 클래스 생성자를 가리키는 메서드 참조
  - 배열 생성자를 가리키는 메서드 참조

#
### 아이템 44. 표준 함수형 인터페이스를 사용하라
- 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라.
- 표준 함수형 인터페이스
  - `UnaryOperator` : 반환값과 인수의 타입이 같은 함수, 인수 1개
  - `BinaryOperator` : 반환값과 인수의 타입이 같은 함수, 인수 2개
  - `Predicate` : 인수 하나를 받아 boolean을 반환하는 함수
  - `Fucntion` : 인수와 반환 타입이 다른 함수
  - `Supplier` : 인수를 받지 않고 값을 반환(혹은 제공)하는 함수
  - `Consumer` : 인수를 하나 받고 반환값은 없는(특히 인수를 소비하는) 함수
- 표준 함수형 인터페이스 대부분 기본 타입만 지원한다.
- 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지 말라. (계산량이 많을 때는 성능이 처참히 느려진다.)
- 아래 3개의 기준 중 하나 이상을 만족한다면 전용 함수형 인터페이스를 구현해야 할지 고민하라
  - 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다.
  - 반드시 따라야 하는 규칙이 있다.
  - 유용한 디폴트 메서드를 제공할 수 있다.
- `@Functional Interface`를 사용하는 이유
  - 해당 클래스의 코드나 설명 문서를 읽을 이에게 그 인터페이스가 람다용으로 설계된 것임을 알려준다.
  - 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
  - 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다.
- 직접 만든 함수형 인터페이스에는 항상 `@Functional Interface` 사용하라.
- 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의해서는 안 된다.
