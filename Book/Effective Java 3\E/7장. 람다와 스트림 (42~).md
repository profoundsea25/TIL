# 7장. 람다와 스트림
### 아이템 42. 익명 클래스보다는 람다를 사용하라
- 함수형 인터페이스
  - 추상 메서드 하나짜리 인터페이스
  - 이 인터페이스들의 인스턴스를 람다식(lambda expression)을 사용해 만들 수 있음
- 람다
  - 매개변수, 반환값의 타입은 컴파일러가 문맥을 살펴 타입을 추론한다.
  - 컴파일러가 타입을 결정하지 못할 경우, 프로그래머가 직접 명시하면 된다.
  - 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자.
  - 람다에서의 타입 추론 측면에서 제네릭을 사용하는 것은 매우 중요하다.
  - 메서드나 클래스와 달리, 람다는 이름이 없고 문서화도 못 하기 때문에 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.
  - 람다는 한 줄일 때 가장 좋고 길어야 세 줄 안에 끝내는 게 좋다.
  - 람다는 함수형 클래스에서만 쓰인다.
    - 예컨대 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니, 익명 클래스를 써야 한다.
    - 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명 클래스를 쓸 수 있다.
  - 람다는 자신을 참조할 수 없다. 람다에서의 `this` 키워드는 바깥 인스턴스를 가리킨다.
    - 익명 클래스에서의 `this`는 익명 클래스의 인스턴스 자신을 가리킨다.
    - 따라서 함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 써야 한다.
  - 람다를 직렬화하는 일은 극히 삼가야 한다. (익명 클래스의 인스턴스도 마찬가지다.)
    - 직렬화해야한다면 private 정적 중첩 클래스의 인스턴스를 사용하라.
- 익명 클래스는 (함수형 인터페이스가 아닌) 타입의 인스턴스를 만들 때만 사용하라.

#
### 아이템 43. 람다보다는 메서드 참조를 사용하라
- 매개변수 수가 늘어날수록 메서드 참조로 제거할 수 있는 코드양도 늘어난다.
  - 하지만 어떤 람다에서는 매개변수의 이름 자체가 프로그래머에게 좋은 가이드가 되기도 한다.
  - 이런 람다는 길이는 더 길지만 메서드 참조보다 읽기 쉽고 유지보수도 쉬울 수 있다.
- 람다로 할 수 없는 일이라면 메서드 참조로도 할 수 없다.
- 람다로 구현했을 때 너무 길거나 복잡하다면 메서드 참조가 좋은 대안이 된다.
  - 즉 람다로 작성할 코드를 새로운 메서드에 담은 다음, 람다 대신 그 메서드 참조를 사용하는 식이다.
- 때론 람다가 메서드 참조보다 간결할 때가 있다. 주로 메서드와 람다가 같은 클래스에 있을 때 그렇다.
- 메서드 참조 유형 5가지
  - 정적 메서드를 가리키는 메서드 참조
  - 인스턴스 메서드를 참조하는 유형
    - 수신 객체(참조 대상 인스턴스)를 특정하는 적 인스턴스 메서드 참조
    - 수신 객체를 특정하지 않는 비한정적 인스턴스 메서드 참조
  - 클래스 생성자를 가리키는 메서드 참조
  - 배열 생성자를 가리키는 메서드 참조

#
### 아이템 44. 표준 함수형 인터페이스를 사용하라
- 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라.
- 표준 함수형 인터페이스
  - `UnaryOperator` : 반환값과 인수의 타입이 같은 함수, 인수 1개
  - `BinaryOperator` : 반환값과 인수의 타입이 같은 함수, 인수 2개
  - `Predicate` : 인수 하나를 받아 boolean을 반환하는 함수
  - `Fucntion` : 인수와 반환 타입이 다른 함수
  - `Supplier` : 인수를 받지 않고 값을 반환(혹은 제공)하는 함수
  - `Consumer` : 인수를 하나 받고 반환값은 없는(특히 인수를 소비하는) 함수
- 표준 함수형 인터페이스 대부분 기본 타입만 지원한다.
- 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지 말라. (계산량이 많을 때는 성능이 처참히 느려진다.)
- 아래 3개의 기준 중 하나 이상을 만족한다면 전용 함수형 인터페이스를 구현해야 할지 고민하라
  - 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다.
  - 반드시 따라야 하는 규칙이 있다.
  - 유용한 디폴트 메서드를 제공할 수 있다.
- `@Functional Interface`를 사용하는 이유
  - 해당 클래스의 코드나 설명 문서를 읽을 이에게 그 인터페이스가 람다용으로 설계된 것임을 알려준다.
  - 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
  - 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다.
- 직접 만든 함수형 인터페이스에는 항상 `@Functional Interface` 사용하라.
- 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의해서는 안 된다.

#
### 아이템 45. 스트림은 주의해서 사용하라
- 스트림 API
  - 다량의 데이터 처리 작업(순차/병렬)을 돕고자 자바8에 추가됨.
  - 핵심 1. 데이터 원소의 유한 혹은 무한 시퀀스(sequence)
  - 핵심 2. 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현
- 특징
  - 스트림의 원소들은 컬렉션, 배열, 파일 등 어디로부터든 올 수 있다.
  - 스트림 안의 데이터 원소들은 객체 참조나 기본 타입 값(int, long, double)이다.
  - 소스 스트림 -> 중간 연산(intermediate operation) -> 종단 연산(terminal operation)
  - 스트림 파이프라인은 지연 평가(lazy evaluation)된다. 즉, 종단 연산이 호출될 때 평가가 이뤄지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다.
    - 종단 연산이 없는 스트림 파이프라인은 아무 일도 일어나지 않는다.
  - 메서드 연쇄를 지원하는 fluent API
- 주의
  - 스트림을 제대로 사용하면 프로그램이 짧고 깔끔해지지만, 과용하면 읽기 어렵고 유지보수도 힘들어진다.
  - 람다에서는 타입 이름을 자주 생략하므로 매개변수 이름을 잘 지어야 스트림 파이프라인의 가독성이 유지된다.
  - 연산에 적절한 이름을 지어주고 세부 구현을 주 프로그램 로직 밖으로 빼내어 만든 도우미 메서드를 적절히 활용하라. (일반 반복 코드에서보다 스트림 파이프라인에서 훨씬 중요하다.)
  - char 값들을 처리할 때는 스트림을 삼가야 한다.
  - 기존 코드는 스트림을 사용하도록 리팩터링하되, 새 코드가 더 나아 보일 때만 반영할 것
  - 스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 택하라
  - 팀 기준에 맞출 것
- 스트림을 쓰기 적절한 경우
  - 원소들을 일관되게 변환한다.
  - 원소들을 필터링한다.
  - 원소들을 하나의 연산을 사용해 결합한다.
  - 원소들을 공통 기준을 가지고 컬렉션에 모은다.
  - 원소들 중 특정 조건을 만족하는 원소를 찾는다.
- 스트림을 쓰기 부적절한 경우
  - 코드 블록 안의 지역변수를 수정해야 할 경우
  - `return`, `break`, `continue` 기능이 필요한 경우
  - 메서드 선언에 명시된 Checked Exception을 던져야 하는 경우
  - 스트림 파이프라인에서 하나의 연산을 거친 후에, 원래 값 혹은 앞 단계의 값에 접근하고자 하는 경우

#
### 아이템 46. 스트림에서는 부작용 없는 함수를 사용하라
- 스트림 패러다임의 핵심은 계산을 일련의 변환(transformation)으로 재구성하는 부분이다.
  - 이때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수 함수여야 한다.
  - 순수 함수란 오직 입력만이 결과에 영향을 주는 함수를 말한다.
  - 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않는다.
  - 즉, 스트림 연산에 건네는 함수 객체는 모두 부작용(side effect)이 없어야 한다.
- `forEach` 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는 데는 쓰지 말자.
- collector에 대한 내용을 잘 숙지하라.
  - `toList`, `toSet`, `toMap`, `groupingBy`, `joining`

#
### 아이템 47. 반환 타입으로는 스트림보다 컬렉션이 낫다
- 원소 시퀀스를 반환할 때
  - 기본은 컬렉션 인터페이스
  - for-each 문에서만 쓰이거나 반환된 원소 시퀀스가 일부 Collection 메서드를 구현할 수 없을 때는 Iterable 인터페이스
  - 반환 원소들이 기본 타입이거나 성능에 민감한 상황이라면 배열
- 그러나 스트림은 반복(iteration)을 지원하지 않는다.
  - `Stream` 인터페이스는 `Iterable` 인터페이스가 정의한 추상 메서드를 전부 포함하며, 그 방식대로 동작하나, for-each로 스트림을 반복할 수 없다.
  - `Iterable`을 확장하지 않았기 때문이다.
- 객체 시퀀스를 반환하는 메서드를 작성할 때,
  - 이 메서드가 오직 스트림 파이프라인에서만 쓰인다면 스트림을 반환
  - 반복문에서만 쓰인다면 `Iterable` 반환
  - 반환 전부터 이미 원소들을 컬렉션에 담아 관리하고 있거나 컬렉션을 하나 더 만들어도 될 정도로 원소 개수가 적다면 `ArrayList` 같은 표준 컬렉션에 담아 반환
  - 원소 시퀀스를 반환하는 공개 API의 반환 타입에는 Collection이나 그 하위 타입을 쓰는 게 일반적으로 최선이다.

#
### 아이템 48. 스트림 병렬화는 주의해서 적용하라
- 동시성 프로그래밍을 할 때는 안전성(safety)과 응답 가능(liveness) 상태를 유지하기 위해 애써야 한다.
- `parallel`를 쓴다고 늘 성능이 향상되지 않는다.
  - 데이터 소스가 `Stream.iterate`거나 중간 연산으로 `limit`을 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.
- 대체로 스트림의 소스가 `ArrayList`, `HashMap`, `HashSet`, `ConcurrentHashMap`의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다.
  - 이들은 참조 지역성(locality of reference)이 뛰어나다는 것이다.
  - 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있다는 뜻이다.
- 스트림 파이프라인의 종단 연산의 동작 방식 역시 병렬 수행 효율에 영향을 준다.
  - 종단 연산 중 병렬화에 가장 적합한 것은 축소(reduction)다.
  - 축소란 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업이다.
  - `anyMatch`, `allMatch`, `noneMatch`처럼 조건에 맞으면 바로 반환되는 메서드도 병렬화에 적합하다.
  - 반면 가변 축소(mutable reduction)은 적합하지 않다. 컬렉션들을 합치는 부담이 크기 때문이다.
- 스트림을 잘못 병렬화하면 응답 불가를 포함해 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.
- 파이프라인이 수행하는 진짜 작업이 병렬화에 드는 추가 비용을 상쇄하지 못한다면 성능 향상은 미미할 수 있다.
- 스트림 병렬화는 오직 성능 최적화 수단임을 기억해야 한다.
  - 다른 최적화와 마찬가지로 변경 전후로 반드시 성능을 테스트하여 병렬화를 사용할 가치가 있는지 확인해야 한다.
- 조건만 잘 맞으면 `parallel` 메서드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 만끽할 수 있다.
