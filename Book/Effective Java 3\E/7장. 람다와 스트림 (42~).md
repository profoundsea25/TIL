# 7장. 람다와 스트림
### 아이템 42. 익명 클래스보다는 람다를 사용하라
- 함수형 인터페이스
  - 추상 메서드 하나짜리 인터페이스
  - 이 인터페이스들의 인스턴스를 람다식(lambda expression)을 사용해 만들 수 있음
- 람다
  - 매개변수, 반환값의 타입은 컴파일러가 문맥을 살펴 타입을 추론한다.
  - 컴파일러가 타입을 결정하지 못할 경우, 프로그래머가 직접 명시하면 된다.
  - 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자.
  - 람다에서의 타입 추론 측면에서 제네릭을 사용하는 것은 매우 중요하다.
  - 메서드나 클래스와 달리, 람다는 이름이 없고 문서화도 못 하기 때문에 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.
  - 람다는 한 줄일 때 가장 좋고 길어야 세 줄 안에 끝내는 게 좋다.
  - 람다는 함수형 클래스에서만 쓰인다.
    - 예컨대 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니, 익명 클래스를 써야 한다.
    - 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명 클래스를 쓸 수 있다.
  - 람다는 자신을 참조할 수 없다. 람다에서의 `this` 키워드는 바깥 인스턴스를 가리킨다.
    - 익명 클래스에서의 `this`는 익명 클래스의 인스턴스 자신을 가리킨다.
    - 따라서 함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 써야 한다.
  - 람다를 직렬화하는 일은 극히 삼가야 한다. (익명 클래스의 인스턴스도 마찬가지다.)
    - 직렬화해야한다면 private 정적 중첩 클래스의 인스턴스를 사용하라.
- 익명 클래스는 (함수형 인터페이스가 아닌) 타입의 인스턴스를 만들 때만 사용하라.

#
### 아이템 43. 람다보다는 메서드 참조를 사용하라
- 매개변수 수가 늘어날수록 메서드 참조로 제거할 수 있는 코드양도 늘어난다.
  - 하지만 어떤 람다에서는 매개변수의 이름 자체가 프로그래머에게 좋은 가이드가 되기도 한다.
  - 이런 람다는 길이는 더 길지만 메서드 참조보다 읽기 쉽고 유지보수도 쉬울 수 있다.
- 람다로 할 수 없는 일이라면 메서드 참조로도 할 수 없다.
- 람다로 구현했을 때 너무 길거나 복잡하다면 메서드 참조가 좋은 대안이 된다.
  - 즉 람다로 작성할 코드를 새로운 메서드에 담은 다음, 람다 대신 그 메서드 참조를 사용하는 식이다.
- 때론 람다가 메서드 참조보다 간결할 때가 있다. 주로 메서드와 람다가 같은 클래스에 있을 때 그렇다.
- 메서드 참조 유형 5가지
  - 정적 메서드를 가리키는 메서드 참조
  - 인스턴스 메서드를 참조하는 유형
    - 수신 객체(참조 대상 인스턴스)를 특정하는 적 인스턴스 메서드 참조
    - 수신 객체를 특정하지 않는 비한정적 인스턴스 메서드 참조
  - 클래스 생성자를 가리키는 메서드 참조
  - 배열 생성자를 가리키는 메서드 참조

#
### 아이템 44. 표준 함수형 인터페이스를 사용하라
- 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라.
- 표준 함수형 인터페이스
  - `UnaryOperator` : 반환값과 인수의 타입이 같은 함수, 인수 1개
  - `BinaryOperator` : 반환값과 인수의 타입이 같은 함수, 인수 2개
  - `Predicate` : 인수 하나를 받아 boolean을 반환하는 함수
  - `Fucntion` : 인수와 반환 타입이 다른 함수
  - `Supplier` : 인수를 받지 않고 값을 반환(혹은 제공)하는 함수
  - `Consumer` : 인수를 하나 받고 반환값은 없는(특히 인수를 소비하는) 함수
- 표준 함수형 인터페이스 대부분 기본 타입만 지원한다.
- 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지 말라. (계산량이 많을 때는 성능이 처참히 느려진다.)
- 아래 3개의 기준 중 하나 이상을 만족한다면 전용 함수형 인터페이스를 구현해야 할지 고민하라
  - 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다.
  - 반드시 따라야 하는 규칙이 있다.
  - 유용한 디폴트 메서드를 제공할 수 있다.
- `@Functional Interface`를 사용하는 이유
  - 해당 클래스의 코드나 설명 문서를 읽을 이에게 그 인터페이스가 람다용으로 설계된 것임을 알려준다.
  - 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
  - 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다.
- 직접 만든 함수형 인터페이스에는 항상 `@Functional Interface` 사용하라.
- 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의해서는 안 된다.

#
### 아이템 45. 스트림은 주의해서 사용하라
- 스트림 API
  - 다량의 데이터 처리 작업(순차/병렬)을 돕고자 자바8에 추가됨.
  - 핵심 1. 데이터 원소의 유한 혹은 무한 시퀀스(sequence)
  - 핵심 2. 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현
- 특징
  - 스트림의 원소들은 컬렉션, 배열, 파일 등 어디로부터든 올 수 있다.
  - 스트림 안의 데이터 원소들은 객체 참조나 기본 타입 값(int, long, double)이다.
  - 소스 스트림 -> 중간 연산(intermediate operation) -> 종단 연산(terminal operation)
  - 스트림 파이프라인은 지연 평가(lazy evaluation)된다. 즉, 종단 연산이 호출될 때 평가가 이뤄지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다.
    - 종단 연산이 없는 스트림 파이프라인은 아무 일도 일어나지 않는다.
  - 메서드 연쇄를 지원하는 fluent API
- 주의
  - 스트림을 제대로 사용하면 프로그램이 짧고 깔끔해지지만, 과용하면 읽기 어렵고 유지보수도 힘들어진다.
  - 람다에서는 타입 이름을 자주 생략하므로 매개변수 이름을 잘 지어야 스트림 파이프라인의 가독성이 유지된다.
  - 연산에 적절한 이름을 지어주고 세부 구현을 주 프로그램 로직 밖으로 빼내어 만든 도우미 메서드를 적절히 활용하라. (일반 반복 코드에서보다 스트림 파이프라인에서 훨씬 중요하다.)
  - char 값들을 처리할 때는 스트림을 삼가야 한다.
  - 기존 코드는 스트림을 사용하도록 리팩터링하되, 새 코드가 더 나아 보일 때만 반영할 것
  - 스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 택하라
  - 팀 기준에 맞출 것
- 스트림을 쓰기 적절한 경우
  - 원소들을 일관되게 변환한다.
  - 원소들을 필터링한다.
  - 원소들을 하나의 연산을 사용해 결합한다.
  - 원소들을 공통 기준을 가지고 컬렉션에 모은다.
  - 원소들 중 특정 조건을 만족하는 원소를 찾는다.
- 스트림을 쓰기 부적절한 경우
  - 코드 블록 안의 지역변수를 수정해야 할 경우
  - `return`, `break`, `continue` 기능이 필요한 경우
  - 메서드 선언에 명시된 Checked Exception을 던져야 하는 경우
  - 스트림 파이프라인에서 하나의 연산을 거친 후에, 원래 값 혹은 앞 단계의 값에 접근하고자 하는 경우

#
### 아이템 46. 스트림에서는 부작용 없는 함수를 사용하라
- 
