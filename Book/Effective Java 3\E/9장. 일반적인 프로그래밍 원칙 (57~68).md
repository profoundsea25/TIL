# 9. 일반적인 프로그래밍 원칙
### 아이템 57. 지역변수의 범위를 최소화하라
- "클래스와 멤버의 접근 권한을 최소화하라"(아이템 15)와 비슷
- 지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.
  - 지역변수의 범위를 줄이는 가장 강력한 기법은 역시 '가장 처음 쓰일 때 선언하기'다.
  - 미리 선언부터 해두면 코드가 어수선해져 가독성이 떨어진다.
  - 변수를 사용하는 시점엔 타입과 초깃값이 기억나지 않을 수도 있다.
  - 메서드를 작게 유지하고 한 가지 기능에 집중하도록 한다. 단순히 메서드를 기능별로 쪼개면 된다.
- 거의 모든 지역변수는 선언과 동시에 초기화해야 한다.
  - 초기화에 필요한 정보가 충분치 않다면 충분해질 때까지 선언을 미뤄야 한다.
  - 단, `try-catch`문은 예외다.
    - 변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 try 블록 안에서 초기화해야 한다.
    - 한편, 변수 값을 try 블록 바깥에서도 사용해야 한다면 try 블록 앞에서 선언해야 한다.
  - 반복문 변수의 값을 반복문이 종료된 뒤에도 써야 하는 상황이 아니라면 while문보다는 for문을 쓰는 편이 낫다.

#
### 아이템 58. 전통적인 `for`문보다는 `for-each`문을 사용하라
- 전통적인 for문(`Iterator`사용 포함)의 반복자와 인덱스 변수는 모두 코드를 지저분하게 할 뿐 우리에게 진짜 필요한 건 원소들뿐이다.
  - 더군다나 이처럼 쓰이는 요소 종류가 늘어나면 오류가 생길 가능성이 높아진다.
  - 잘못된 변수를 사용했을 때 컴파일러가 잡아주리라는 보장도 없다.
  - 컬렉션이냐 배열이냐에 따라 코드 형태가 상당히 달라진다.
- `for-each`문은 위의 문제를 모두 해결한다. 정식 이름은 '향상된 for문(enhanced for statement)'이다.
  - `for (Element e : elements) {}`의 표현에서 :은 '안의(in)'이라고 읽으면 된다.
  - 반복 대상이 컬렉션이든 배열이든 속도는 그대로다.
  - 컬렉션을 중첩해 순회해야 한다면 for-each 문의 이점이 더욱 커진다.
  - 컬렉션과 배열은 물론 `Iterable`인터페이스를 구현한 객체라면 무엇이든 순회할 수 있다.
- `for-each`문을 사용할 수 없는 세 가지 상황
  - 파괴적인 필터링(destructive-filtering)
    - 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 호출해야 한다.
    - 자바 8부터 Collection의 removeIf 메서드를 사용해 컬렉션을 명시적으로 순회하는 일을 피할 수 있다.
  - 변형(transforming)
    - 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 한다.
  - 병렬 반복(parallel iteration)
    - 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.

#
### 아이템 59. 라이브러리를 익히고 사용하라
- 표준 라이브러리를 사용하면,
  - 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.
    - ex. `Random` -> `ThreadLocalRandom` or `SplittableRandom`
  - 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다. 애플리케이션 기능 개발에 집중 가능하다.
  - 따로 노력하지 않아도 성능이 지속해서 개선된다는 점이다.
  - 기능이 점점 많아진다.
  - 여러분이 작성한 코드가 많은 사람에게 낯익은 코드가 된다. 자연스럽게 다른 개발자들이 더 읽기 좋고, 유지보수하기 좋고, 재활용하기 쉬운 코드가 된다.
- 표준 라이브러리의 기능을 사용하는 것이 좋아 보이지만, 실상은 많은 프로그래머가 직접 구현한다. 아마 라이브러리에 그런 기능이 있는지 모르기 때문일 것이다.
  - 메이저 릴리스마다 주목할 만한 수많은 기능이 라이브러리에 추가된다.
  - 자바 프로그래머라면 적어보 `java.lang`, `java.util`, `java.io`와 그 하위 패키지들에는 익숙해져야 한다.
  - 컬렉션 프레임워크와 스트림 라이브러리, `java.util.concurrent` 등을 알면 큰 도움이 된다.
- 우선 라이브러리를 사용하려 해보자.
  - 원하는 기능이 아니라 판단되면 대안을 사용하자.
  - 표준 라이브러리에서 원하는 기능을 찾지 못하면, 그다음 선택지는 고품질의 서드파티 라이브러리가 될 것이다.
  - 그것 또한 찾지 못했다면, 직접 구현이 답이다.
  - **바퀴를 다시 발명하지 말자.**

#
### 아이템 60. 정확한 답이 필요하다면 float와 double은 피하라
- `float`와 `double` 타입은 특히 금융 관련 계산과는 맞지 않는다. 공학/과학 계산용으로 설계되었다.
  - 금융 계산에는 `BigDemical`, `int` 혹은 `long`을 사용해야 한다.
  - `BigDemical`은 문자열을 받는 생성자가 있어, 계산시 부정확한 값이 사용되는 것을 막을 수 있다.
  - 다만, `BigDemical`은 기본 타입보다 쓰기가 훨씬 불편하고, 훨씬 느린 단점이 있다.
  - 그 대안으로 `int`, `long`을 사용할 수 있는데, 이 때는 다룰 수 있는 값의 크기가 제한되고, 소수점을 직접 관리해야 한다.
- 정리
  - ~9자리 십진수 -> `int`
  - ~18자리 십진수 -> `long`
  - ~그 이상 -> `BigDemical`

#
### 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라
- 오토박싱과 오토언박싱 덕분에 기본 타입(int, double, boolean 등)과 참조 타입(String, List 등)을 크게 구분하고 사용할 수는 있지만, 그렇다고 차이가 사라지는 것은 아니다.
  - 둘 사이에는 분명한 차이가 있으니 어떤 타입을 사용하는지는 상당히 중요하다. 주의해야 한다.
- 기본 타입과 박싱된 기본 타입의 차이점 3가지
  - 첫 번째, 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖는다. 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.
  - 두 번째, 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null을 가질 수 있다.
  - 세 번째, 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.
- 박싱된 타입에 `==` 연산자를 사용하면 오류가 일어난다.
  - 실무에서 이와 같이 기본 타입을 다루는 비교자가 필요하다면 `Comparator.naturalOrder()`를 사용하자.
  - 비교자를 직접 만들면 비교자 생성 메서드나 기본 타입을 받는 정적 compare 메서드를 사용해야 한다.
- 거의 예외 없이 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.
  - 그리고 null 참조를 언박싱하면 `NullPointerException`이 발생한다.
- 박싱된 기본타입을 언제 써야 하는가?
  - 첫 번째, 컬렉션의 원소, 키, 값으로 쓴다. 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야만 한다. 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 한다. 자바가 타입 매개변수로 기본 타입을 지원하지 않기 때문이다.
  - 두 번째, 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.
- 정리
  - 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 기본 타입을 사용하자. 기본 타입은 빠르고 간단하다.
  - 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.
  - 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, 언박싱 과정에서 `NullPointerException`을 던질 수 있다.
  - 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다.

#
### 아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라
- 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
  - I/O에서 받는 데이터가 수치형이면 int, float, BigInteger 등 적당한 수치 타입으로 변환해야 한다.
  - '예/아니오'는 적절한 열거 타입이나 boolean으로 변환해야 한다.
  - 기본 타입이든 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고, 없다면 새로 만들어라.
- 문자열은 열거 타입을 대신하기에 적합하지 않다. Enum 써라. 훨씬 낫다.
- 문자열은 혼합 타입을 대신하기에 적합하지 않다.
  - 문자열에 특수 문자로 데이터를 구분짓는 경우, 파싱하는데 느리고, 귀찮고, 오류 가능성이 커진다.
  - 적절한 equals, toString, compareTo 메서드를 제공할 수 없으며, String이 제공하는 기본 기능에만 의존해야 한다.
  - 차라리 전용 클래스를 만드는 게 낫다. 이런 클래스는 보통 private 정적 멤버 클래스로 선언한다.
- 문자열은 권한을 표현하기에 적합하지 않다.

#
### 아이템 63. 문자열 연결은 느리니 주의하라
- 문자열 연결 연산자 `+`는 여러 문자열을 하나로 합쳐주는 편리한 수단이지만, 문자열 n개를 잇는 시간은 n^2에 비례할만큼 연산이 느리다.
  - 문자열은 불변이기 때문에 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하기 때문이다.
- 성능을 포기하고 싶지 않다면 `String` 대신 `StringBuilder`를 사용하자.
- 문자 배열을 사용하거나, 문자열을 연결하지 않고 하나씩 처리하는 방법도 있다.

#
### 아이템 64. 객체는 인터페이스를 사용해 참조하라
- 적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.
  - 객체의 실제 클래스를 사용해야 할 상황은 '오직' 생성자로 생성할 때뿐이다.
  - 인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.
  - 나중에 구현 클래스를 교체하고자 한다면 그저 새 클래스의 생성자(혹은 다른 정적 팩터리)를 호출해주기만 하면 된다.
- 주의할 점. 원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하며, 주변 코드가 이 기능에 기대어 동작한다면 새로운 클래스도 반드시 같은 기능을 제공해야 한다.
  - 구현 타입을 바꾸려는 이유는 보통 원래 것보다 성능이 좋거나 멋진 신기능을 제공하기 때문일 것이다.
- 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다.
  - 1) String, BigInteger 같은 값 클래스. 값 클래스는 매개변수, 변수, 필드, 반환 타입으로 사용해도 무방하다.
  - 2) 클래스 기반으로 작성된 프레임워크가 제공하는 객체들. 다만 이런 경우라도 특정 구현 클래스보다는 기반 클래스(보통 추상 클래스다.)를 참조하는 게 좋다.
  - 3) 인터페이스에는 없는 특별한 메서드를 제공하는 클래스. 특별한 메서드를 꼭 사용해야 하는 경우를 최소화해야 하며, 절대 남발해서는 안 된다.
- 적합한 인터페이스가 없다면 클래스 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(= 상위의) 클래스를 타입으로 사용하자.

#
### 아이템 65. 리플렉션보다는 인터페이스를 사용하라
- 리플렉션 기능(`java.lang.reflect`)
  - 프로그램에서 임의의 클래스에 접근 가능
  - Class 객체가 주어지면 그 클래스의 생성자, 메서드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있다.
    - 그 인스턴스들로 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있다.
    - 그 인스턴스들을 통해 해당 클래스의 인스턴스를 생성하거나, 메서드를 호출하거나, 필드에 접근할 수 있다.
- 리플렉션의 단점
  - 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다.
    - 예외 검사도 마찬가지라 프로그램이 리플렉션 기능을 써서 존재하지 않는 혹은 접글할 수 없는 메서드를 호출하려 시도하면 런타임 오류가 발생한다.
  - 리플렉션을 이용하면 코드가 지저분해지고 장황해진다.
  - 성능이 떨어진다. 리플렉션을 이용한 메서드 호출은 일반 메서드 호출보다 훨씬 느리다.
- 리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할 수 있다.
  - 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 (컴파일타임에 알 수 있는)상위 클래스로 형변환해 사용하자.
  - 컴파일타임에는 알 수 없는 클래스를 사용하는 프로그램을 작성한다면 리플렉션을 사용해야 한다.

#
### 아이템 66. 네이티브 메서드는 신중히 사용하라
- 네이티브 메서드란 C나 C++같은 네이티브 프로그래밍 언어로 작성한 메서드
  - 레지스트리 같은 플랫폼 특화 기능을 사용할 때
  - 네이티브 코드로 작성된 기존 라이브러리를 사용할 때
  - 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성할 때
- 권장하지 않는 이유 : 자바가 그만큼 발전했기 때문.
  - 플랫폼 특화 기능을 자바가 흡수하고 있다. (ex. process API로 OS프로세스 접근 가능)
  - 자바 라이브러리들이 많아지고 있다.
  - 자바 3전과 비교했을 때, 성능 또한 C에 못지 않게 많이 개선되었다.
- 단점
  - 네이티브 언어가 안전하지 안않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 안전하지 않다. (GC가 작동하지 않는다!)
  - 자바보다 플랫폼을 많이 타서 이식성이 낮다.
  - 디버깅도 더 어렵다.
  - 주의하지 않으면 더 느려지기도 한다.
  - 네이티브 메서드와 자바 코드 사이의 '접착 코드'를 작성해야 하는데, 귀찮고 가독성이 떨어진다.

#
### 아이템 67. 최적화는 신중히 하라
- 저자가 추천하는 마음 깊이 새겨야 할 최적화 격언
  - (맹목적인 어리석음을 포함해) 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다. (심지어 효율을 높이지도 못하면서)
  - (전체의 97% 정도인) 자그마한 효율성은 모두 잊자. 섣부른 최적화가 만악의 근원이다.
  - 최적화를 할 때는 다음 두 규칙을 따르라.
    - 첫 번째, 하지 마라.
    - 두 번째, (전문가 한정) 아직 하지 마라. 다시 말해, 완전히 명백하고 최적화되지 않은 해법을 찾을 때까지는 하지 마라.
- 최적화의 실상
  - 최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고, 섣불리 진행하면 특히 더 그렇다.
  - 빠르지도 않고 제대로 동작하지도 않으면서 수정하기는 어려운 소프트웨어를 탄생시킨다.
  - 성능 때문에 견고한 구조를 희생하지 말자. **빠른 프로그램보다는 좋은 프로그램을 작성하라.**
    - 좋은 프로그램이지만 원하는 성능이 나오지 않는다면 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것이다.
    - 좋은 프로그램은 정보 은닉 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있다. 따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다.
  - 구현상의 문제는 해결할 수 있을지라도, 아키텍처의 결함이 성능을 제한하는 상황이라면 시스템 전체를 다시 작성하지 않고는 해결하기 불가능할 수 있다.
  - 완성된 설계의 기본 틀을 변경하려다 보면 유지보수하거나 개선하기 어려운 꼬인 구조의 시스템이 만들어지기 쉽다.
- 성능을 제한하는 설계를 피하라.
  - 완성 후 가장 변경하기 어려운 설계 요소는 컴포넌트끼리, 혹은 외부 시스템과의 소통 방식. (API, 네트워크 프로토콜, 영구 저장용 데이터 포멧 등)
  - API를 설계할 때 성능에 주는 영향을 고려하라.
    - public 타입을 가변으로 만들면, 내부 데이터가 변경될 수 있어 불필요한 방어적 복사를 수없이 유발할 수 있다.
    - 컴포지션 대신 상속으로 설계한 public 클래스는 상위 클래스에 영원히 종속된다. 그 성능 제약까지도 물려받는다.
    - 인터페이스 대신 구현 타입을 사용하는 것도 좋지 않다. 특정 구현체에 종속되게 하여, 나중에 더 빠른 구현체가 나오더라도 이용하지 못하게 된다.
  - 잘 설계된 API는 성능도 좋은 게 보통이다. 그러니 성능을 위해 API를 왜곡하는 건 매우 안 좋은 생각이다.
- 신중하게 설게하여 깨끗하고 명확한 멋진 구조를 갖춘 프로그램을 완성한 다음에야 최적화를 고려해볼 차례가 된다.
  - 물론 성능에 만족하지 못할 경우에 한정된다.
  - 하게 된다면 각각의 최적화 시도 전후로 성능을 반드시 측정하라.
  - 시도한 최적화 기법이 성능을 눈에 띄게 높이지 못하는 경우가 많고, 심지어 더 나빠지게 할 때도 있다.
  - 일반적으로 90%의 시간을 단 10%의 코드에서 사용한다.
  - 프로파일링 도구는 최적화 노력을 어디에 집중해야 할지 찾는데 도움을 준다.
  - 프로그램에 시간이 거듭제곱으로 증가하는(혹은 더 나쁜) 알고리즘이 숨어 있다면 더 효율적인 것으로 교체해야 한다.
  - 충분히 빠르다면 그것으로 끝이다.

#
### 아이템 68. 일반적으로 통용되는 명명 규칙을 따르라
- 자바의 철자 규칙
  - 패키지, 클래스, 인터페이스, 메서드, 필트, 타입 변수의 이름을 대상
  - 특별한 이유가 없는 한 반드시 따르자. 이 규칙을 어긴 API는 사용하기 어렵고, 유지보수하기 어렵다.
  - 패키지와 모듈 이름
    - 각 요소를 점(.)으로 구분하여 계층적으로 짓는다.
    - 요소들은 모두 소문자 알파벳 혹은 숫자다.
    - 조직의 인터넷 도메인 이름을 역순으로 사용한다.
    - 표준 라이브러리와 선택적 패키지들은 java와 javax를 사용.
    - 패키지 이름의 나머지는 해당 패키지를 설명하는 하나 이상의 요소로 이뤄진다.
    - 8자 이하의 짧은 단어. 요소의 이름은 보통 한 단어 혹은 약어로 이뤄진다.
  - 클래스와 인터페이스 (Enum과 애너테이션 포함)
    - 하나 이상의 단어로 이뤄지며, 각 단어는 대문자 시작
    - 여러 단어의 첫 글자를 딴 약자나, 널리 통용되는 줄임말을 제외하고는 단어를 줄여쓰지 않는다.
    - 약자 또한 첫 글자만 대문자로 써주는게 가독성에 좋다.
  - 메서드와 필드 이름
    - 첫 글자를 소문자한다.
    - 그 외는 클래스 명명 규칙과 같다.
    - 첫 단어가 약자라면 단어 전체가 소문자여야 한다.
  - 단, 상수 필드는 예외다.
    - 상수 필드를 구성하는 단어는 모두 대문자로 쓰며 단어 사이는 밑줄로 구분한다.
    - 상수 필드는 값이 불변인 static final 필드를 말한다.
  - 지역 변수
    - 약어를 써도 좋다.
    - 입력 매개변수도 지역변수의 하나지만, 메서드 설명 문서에도 등장하는 만큼 신경 써주자.
  - 타입 매개변수
    - 보통 한 문자로 표현
    - 임의의 타입엔 T, 컬렉션 원소엔 E, 맵의 키와 값에는 K와 V, 예외에는 X, 메서드의 반환 타입에는 R, 그 외에 임의 타입의 시퀀스에는 T, U, V 혹은 T1, T2, T3 사용
- 자바의 문법 규칙
  - 철자 규칙보다 유연, 논란도 더 많다.
  - 패키지에 대한 규칙은 따로 없다.
  - 기억할 것
    - `to{Type}` : 객체 타입을 바꿔서 다른 타입의 또 다른 객체를 반환하는 인스턴스 메서드
    - `as{Type}` : 객체의 내용을 다른 뷰로 보여주는 메서드
    - `{type}Value` : 객체의 값을 기본 타입 값으로 반환하는 메서드
    - `from, of, valueOf, instance, getInstance, newInstance, getType, newType` : 정적 팩터리 이름들
  - 필드 이름은 API 설계를 잘 했다면 필드가 직접 노출될 일이 거의 없기 때문에, 문법 규칙이 덜 명확하고 덜 중요하다.
- "오랫동안 따라온 규칙과 충돌한다면 그 규칙을 맹종해서는 안 된다."
