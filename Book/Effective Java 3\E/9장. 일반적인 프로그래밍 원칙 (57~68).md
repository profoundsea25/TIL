# 9. 일반적인 프로그래밍 원칙
### 아이템 57. 지역변수의 범위를 최소화하라
- "클래스와 멤버의 접근 권한을 최소화하라"(아이템 15)와 비슷
- 지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.
  - 지역변수의 범위를 줄이는 가장 강력한 기법은 역시 '가장 처음 쓰일 때 선언하기'다.
  - 미리 선언부터 해두면 코드가 어수선해져 가독성이 떨어진다.
  - 변수를 사용하는 시점엔 타입과 초깃값이 기억나지 않을 수도 있다.
  - 메서드를 작게 유지하고 한 가지 기능에 집중하도록 한다. 단순히 메서드를 기능별로 쪼개면 된다.
- 거의 모든 지역변수는 선언과 동시에 초기화해야 한다.
  - 초기화에 필요한 정보가 충분치 않다면 충분해질 때까지 선언을 미뤄야 한다.
  - 단, `try-catch`문은 예외다.
    - 변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 try 블록 안에서 초기화해야 한다.
    - 한편, 변수 값을 try 블록 바깥에서도 사용해야 한다면 try 블록 앞에서 선언해야 한다.
  - 반복문 변수의 값을 반복문이 종료된 뒤에도 써야 하는 상황이 아니라면 while문보다는 for문을 쓰는 편이 낫다.

#
### 아이템 58. 전통적인 `for`문보다는 `for-each`문을 사용하라
- 전통적인 for문(`Iterator`사용 포함)의 반복자와 인덱스 변수는 모두 코드를 지저분하게 할 뿐 우리에게 진짜 필요한 건 원소들뿐이다.
  - 더군다나 이처럼 쓰이는 요소 종류가 늘어나면 오류가 생길 가능성이 높아진다.
  - 잘못된 변수를 사용했을 때 컴파일러가 잡아주리라는 보장도 없다.
  - 컬렉션이냐 배열이냐에 따라 코드 형태가 상당히 달라진다.
- `for-each`문은 위의 문제를 모두 해결한다. 정식 이름은 '향상된 for문(enhanced for statement)'이다.
  - `for (Element e : elements) {}`의 표현에서 :은 '안의(in)'이라고 읽으면 된다.
  - 반복 대상이 컬렉션이든 배열이든 속도는 그대로다.
  - 컬렉션을 중첩해 순회해야 한다면 for-each 문의 이점이 더욱 커진다.
  - 컬렉션과 배열은 물론 `Iterable`인터페이스를 구현한 객체라면 무엇이든 순회할 수 있다.
- `for-each`문을 사용할 수 없는 세 가지 상황
  - 파괴적인 필터링(destructive-filtering)
    - 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 호출해야 한다.
    - 자바 8부터 Collection의 removeIf 메서드를 사용해 컬렉션을 명시적으로 순회하는 일을 피할 수 있다.
  - 변형(transforming)
    - 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 한다.
  - 병렬 반복(parallel iteration)
    - 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.

#
### 아이템 59. 라이브러리를 익히고 사용하라
- 표준 라이브러리를 사용하면,
  - 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.
    - ex. `Random` -> `ThreadLocalRandom` or `SplittableRandom`
  - 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다. 애플리케이션 기능 개발에 집중 가능하다.
  - 따로 노력하지 않아도 성능이 지속해서 개선된다는 점이다.
  - 기능이 점점 많아진다.
  - 여러분이 작성한 코드가 많은 사람에게 낯익은 코드가 된다. 자연스럽게 다른 개발자들이 더 읽기 좋고, 유지보수하기 좋고, 재활용하기 쉬운 코드가 된다.
- 표준 라이브러리의 기능을 사용하는 것이 좋아 보이지만, 실상은 많은 프로그래머가 직접 구현한다. 아마 라이브러리에 그런 기능이 있는지 모르기 때문일 것이다.
  - 메이저 릴리스마다 주목할 만한 수많은 기능이 라이브러리에 추가된다.
  - 자바 프로그래머라면 적어보 `java.lang`, `java.util`, `java.io`와 그 하위 패키지들에는 익숙해져야 한다.
  - 컬렉션 프레임워크와 스트림 라이브러리, `java.util.concurrent` 등을 알면 큰 도움이 된다.
- 우선 라이브러리를 사용하려 해보자.
  - 원하는 기능이 아니라 판단되면 대안을 사용하자.
  - 표준 라이브러리에서 원하는 기능을 찾지 못하면, 그다음 선택지는 고품질의 서드파티 라이브러리가 될 것이다.
  - 그것 또한 찾지 못했다면, 직접 구현이 답이다.
  - **바퀴를 다시 발명하지 말자.**

#
### 아이템 60. 정확한 답이 필요하다면 float와 double은 피하라
- `float`와 `double` 타입은 특히 금융 관련 계산과는 맞지 않는다. 공학/과학 계산용으로 설계되었다.
  - 금융 계산에는 `BigDemical`, `int` 혹은 `long`을 사용해야 한다.
  - `BigDemical`은 문자열을 받는 생성자가 있어, 계산시 부정확한 값이 사용되는 것을 막을 수 있다.
  - 다만, `BigDemical`은 기본 타입보다 쓰기가 훨씬 불편하고, 훨씬 느린 단점이 있다.
  - 그 대안으로 `int`, `long`을 사용할 수 있는데, 이 때는 다룰 수 있는 값의 크기가 제한되고, 소수점을 직접 관리해야 한다.
- 정리
  - ~9자리 십진수 -> `int`
  - ~18자리 십진수 -> `long`
  - ~그 이상 -> `BigDemical`

#
### 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라
- 오토박싱과 오토언박싱 덕분에 기본 타입(int, double, boolean 등)과 참조 타입(String, List 등)을 크게 구분하고 사용할 수는 있지만, 그렇다고 차이가 사라지는 것은 아니다.
  - 둘 사이에는 분명한 차이가 있으니 어떤 타입을 사용하는지는 상당히 중요하다. 주의해야 한다.
- 기본 타입과 박싱된 기본 타입의 차이점 3가지
  - 첫 번째, 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖는다. 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.
  - 두 번째, 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null을 가질 수 있다.
  - 세 번째, 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.
- 박싱된 타입에 `==` 연산자를 사용하면 오류가 일어난다.
  - 실무에서 이와 같이 기본 타입을 다루는 비교자가 필요하다면 `Comparator.naturalOrder()`를 사용하자.
  - 비교자를 직접 만들면 비교자 생성 메서드나 기본 타입을 받는 정적 compare 메서드를 사용해야 한다.
- 거의 예외 없이 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.
  - 그리고 null 참조를 언박싱하면 `NullPointerException`이 발생한다.
- 박싱된 기본타입을 언제 써야 하는가?
  - 첫 번째, 컬렉션의 원소, 키, 값으로 쓴다. 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야만 한다. 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 한다. 자바가 타입 매개변수로 기본 타입을 지원하지 않기 때문이다.
  - 두 번째, 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.
- 정리
  - 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 기본 타입을 사용하자. 기본 타입은 빠르고 간단하다.
  - 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.
  - 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, 언박싱 과정에서 `NullPointerException`을 던질 수 있다.
  - 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다.

#
### 아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라
- 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
  - I/O에서 받는 데이터가 수치형이면 int, float, BigInteger 등 적당한 수치 타입으로 변환해야 한다.
  - '예/아니오'는 적절한 열거 타입이나 boolean으로 변환해야 한다.
  - 기본 타입이든 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고, 없다면 새로 만들어라.
- 문자열은 열거 타입을 대신하기에 적합하지 않다. Enum 써라. 훨씬 낫다.
- 문자열은 혼합 타입을 대신하기에 적합하지 않다.
  - 문자열에 특수 문자로 데이터를 구분짓는 경우, 파싱하는데 느리고, 귀찮고, 오류 가능성이 커진다.
  - 적절한 equals, toString, compareTo 메서드를 제공할 수 없으며, String이 제공하는 기본 기능에만 의존해야 한다.
  - 차라리 전용 클래스를 만드는 게 낫다. 이런 클래스는 보통 private 정적 멤버 클래스로 선언한다.
- 문자열은 권한을 표현하기에 적합하지 않다.

#
### 아이템 63. 문자열 연결은 느리니 주의하라
- 문자열 연결 연산자 `+`는 여러 문자열을 하나로 합쳐주는 편리한 수단이지만, 문자열 n개를 잇는 시간은 n^2에 비례할만큼 연산이 느리다.
  - 문자열은 불변이기 때문에 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하기 때문이다.
- 성능을 포기하고 싶지 않다면 `String` 대신 `StringBuilder`를 사용하자.
- 문자 배열을 사용하거나, 문자열을 연결하지 않고 하나씩 처리하는 방법도 있다.

#
### 아이템 64. 객체는 인터페이스를 사용해 참조하라
- 적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.
  - 객체의 실제 클래스를 사용해야 할 상황은 '오직' 생성자로 생성할 때뿐이다.
  - 인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.
  - 나중에 구현 클래스를 교체하고자 한다면 그저 새 클래스의 생성자(혹은 다른 정적 팩터리)를 호출해주기만 하면 된다.
- 주의할 점. 원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하며, 주변 코드가 이 기능에 기대어 동작한다면 새로운 클래스도 반드시 같은 기능을 제공해야 한다.
  - 구현 타입을 바꾸려는 이유는 보통 원래 것보다 성능이 좋거나 멋진 신기능을 제공하기 때문일 것이다.
- 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다.
  - 1) String, BigInteger 같은 값 클래스. 값 클래스는 매개변수, 변수, 필드, 반환 타입으로 사용해도 무방하다.
  - 2) 클래스 기반으로 작성된 프레임워크가 제공하는 객체들. 다만 이런 경우라도 특정 구현 클래스보다는 기반 클래스(보통 추상 클래스다.)를 참조하는 게 좋다.
  - 3) 인터페이스에는 없는 특별한 메서드를 제공하는 클래스. 특별한 메서드를 꼭 사용해야 하는 경우를 최소화해야 하며, 절대 남발해서는 안 된다.
- 적합한 인터페이스가 없다면 클래스 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(= 상위의) 클래스를 타입으로 사용하자.
