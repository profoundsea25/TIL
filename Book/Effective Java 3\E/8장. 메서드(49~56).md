# 8. 메서드
### 아이템 49. 매개변수가 유효한지 검사하라
- 매서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. 이런 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다.
  - "오류는 가능한 한 빨리 (발생한 곳에서) 잡아야 한다"
  - 오류를 발생한 즉시 잡지 못하면 해당 오류를 감자하기 어려워지고, 감지하더라도 오류의 발생 지점을 찾기 어려워진다.
- 매개변수 검사를 제대로 하지 못하면 생기는 문제
  - 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
  - 더 나쁜 상황은 메서드가 잘 수행되지만 잘못된 결과를 반환할 때다.
  - 한층 더 나쁜 상황은 메서드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어놓아서 미래의 알 수 없는 시점에 이 메서드와는 관련 없는 오류를 낼 때다.
- `public`과 `protected` 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다. 
  - 보통은 `IllegalArgumentException`, `IndexOutOfBoundsException`, `NullPointerException` 중 하나.
  - 매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.
  - `Objects.requireNonNull` 메서드는 유연하고 사용하기도 편하니, 더 이상 null 검사를 수동으로 하지 않아도 된다.
- 공개되지 않은 메서드라면 제작자인 여러분이 메서드가 호출되는 상황을 통제할 수 있다.
  - 다시 말해 `public`이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증할 수 있다.
- 메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경 써서 검사해야 한다.
  - 예외 - 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때, 혹은 계산 과정에서 암묵적으로 검사가 수행될 때다.

#
### 아이템 50. 적시에 방어적 복사본을 만들라
- 자바는 안전한 언어다. 메모리 충돌이 없으며, 자바로 작성한 클래스는 그 불변식이 지켜진다.
  - 그러나 다른 클래스로부터의 침범을 아무런 노력 없이 다 막을 수 있는 것은 아니다. 
  - 그러니 클라이언트가 여러분의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.
- 인스턴스의 내부를 보호하려면 생성자에서 받은 가변 매개변수를 각각을 방어적으로 복사(defensive copy)해야 한다.
  - 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사하라.
  - 멀티스레딩 환경이라면 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다.
  - 매개변수가 제 3자에 의해 확잘될 수 있는 타입이라면 방어적 복사본을 만들 때 `clone`을 사용해서는 안된다.
- 접근자 메서드가 내부의 가변 정보를 직접 드러내지 않기 위해서는, 접근자가 가변 필드의 방어적 복사본을 반환하면 된다.
- 메서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지를 생각해야 한다.
  - 변경될 수 있는 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작할지를 따져보라. 확신할 수 없다면 복사본을 만들어 저장해야 한다.
- 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
- 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하도록 하자.

#
### 아이템 51. 메서드 시그니처를 신중히 설계하라
- 메서드 이름은 신중히 짓자. 항상 표준 명명 규칙을 따라야 한다.
  - 이해할 수 있고, 같은 패키지에 속한 다른 이름들과 일관되게 짓는 게 최우선 목표다.
- 편의 메서드를 너무 많이 만들지 말자. 확신이 서지 않으면 만들지 말자.
- 매개변수 목록은 짧게 유지하자. 4개 이하가 좋다.
  - 같은 타입의 매개변수 여러 개가 연달아 나오는 경우가 특히 해롭다.
  - 과하게 긴 매개변수 목록을 짧게 줄이는 기술 3가지
    - 1. 여러 메서드로 쪼갠다. 쪼개진 메서드 각가은 원래 매개변수 목록의 부분집합을 받는다.
    - 2. 도우미 클래스를 만든다. 일반적으로 정적 멤버 클래스로 둔다. 특히 잇따른 매개변수 몇 개를 독립된 하나의 개념으로 볼 수 있을 때 추천하는 기법이다.
    - 3. 객체 생성에 사용한 빌더 패턴을 메서드 호출에 응용한다.
- 매개변수 타입으로는 클래스보다는 인터페이스가 더 낫다.
- boolean 보다는 원소 2개짜리 열거 타입이 낫다.

#
### 아이템 52. 다중정의는 신중히 사용하라
- 다중정의(overloading)가 된 메서드들 중에서 어느 메서드를 호출할지가 컴파일타임에 정해진다.
- 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택된다.
- 따라서 다중정의가 혼동을 일으키는 상황을 피해야 한다.
- 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.
  - 가변인수(varargs)를 사용하는 메서드라면 다중정의를 아예 하지 말아야 한다.
  - 다중정의하는 대신 메서드 이름을 다르게 지어주는 길도 항상 열려 있으니 말이다.
- 생성자는 이름을 다르게 지을 수 없으니 두 번째 생성자부터는 무조건 다중정의가 된다. 하지만 정적 팩터리라는 대안을 활용할 수 있는 경우가 많다.
- 다중정의된 메서드(혹은 생성자)들이 함수형 인터페이스를 인수로 받을 때, 비록 서로 다른 함수형 인터페이스라도 인수 위치가 같으면 혼란이 생긴다는 것이다.
  - 따라서 메서드를 다중정의할 때, 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안 된다.
