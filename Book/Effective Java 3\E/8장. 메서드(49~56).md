# 8. 메서드
### 아이템 49. 매개변수가 유효한지 검사하라
- 매서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. 이런 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다.
  - "오류는 가능한 한 빨리 (발생한 곳에서) 잡아야 한다"
  - 오류를 발생한 즉시 잡지 못하면 해당 오류를 감자하기 어려워지고, 감지하더라도 오류의 발생 지점을 찾기 어려워진다.
- 매개변수 검사를 제대로 하지 못하면 생기는 문제
  - 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
  - 더 나쁜 상황은 메서드가 잘 수행되지만 잘못된 결과를 반환할 때다.
  - 한층 더 나쁜 상황은 메서드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어놓아서 미래의 알 수 없는 시점에 이 메서드와는 관련 없는 오류를 낼 때다.
- `public`과 `protected` 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다. 
  - 보통은 `IllegalArgumentException`, `IndexOutOfBoundsException`, `NullPointerException` 중 하나.
  - 매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.
  - `Objects.requireNonNull` 메서드는 유연하고 사용하기도 편하니, 더 이상 null 검사를 수동으로 하지 않아도 된다.
- 공개되지 않은 메서드라면 제작자인 여러분이 메서드가 호출되는 상황을 통제할 수 있다.
  - 다시 말해 `public`이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증할 수 있다.
- 메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경 써서 검사해야 한다.
  - 예외 - 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때, 혹은 계산 과정에서 암묵적으로 검사가 수행될 때다.

#
### 아이템 50. 적시에 방어적 복사본을 만들라
- 자바는 안전한 언어다. 메모리 충돌이 없으며, 자바로 작성한 클래스는 그 불변식이 지켜진다.
  - 그러나 다른 클래스로부터의 침범을 아무런 노력 없이 다 막을 수 있는 것은 아니다. 
  - 그러니 클라이언트가 여러분의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.
- 인스턴스의 내부를 보호하려면 생성자에서 받은 가변 매개변수를 각각을 방어적으로 복사(defensive copy)해야 한다.
  - 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사하라.
  - 멀티스레딩 환경이라면 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다.
  - 매개변수가 제 3자에 의해 확잘될 수 있는 타입이라면 방어적 복사본을 만들 때 `clone`을 사용해서는 안된다.
- 접근자 메서드가 내부의 가변 정보를 직접 드러내지 않기 위해서는, 접근자가 가변 필드의 방어적 복사본을 반환하면 된다.
- 메서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지를 생각해야 한다.
  - 변경될 수 있는 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작할지를 따져보라. 확신할 수 없다면 복사본을 만들어 저장해야 한다.
- 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
- 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하도록 하자.

#
### 아이템 51. 메서드 시그니처를 신중히 설계하라
- 메서드 이름은 신중히 짓자. 항상 표준 명명 규칙을 따라야 한다.
  - 이해할 수 있고, 같은 패키지에 속한 다른 이름들과 일관되게 짓는 게 최우선 목표다.
- 편의 메서드를 너무 많이 만들지 말자. 확신이 서지 않으면 만들지 말자.
- 매개변수 목록은 짧게 유지하자. 4개 이하가 좋다.
  - 같은 타입의 매개변수 여러 개가 연달아 나오는 경우가 특히 해롭다.
  - 과하게 긴 매개변수 목록을 짧게 줄이는 기술 3가지
    - 1. 여러 메서드로 쪼갠다. 쪼개진 메서드 각각은 원래 매개변수 목록의 부분집합을 받는다.
    - 2. 도우미 클래스를 만든다. 일반적으로 정적 멤버 클래스로 둔다. 특히 잇따른 매개변수 몇 개를 독립된 하나의 개념으로 볼 수 있을 때 추천하는 기법이다.
    - 3. 객체 생성에 사용한 빌더 패턴을 메서드 호출에 응용한다.
- 매개변수 타입으로는 클래스보다는 인터페이스가 더 낫다.
- boolean 보다는 원소 2개짜리 열거 타입이 낫다.

#
### 아이템 52. 다중정의는 신중히 사용하라
- 다중정의(overloading)가 된 메서드들 중에서 어느 메서드를 호출할지가 컴파일타임에 정해진다.
- 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택된다.
- 따라서 다중정의가 혼동을 일으키는 상황을 피해야 한다.
- 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.
  - 가변인수(varargs)를 사용하는 메서드라면 다중정의를 아예 하지 말아야 한다.
  - 다중정의하는 대신 메서드 이름을 다르게 지어주는 길도 항상 열려 있으니 말이다.
- 생성자는 이름을 다르게 지을 수 없으니 두 번째 생성자부터는 무조건 다중정의가 된다. 하지만 정적 팩터리라는 대안을 활용할 수 있는 경우가 많다.
- 다중정의된 메서드(혹은 생성자)들이 함수형 인터페이스를 인수로 받을 때, 비록 서로 다른 함수형 인터페이스라도 인수 위치가 같으면 혼란이 생긴다는 것이다.
  - 따라서 메서드를 다중정의할 때, 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안 된다.

#
### 아이템 53. 가변인수는 신중히 사용하라
- 가변인수(varargs) 메서드는 명시한 타입의 인수를 0개 이상 받을 수 있다.
  - 이를 호출하면, 가장 먼저 인수의 개수와 길이가 같은 배열을 만들고 인수들을 이 배열에 저장하여 가변인수 메서드에 건네준다.
  - 인수를 0개 받는 것을 허용하고 싶지 않다면, 매개변수를 2개 받도록 하자. 평범한 매개변수를 첫 번째로, 가변인수를 두 번째로 받는 방법을 추천.
- 성능에 민감한 상황이라면 가변인수가 걸림돌이 될 수 있다.
  - 이 때에는 다중정의를 적절히 사용하자.
  - 만약 어떤 메서드를 호출할 때 95%가 매개변수 3개 이하라면, 매개변수 3개까지는 각각 다중정의하고, 4개 이상부터는 가변인수로 받는 것이다.

#
### 아이템 54. null이 아닌, 빈 컬렉션이나 배열을 반환하라
- null을 반환하는 것은 클라이언트 쪽에도, 서버 쪽에도 특별취급해줘야 해서 코드가 복잡해진다.
- 빈 컨테이너를 할당하는 데 비용이 드니 null을 반환하는 것이 낫다는 것은 두 가지 면에서 틀린 주장이다.
  - 첫 번쨰, 성능 분석 결과 이 할당이 성능 저하의 주범이라고 확인되지 않는 한, 이 정도의 성능 차이는 신경 쓸 수준이 못 된다.
  - 두 번째, 빈 컬렉션과 배열은 굳이 새로 할당하지 않고도 반환할 수 있다. 매번 똑같은 빈 '불변' 컬렉션을 반환하면 특히 성능에 영향이 적다. (`Collections.emptyList`)
- 배열을 쓸 때도 마찬가지다. null 반환 대신에, 길이가 0인 배열을 반환하자.

#
### 아이템 55. 옵셔널 반환은 신중히 하라
- 자바 8 이전 메서드가 특정 조건에서 값을 반환할 수 없을 때
  - 예외를 던진다.
  - null을 반환한다. (반환 타입이 객체 참조일 경우)
- 문제점
  - 예외는 진짜 예외적인 상황에서만 사용해야 하며, 예외를 생성할 때 스택 추적 전체를 캡쳐하므로 비용도 만만치 않다.
  - null을 반환하면, 그 메서드를 호출할 때는 별도의 null 처리 코드를 추가해야 한다. 근본 원인이 되는 곳에서부터 멀리 떨어진 곳에서 `NullPointerException`이 발생할 수 있다.
- `Optional<T>`
  - null이 아닌 T타입 참조를 하나 담거나, 혹은 아무것도 담지 않을 수 있다.
  - 아무것도 담지 않은 옵셔널은 '비었다'고 하며, 어떤 값을 담은 옵셔널은 '비지 않았다'고 한다.
  - 옵셔널은 원소를 최대 1개 가질 수 있는 '불변' 컬렉션이다.
  - 옵셔널을 반환하는 메서드는 예외를 던지는 메서드보다 유연하고 사용하기 쉬우며, null을 반환하는 메서드보다 오류 가능성이 적다.
  - 옵셔널을 반환하는 메서드에서는 절대 null을 반환하지 말자.
- 옵셔널 반환을 선택해야 하는 기준
  - 옵셔널은 검사 예외와 취지가 비슷하다.
  - 반환값이 없을 수도 있음을 API 사용자에게 명확히 알려준다.
  - 비검사 예외 혹은 null을 반환했을 때, API 사용자가 그 사실을 인지하지 못하면 오류 발생 가능성이 매우 높다.
  - 하지만 검사 예외를 던지면 클라이언트에서는 반드시 이에 대처하는 코드를 작성해넣어야 한다.
- 메서드가 옵셔널을 반환한다면 클라이언트는 값을 받지 못했을 때 취할 행동을 선택해야 한다.
  - 기본값을 반환한다. (`orElse()`)
  - 원하는 예외를 발생시킨다. ('orElseThrow()')
  - 옵셔널에 항상 값이 채워져 있다고 확신한다면 그냥 곧바로 값을 꺼내 사용하는 선택지도 있다. (`get()`) 다만 잘못 판단했을 경우 `NoSuchElementException`이 발생한다.
  - 값이 처음 필요할 때 Supplier\<T>를 사용해 생성하므로 초기 설정 비용을 낮출 수 있다. (`orElseGet()`)
- 유용한 메서드들
  - `ifPresent()` 
    - 안전 밸브 역할의 메서드. 옵셔널이 채워져 있으면 true, 비어 있으면 false
    - 다만 다른 메서드들로 충분히 대체할 수 있으며, 더 짧고 명확하고 용법에 맞는 코드를 만들 여지가 있다.
  - `map()`, `flatMap()`, `filter()`, `stream()`
- 옵셔널이 반드시 득이 되는 것은 아니다.
  - 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안 된다.
- 옵셔널을 사용하는 기본 규칙
  - 결과가 없을 수 있으며, 클라이언트가 이 상황을 특별하게 처리해야 한다면 Optional\<T>를 반환한다.
  - Optional도 엄연히 새로 할당하고 초기화해야 하는 객체이므로, 성능이 중요한 상황에서는 옵셔널이 맞지 않을 수 있다. (null 반환이 더 나을 수 있다.)
  - 박싱된 기본 타입을 담은 옵셔널을 반환하는 일은 없도록 하자. (`OptionalInt`, `OptionalLong`, `OptionalDouble` 등을 활용, Boolean, Byte, Character, Short, Float은 예외)
  - 옵셔널을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는 게 적절한 상황은 거의 없다.

#
### 아이템 56 공개된 API 요소에는 항상 문서화 주석을 작성하라
- 여러분의 API를 올바른 문서화하려면 공개된 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야 한다.
- 메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다.
  - 상속용으로 설계된 클래스의 메서드가 아니라면 how가 아닌 what을 기술해야 한다.
  - 해당 메서드의 전제조건, 사후조건, 부작용을 모두 나열해야 한다.
  - 제네릭 타입이나 제네릭 메서드를 문서화할 때는 모든 타입 매개변수에 주석을 달아야 한다.
- 열거 타입을 문서화할 때는 상수들에도 주석을 달아야 한다.
- 애너테이션 타입을 문서화할 때는 멤버들에도 모든 주석을 달아야 한다.
- 클래스 혹은 정적 메서드가 스레드 안전하든 그렇지 않든, 스레드 안전 수준을 반드시 API 설명에 포함해야 한다.
- 직렬화할 수 있는 클래스라면 직렬화 형태도 API 설명에 기술해야 한다.
