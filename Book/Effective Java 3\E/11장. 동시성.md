# 11장. 동시성
### 아이템 78. 공유 중인 가변 데이터는 동기화해 사용하라
- 동기화의 효과 2가지
  - 배타적 수행
  - 스레드 간의 통신
- `synchronized`
  - 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장
  - 한 객체가 일관된 상태를 가지고 생성되고, 이 객체에 접근하는 메서드는 그 객체에 락을 건다. 락을 건 메서드는 그 객체의 상태를 확인하고 필요하면 수정한다.
  - 즉, 객체를 하나의 일관된 상태에서 다른 일관된 상태로 변화시킨다.
  - 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.
  - 동기화는 일관성이 깨진 상태를 볼 수 없게하는 것은 물론, 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다.
- 자바 언어 명세는 스레드가 필드를 읽을 때 항상 '수정이 완전히 반영된' 값을 얻는다고 보장하지만, 한 스레드가 저장한 값이 다른 스레드에게 '보이는가'는 보장하지 않는다.
  - 동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.
- 쓰기와 읽기 모두가 동기화되지 않으면 동작을 보장하지 않는다. 반드시 두 곳에서 모두 `synchronized`를 명시해야 한다.
  - 안전 실패(safety failure) : 프로그램이 잘못된 결과를 계산해내는 오류 
- 참고: `volatile`
  - 배타적 수행과는 상관없지만 항상 가장 최근에 기록된 값을 읽게 됨을 보장함. (스레드 통신)
  - 읽기/쓰기 연산이 하나의 접근이 아니라면, volatile은 동기화 목적으로 사용하지 말 것.
- `java.util.concurrent.atomic`의 클래스들 (`AtomicLong`)
  - 이 패키지는 락 없이도 스레드 안전한 프로그래밍을 지원
  - 성능도 동기화 버전보다 우수
- 문제를 피하는 가장 좋은 방법은 애초에 가변 데이터를 공유하지 않는 것.
  - 즉, 가변 데이터는 단일 스레드에서만 사용할 것.
  - 한 스레드가 데이터를 다 수정한 후 다른 스레드에 공유할 때는 해당 객체에서 공유하는 부분만 동기화해도 된다. 
    - 이러한 객체를 사실상 불변(effectively immutable)이라 함.
    - 이런 객체를 건내는 행위를 안전 발행(safe publication)이라 함.
- 안전 발행의 방법들
  - 클래스 초기화 과정에서 객체를 정적 필드, volatile 필드, final 필드, 혹은 보통의 락을 통해 접근하는 필드에 저장
  - 동시성 컬렉션에 저장

#
### 아이템 79. 과도한 동기화는 피하라
- 과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지언느 예측할 수 없는 동작을 낳기도 한다.
- 응답 불과와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.
  - 동기화된 영역 안에서는 재정의할 수 있는 메서드는 호출하면 안 되며,
  - 클라이언트가 넘겨준 함수 객체를 호출해서도 안 된다.
  - 외부 메서드가 하는 일에 따라 동기화도니 영역은 예외를 일으키거나, 교착상태에 빠지거나, 데이터를 훼손할 수 있다.
- `CopyOnWriteArrayList`
  - 내부를 변경하는 작업은 항상 깨끗한 복사본을 만들어 수행한다.
  - 내부 배열은 절대 수정되지 않는다.
  - 수정할 일은 드물고 순회만 빈번히 일어나는 관찰자 리스트 용도로는 최적이다.
- 기본 규칙은 동기화 영역에서는 가능한 한 일을 적게하는 것이다.
  - 오래 걸리는 작업이라면 동기화 영역 바깥으로 옮기는 방법을 찾아보자.
- 가변 클래스를 작성하려거든 둘 중 하나를 따르자.
  - 1. 동기화를 전혀 하지 않고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자.
  - 2. 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.
    - 단, 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 선택
  - 선택하기 어렵다면 동기화하지 말고, 대시 문서에 "스레드 안전하지 않다"고 명기하자.
- 클래스 내부에서 동기화하기로 했을 때, 동시성을 높이는 방법
  - 락 분할
  - 락 스트라이핑
  - 비차단 동시성 제어
- 여러 스레드가 호출할 가능성이 있는 메서드가 정적 필드를 수정한다면 그 필드를 사용하기 전에 반드시 동기화해야 한다.
  - 만약 클라이언트가 여러 스레드로 복제돼 구동되는 상황이라면 다른 클라이언트에서 이 메서드를 호출하는 걸 막을 수 없으니 외부에서 동기화할 방법이 없다.

#
### 아이템 80. 스레드보다는 실행자, 태스크, 스트림을 애용하자
- `java.util.concurrent`의 등장
- Executor Framework
  - 작업 큐 생성 `ExecutorService exec = Executors.newSingleThreadExcutor();`
  - 실행할 태스크(작업) 넘기기 `exec.execute(runnable);`
  - 실행자 종료 (종료 실패하면 VM이 종료되지 않음) `exec.shutdown();`
  - 특정 태스트가 완료되기를 기다린다. `exec.get()`
  - 태스크 모음 중 아무것 하나(`invokeAny` 메서드) 혹은 모든 태스크(`invokeAll` 메서드)가 완료되기를 기다린다.
  - 실행자 서비스가 종료하기를 기다린다. (`awaitTermination` 메서드)
  - 완료된 태스크들의 결과를 차례로 받는다. (`ExecutorCompletionService` 클래스)
  - 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다. (`ScheduledThreadPoolExecutor` 클래스)
- 하나의 큐를 둘 이상의 스레드가 처리하게 하고 싶다면 간단히 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스(스레드 풀)을 생성하면 된다.
  - 스레드 풀의 개수는 고정할 수도, 필요에 따라 늘어나거나 줄어들게 설정할 수도 있다.
  - 작은 서버라면 Executors.newCachedThreadPool 사용
    - 일반적인 용도
    - 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임돼 실행
    - 가용한 스레드가 없다면 새로 하나 생성
  - 무서운 프로덕션 서버에는 `Executors.newFixedThreadPool`을 선택하거나 완전히 통제할 수 있는 `ThreadPoolExecutor`를 직접 사용
  - 작업 큐를 손수 만드는 일, 스레드를 직접 다루는 일은 삼가도록 하자.
- 태스크 = 작업 단위를 나타내는 핵심 추상 개념
  - `Runnable` -> void
  - `Callable` -> 값을 반환하고, 임의의 예외 던지기 가능
  - 태스크 수행을 실행자 서비스에 맡기면 웒나느 태스크 수행 정책을 선택할 수 있고, 언제든 변경 가능하다.
- `ForkJoinTask`
  - 자바 7부터 지원.
  - `ForkJoinTask`는 작은 하위 태스크로 나뉠 수 있다.
  - `ForkJoinPool`을 구성하는 스레드들이 이 태스크들을 처리한다.
  - 일을 먼저 끝낸 스레드는 다른 스레드의 남은 태스크를 가져와 대신 처리할 수도 있다.
  - 이렇게 하여 CPU를 최대한 활용하면서 높은 처리량과 낮은 지연시간을 달성
