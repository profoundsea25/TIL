> 김영한님의 [스프링 핵심 원리 - 고급편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8) 강의 내용 정리입니다.

# 2. 쓰레드 로컬
### 동시성 문제
- 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제
- 여러 쓰레드가 같은 인스턴스의 필드에 접근해야 하지 때문에 트래픽이 적은 상황에서는 확률상 잘 나타나지 않고, 트래픽이 점점 많아질수록 자주 발생
- 특히 스프링 빈처럼 싱글톤 객체의 필드를 변경하며 사용할 때 이러한 동시성 문제를 조심해야 함.
- 동시성 문제는 지역 변수에서는 발생하지 않음. 지역 변수는 쓰레드마다 각각 다른 메모리 영역이 할당됨.
- 동시성 문제가 발생하는 곳은 인스턴스의 필드(주로 싱글톤에서 자주 발생), 또는 static 같은 공용 필드에 접근할 때 발생
- 동시성 문제는 값을 읽기만 하면 발생하지 않음. 어디선가 값을 변경하기 때문에 발생
- 동시성 문제를 해결하기 위해 사용하는 것이 바로 쓰레드 로컬

### ThreadLocal
- 쓰레드 로컬이란 해당 쓰레드만 접근할 수 있는 특별한 저장소
- 해당 쓰레드가 쓰레드 로컬을 모두 사용하고 나면 `ThreadLocal.remove()`를 호출해서 쓰레드 로컬에 저장된 값을 제거해주어야 한다.
- 값을 저장할 때는 `.set()`, 값을 조회할 때는 `.get()`
- 쓰레드 로컬의 값을 사용 후 제거하지 않고 그냥 두면 WAS(톰캣)처럼 쓰레드 풀을 사용하는 경우에 심각한 문제가 발생할 수 있다.

# 3. 템플릿 메서드 패턴과 콜백 패턴
### 템플릿 메서드 패턴
- 이름 그대로 템플릿을 사용하는 방식
- 템플릿은 기준이 되는 거대한 틀
- 템플릿이라는 틀에 변하지 않는 부분을 몰아둔다. 그리고 일부 변하는 부분을 별도로 호출해서 해결한다.
- 부모 클래스에 변하지 않는 템플릿 코드를 두고, 변하는 부분은 자식 클래스에 두고 상속과 오버라이딩을 사용해서 처리한다.
#### 정의 BY GOF
- 템플릿 메서드 디자인 패턴의 목적은 다음과 같습니다.
- "작업에서 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스로 연기합니다. 템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의할 수 있습니다."
- 부모 클래스에 알고리즘의 골격인 템플릿을 정의하고, 일부 변경되는 로직은 자식 클래스에 정의하는 것
- 이렇게 하면 자식 클래스가 알고리즘의 전체 구조를 변경하지 않고, 특정 부분만 재정의할 수 있음.
- 결국 상속과 오버라이딩을 통한 다형성으로 문제를 해결

#### 단점
- 템플릿 메서드 패턴은 상속을 사용. 따라서 상속에서 오는 단점들을 그대로 안고간다.
- 특히 자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합되는 문제가 있음. (의존관계에 대한 문제)
- 강하게 의존한다 = 자식 클래스의 코드에 부모 클래스의 코드가 명확하게 적혀 있다는 뜻
- 자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않음. 그러나 부모 클래스를 알아야 함.
- 이것은 좋은 설계가 아님. 이런 잘못된 의존관계 때문에 부모 클래스를 수정하면, 자식 클래스에도 영향을 줄 수 있음.
- 추가로 상속 구조 때문에 별도의 클래스나 익명 내부 클래스를 만들어야 하는 부분도 복잡함.

### 전략 패턴 (Strategy Pattern)
- 템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴
- 전략 패턴은 변하지 않는 부분을 `Context`라는 곳에 두고, 변하는 부분을 `Strategy`라는 인터페이스를 만들고 해당 인터페이스를 구현하도록 해서 문제를 해결한다.
- 상속이 아니라 위임으로 문제를 해결하는 것이다.
- 전략 패턴에서 `Context`는 변하지 않는 템플릿 역할을 하고, `Strategy`는 변하는 알고리즘 역할을 한다.
- "알고리즘 제품군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만들자. 전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다." by GOF
- 컨텍스트는 크게 변하지 않지만, 그 속에서 strategy를 통해 일부 전략이 변경된다.
- 전략 패턴의 핵심은 `Context`는 `Strategy` 인터페이스에만 의존한다는 점이다. 덕분에 `Strategy`의 구현체를 변경하거나 새로 만들어도 `Context` 코드에는 영향을 주지 않는다.
- 스프링의 의존 관계 주입에서 사용하는 방식
- 변하지 않는 부분을 `Context`에 두고, 변하는 부분을 `Strategy`를 구현해서 만든다. 그리고 `Context`의 내부에 `Strategy`를 주입해서 사용한다.

#### 전략 패턴 실행 순서
1. `Context`에 원하는 `Strategy` 구현체를 주입한다.
2. 클라이언트는 `Context`를 실행한다.
3. `Context`는 `Context` 로직을 시작한다.
4. `Context` 로직 중간에 `Strategy`를 호출해서 주입받은 `Strategy` 로직을 실행한다.
5. `Context`는 나머지 로직을 실행한다.

#### 단점
- `Context`와 `Strategy`를 조립한 이후에는 전략을 변경하기가 번거롭다는 점
  - `Context`에 setter를 제공해서 `Strategy`를 넘겨 받아 변경하는 해결책 -> `Context`를 싱글톤으로 사용할 때 동시성 이슈 등 고려할 점이 많음.
  - 그래서 전략을 실시간으로 변경해야 하면 차라리 `Context`를 하나 더 생성하고 그곳에 다른 `Strategy`를 주입하는 것이 더 나은 선택일 수 있음.

#### 직접 파라미터 전달하기
- `Context`와 `Strategy`를 '선 조립, 후 실행' 하는 방식이 아니라 `Context`를 실행할 때마다 전략을 인수로 전달
- 클라이언트는 `Context`를 실행하는 시점에 원하는 `Strategy`를 전달할 수 있다. 따라서 이전 방식과 비교해서 원하는 전략을 더운 유연하게 변경할 수 있다.

#### 직접 파라미터 전달하기 전략 패턴 실행순서
1. 클라이언트는 `Context`를 실행하면서 인수로 `Strategy`를 전달한다.
2. `Context`는 로직을 실행한다.
3. `Context`는 파라미터로 넘어온 `Strategy`의 로직을 실행한다.
4. `Context`의 로직이 종료된다.

#### 정리
- V1 : `Context`필드에 `Strategy`를 저장하는 방식의 전략 패턴
  - 선 조립, 후 실행 방법에 적합
  - `Context`를 실행하는 시점에는 이미 조립이 끝났기 때문에 전략을 신경쓰지 않고 단순히 실행만 하면 됨
- V2 : `Context`에 `Strategy`를 전달받는 방식의 전략 패턴
  - 실행할 때마다 전략을 유연하게 변경할 수 있음
  - 단점 : 실행할 때마다 전략을 계속 지정해주어야 함
- 전략 패턴의 의도 : 변하는 부분과 변하지 않는 부분을 분리하는 것
- 변하지 않는 부분을 템플릿이라고 하고, 그 템플릿 안에서 변하는 부분에 약간 다른 '코드 조각'을 넘겨서 실행하는 것이 목적.
- 따라서 이 때에는 V2가 더 적합

### 템플릿 콜백 패턴
- 위의 `ContextV2` 방식의 전략 패턴을 템플릿 콜백 패턴이라고 한다. `Context`가 템플릿 역할을, `Strategy`가 콜백으로 넘어온다고 볼 수 있다.
- 스프링에서 다양한 템플릿 콜백 패턴을 볼 수 있다.
#### 콜백 정의
- 콜백(callback) 혹은 콜애프터 함수(Call-after function)는 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말한다. 콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고, 아니면 나중에 실행할 수도 있다.

### 템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴의 한계
- 변하는 코드와 변하지 않는 코드를 분리했지만, 아무리 최적화를 해도 결국 관심사(로그 추적기 등)를 분리 위해서 원본 코드를 수정해야 한다.

# 4. 프록시 패턴과 데코레이터 패턴
### 프록시
- 클라이언트는 서버에 필요한 것을 요청하고, 서버는 클라이언트의 요청을 처리한다.
- 직접 호출 : 클라이언트가 서버를 직접 호출하고, 처리 결과를 직접 받는 것
- 프록시 : 클라이언트가 서버에 직접 요청하는 것이 아니라 어떤 대리자를 통해서 대신 간접적으로 서버에 요청할수도 있는데, 이 대리자를 Proxy라고 한다.
- 아무 객체나 프록시가 될 수는 없다.
- 객체에서 프록시가 되려면, 클라이언트는 서버에게 요청을 한 것인지, 프록시에게 요청을 한 것인지 조차 몰라야 한다.
- 즉, 서버와 프록시는 같은 인터페이스를 사용해야 한다. 그리고 클라이언트가 사용하는 서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 한다.
- 프록시 패턴의 핵심은 기존 코드를 전혀 변경하지 않고, 프록시를 도입해서 접근 제어 혹은 부가 기능 추가를 한다는 점이다. 그리고 클라이언트 코드의 변경 없이 자유롭게 프록시를 넣고 뺄 수 있다.

### 프록시의 주요 기능
- 접근 제어
  - 권한에 따른 접근 차단
  - 캐싱
  - 지연로딩
- 부가 기능 추가
  - 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행
  - 예) 요청 값이나, 응답 값을 중간에 변형
  - 예) 실행 시간을 측정해서 추가 로그를 남김

### GOF 디자인 패턴에서는
- 프록시 패턴과 데코레이터 패턴 모두 프록시를 사용하는 방법이지만, GOF 디자인 패턴에서는 이 둘을 의도(intent)에 따라서 프로시 패턴과 데코레이터 패턴으로 구분
- 프록시 패턴 : 접근 제어가 목적
- 데코레이터 패턴 : 새로운 기능 추가가 목적
- 둘 다 프록시를 사용하지만 의도가 다른 것이 핵심

### 의도(intent)
- 사실 프록시 패턴과 데코레이터 패턴은 그 모양이 거의 같고, 상황에 따라 정말 똑같을 때도 있다.
- 디자인 패턴에서 중요한 것은 해당 패턴의 겉모양이 아니라 그 패턴을 만든 의도가 더 중요하다. 따라서 의도에 따라 패턴을 구분한다.
- 프록시 패턴의 의도 : 다른 개체에 대한 접근을 제어하기 위해 대리자를 제공
- 데코레이터 패턴의 의도 : 객체에 추가 책임(기능)을 동적으로 추가하고, 기능 확장을 위한 유연한 대안 제공

### 참고 지식 - 자바 기본
- 자바 언어에서 다형성은 인터페이스나 클래스를 구분하지 않고 모두 적용된다. 해당 타입과 그 타입의 하위 타입은 모두 다형성의 대상이 된다.

### V1 인터페이스 기반 프록시
- 프록시를 인터페이스로 생성하고 프록시를 스프링 빈으로 등록한다. 실제 객체는 스프링 빈으로 등록하지 않는다. 즉, 실제 객체 대신에 프로시 객체가 주입된다.
- 실제 객체가 스프링 빈으로 등록되지 않는다고 해서 사라지는 것은 아니다. 프록시 객체가 실제 객체를 참조하기 때문에 프록시를 통해서 실제 객체를 호출할 수 있다.
- 실제 객체는 스프링 컨테이너와는 상관이 없다. 실제 객체는 프록시 객체를 통해서 참조될 뿐이다.
- 필요한 클래스마다 프록시 클래스를 각각 만들어 주어야 한다.

### V2 구체 클래스 기반 프록시
- 단점 : 자바 기본 문법에 의해 자식 클래스를 생성할 때는 항상 `super()`로 부모 클래스의 생성자를 호출해야 한다. 프록시는 부모 객체의 기능을 사용하지 않기 때문에 `super(null)`을 입력해도 된다. 인터페이스 기반 프록시는 이런 고민을 하지 않아도 된다.
-
### 인터페이스 기반 프록시와 클래스 기반 프록시
- 클래스 기반 프록시는 해당 클래스에만 적용할 수 있다. 인터페이스 기반 프록시는 인터페이스만 같으면 모든 곳에 적용할 수 있다.
- 클래스 기반 프록시는 상속을 사용하기 떄문에 몇가지 제약이 있다.
  - 부모 클래스의 생성자를 호출해야 한다.
  - 클래스에 final 키워드가 붙으면 상속이 불가능하다.
  - 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩할 수 없다.
- 인터페이스 기반의 프록시는 상속이라는 제약에서 자유롭기 때문에 더 좋다. 프로그래밍 관점에서도 인터페이스를 사용하는 것이 역할과 구현을 명확하게 나누기 때문에 더 좋다.
- 인터페이스 기반 프록시의 단점은 인터페이스가 필요하다는 그 자체이다. 인터페이스가 없으면 인터페이스 기반 프록시를 만들 수 없다.
- 인터페이스 기반 프록시는 캐스팅 관련해서 단점이 존재한다. (추후에 설명)
- 이론적으로는 모든 객체에 인터페이스를 도입해서 역할과 구현을 나누는 것이 좋다. 이렇게 하면 역할과 구현을 나누어서 구현체를 매우 편리하게 변경할 수 있따. 하지만 실제로는 구현을 거의 변경할 일이 없는 클래스도 많다. 인터페이스를 도입하는 것은 구현을 변경할 가능성이 있을 때 효과적인데, 구현을 변경할 가능성이 거의 없는 코드에 무작정 인터페이스를 사용하는 것은 번거롭고 그렇게 실용적이지 않다. 이런 곳에는 실용적인 관점에서 인터페이스를 사용하지 않고 구체 클래스를 바로 사용하는 것을 추천. - 즉, 인터페이스가 항상 필요하지는 않다.

### 너무 많은 프록시 클래스
- 프록시를 사용하면 기존 코드를 변경하지 않고, 부가 기능을 적용할 수 있었다.
- 그런데 문제는 프록시 클래스를 너무 많이 만들어야 한다는 점이다. 
- 프록시 클래스를 하나만 만들어서 모든 곳에 적용하는 방법이 없을까? -> 동적 프록시

# 5. 동적 프록시 기술
- 자바가 기본으로 제공하는 JDK 동적 프록시 기술이나 CGLIB 같은 프록시 생성 오픈소스 기술을 활용하면 프록시 객체를 동적으로 만들어낼 수 있다.
- 즉 프록시 클래스를 계속 만들지 않아도 된다. 프록시를 적용할 코드를 하나만 만들어두고 동적 프록시 기술을 사용해서 프록시 객체를 찍어내면 된다.
### 리플렉션
- 리플렉션 기술을 사용하면 클래스나 메서드의 메타정보를 동적으로 획득하고, 코드도 동적으로 호출/변경할 수 있다.
- 그러나 리플렉션 기술은 런타임에 동작하기 때문에, 컴파일 시점에 오류를 잡을 수 없다.
- 따라서 리플렉션은 일반적으로 사용하면 안된다. 리플렉션은 프레임워크 개발이나 또는 매우 일반적인 공통 처리가 필요할 때 부분적으로 주의해서 사용해야 한다.

### JDK 동적 프록시
- 동적 프록시 기술을 사용하면 개발자가 직접 프록시 클래스를 만들지 않아도 된다. 프록시 객체를 동적으로 런타임에 개발자 대신 만들어준다. 그리고 동적 프록시에 원하는 실행 로직을 지정할 수 있다.
- JDK 동적 프록시는 인터페이스를 기반으로 프록시를 동적으로 만들어준다. 따라서 인터페이스가 필수이다.

### CGLIB
- CGLIB : Code Generator Library
- CGLIB는 바이트코드를 조작해서 동적으로 생성하는 기술을 제공하는 라이브러리
- CGLIB를 사용하면 인터페이스가 없어도 구체 클래스만 가지고 동적 프록시를 만들어 낼 수 있다.
### CGLIB 제약
- 클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다.
- 부모 클래스의 생성자를 체크해야 한다. -> CGLIB는 자식 클래스를 동적으로 생성하기 때문에 기본 생성자가 필요하다.
- 클래스에 final 키워드가 붙으면 상속이 불가능하다. -> CGLIB에서는 예외가 발생한다.
- 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다. -> CGGLIB에서는 프록시 로직이 동작하지 않는다.

# 6. 스프링이 지원하는 프록시
### 프록시 팩토리
#### 인터페이스가 있는 경우에는 JDK 동적 프록시를 적용하고, 그렇지 않은 경우에는 CGLIB를 적용하려면 어떻게 해야할까?
- 스프링은 동적 프록시를 통합해서 편리하게 만들어주는 프록시 팩토리(Proxy Factory)라는 기능을 제공
- 프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시를, 구체 클래스만 있다면 CGLIB를 사용한다.
#### 두 기술을 함께 사용할 때 부가 기능을 적용하기 위해 JDK 동적 프록시가 제공하는 InvocationHandler와 CGLIB가 제공하는 MethodInterceptor를 각각 중복으로 따로 만들어야 할까?
- 스프링은 이 문제를 해결하기 위해 부가 기능을 적용할 때 `Advice`라는 새로운 개념을 도입했다. 개발자는 `Advice`만 만들면 된다.
- 결과적으로 `InvocationHandler`나 `MethodInterceptor`는 `Advice`를 호출하게 된다.
#### 특정 조건이 맞을 때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?
- 스프링은 `Pointcut`이라는 개념을 도입해서, 특정 조건에 맞을 때만 프록시 부가 기능이 적용되도록 한다.

### 프록시 팩토리의 기술 선택 방법
- 대상에 인터페이스가 있으면: JDK 동적 프록시, 인터페이스 기반 프록시
- 대상에 인터페이스가 없으면: CGLIB, 구체 클래스 기반 프록시
- `proxyTargetClass=true`: CGLIB, 구체 클래스 기반 프록시, 인터페이스 여부와 상관없음

###  프록시 팩토리 - 정리
- 프록시 팩토리의 서비스 추상화 덕분에 구체적인 CGLIB, JDK 동적 프록시 기술에 의존하지 않고, 매우 편리하게 동적 프록시를 생성할 수 있다.
- 프록시 부가 기능 로직도 특정 기술에 종속적이지 않게 `Advice`하나로 편리하게 사용할 수 있다. 이것은 프록시 팩토리가 내부에서 JDK 동적 프록시의 경우 `InvocationHandler`가, CGLIB의 경우 `MethodInterceptor`가 `Advice`를 호출하도록 기능을 개발해두었기 때문이다.
- 스프링 부트는 AOP를 적용할 때 기본적으로 `proxyTargetClass=true`로 설정해서 사용한다. 따라서 인터페이스가 있어도 항상 CGLIB를 사용해서 구체 클래스를 기반으로 프록시를 생성한다.

### 포인트컷, 어드바이스, 어드바이저
- 포인트컷(Pointcut): 어디에 부가 기능을 적용할지, 어디에 부가 기능을 적용하지 않을지 판단하는 필터링 로직. 주로 클래스와 메서드 이름으로 필터링한다. 어떤 포인트(Point)에 기능을 적용할지 하지 않을지 잘라서(cut) 구분
- 어드바이스(Advice): 프록시가 호출하는 부가 기능. (프록시 로직)
- 어드바이저(Advisor): 하나의 포인트컷과 하나의 어드바이스를 가지고 있는 것
#### 역할과 책임
- 포인트컷은 대상 여부를 확인하는 필터 역할만 담당
- 어드바이스는 깔끔하게 부가 기능 로직만 담당
- 둘을 합쳐 어드바이스

### 스프링이 제공하는 어드바이저
- 스프링은 AOP를 적용할 때, 최적화를 진행해서 프록시는 하나만 만들고, 하나의 프록시에 여러 어드바이저를 적용한다. AOP를 적용 수만큼 프록시가 생성되는 것이 아니다.
- 즉 target에 여러 AOP가 동시에 적용되어도, 스프링의 AOP는 target마다 하나의 프록시만 생성한다.

### 프록시 팩토리 - 문제
- 설정이 너무 많이 필요하다. 등록된 스프링 빈 개수만큼 동적 프록시 생성 코드를 만들어야 한다.
- 컴포넌트 스캔을 적용한 클래스는 프록시 적용이 불가능하다. 실제 객체를 스프링 컨테이너에 스프링 빈으로 자동 등록되기 떄문이다.

# 7. 빈 후처리기
### BeanPostProcessor
- 스프링이 빈 저장소에 등록할 목적으로 생성한 객체를 빈 저장소에 등록하기 직전에 조작할 때 사용
- 빈을 생성한 후에 무언가를 처리하는 용도로 사용
- 객체를 조작하거나, 완전히 다른 객체로 바꿔치기 하는 것도 가능
- 일반적으로 스프링 컨테이너가 등록하는, 특히 컴포넌트 스캔의 대상이 되는 빈들은 중간에 조작할 방법이 없는데, 빈 후처리기를 사용하면 개발자가 등록하는 모든 빈을 중간에 조작할 수 있음. 이는 빈 객체를 프록시로 교체하는 것도 가능하다는 의미.

### 빈 등록 과정
- 1. 생성 : 스프링 빈 대상이 되는 객체를 생성 (@Bean, 컴포넌트 스캔)
- 2. 전달 : 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달
- 3. 후 처리 작업 : 빈 후처리기는 전달된 스프링 빈 객체를 조작하거나 다른 객체로 바꿔치기 가능
- 4. 등록 : 빈 후처리기가 빈에 어떠한 처리를 한 후 반환한 것을 빈 저장소에 등록

### 참고 - @PostConstruct
- `@PostConstruct`는 스프링 빈 생성 이후 빈을 초기화하는 역할
- 해당 어노테이션이 붙은 초기화 메서드를 한번 호출하는 것 = 생성된 빈을 한번 조작하는 것
- 스프링의 `CommonAnnotationBeanPostProcessor`라는 빈 후처리기를 자동으로 등록하고 `@PostConstruct` 애노테이션이 붙은 메서드를 호출
- 스프링 스스로도 스프링 내부의 기능을 확장하기 위해 빈 후처리기를 사용

### 빈 후처리기 - 정리
- 빈 후처리기로 프록시를 생성하는 부분을 하나로 집중할 수 있다.
- 컴포넌트 스캔처럼 스프링이 직접 대상을 빈으로 등록하는 경우에도 프록시를 스프링 빈으로 등록할 수 있다.
- 덕분에 애플리케이션에 수 많은 스프링 빈이 추가되어도 프록시와 관련된 코드는 전혀 변경하지 않아도 된다.
- 참고) 스프링은 프록시를 생성하기 위한 빈 후처리기를 이미 만들어서 제공한다.

### 포인트컷의 역할 (in 어드바이저)
- 빈 후처리기에서 프록시 적용 대상 여부를 포인트컷을 활용하면 더 정밀하게 설정할 수 있다. (클래스, 메서드 단위의 필터 가능)
- 프록시 적용 대상 여부를 체크해서 꼭 필요한 곳에만 프록시를 적용한다. (빈 후처리기 - 자동 프록시 생성)
- 프록시의 어떤 메서드가 호출 되었을 때 어드바이스를 적용할 지 판단한다. (프록시 내부)

### 자동 프록시 생성기 - AutoProxyCreator
```java
implementation 'org.springframework.boot:spring-boot-starter-aop'
```
- 위의 라이브러리를 추가하면 스프링 부트 자동으로 AOP 관련 클래스를 스프링 빈에 등록한다.
- 이러한 설정으로 `AnnotationAwareAspectJAutoProxyCreator`라는 빈 후처리기가 스프링 빈에 자동으로 등록된다.
- 자동으로 프록시를 생성해주는 빈 후처리기이다.
- 스프링 빈으로 등록된 Advisor들을 자동으로 찾아서 프록시가 필요한 곳에 자동으로 프록시를 적용해준다.

### 자동 프록시 생성기의 작동 과정
- 1. 생성 : 스프링이 스프링 빈 대상이 되는 객체를 생성한다. (@Bean, 컴포넌트 스캔)
- 2. 전달 : 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
- 3. 모든 Advisor 빈 조회 : 자동 프록시 생성기 - 빈 후처리기는 스프링 컨테이너에서 모든 Advisor를 조회한다.
- 4. 프록시 적용 대상 체크 : 앞서 조회한 Advisor에 포함되어 있는 포인트컷을 사용해서 해당 객체가 프록시를 적용할 대상인지 아닌지 판단한다. 이때 객체의 클래스 정보는 물론이고, 해당 객체의 모든 메서드를 포인트컷에 하나하나 모두 매칭해본다. 그래서 조건이 하나라도 만족하면 프록시 적용 대상이 된다.
- 5. 프록시 생성 : 프록시 적용 대상이면 프록시를 생성하고 반환해서 프록시를 스프링 빈으로 등록한다. 만약 프록시 적용 대상이 아니라면 원본 객체를 반환해서 원본 객체를 스프링 빈으로 등록한다.
- 6. 빈 등록 : 반환된 객체는 스프링 빈으로 등록된다.

### 중요 : 포인트컷의 역할
- 프록시 적용 여부 판단 - 생성 단계
  - 자동 프록시 생성기는 포인트컷을 사용해서 해당 빈이 프록시를 생성할 필요가 있는지 없는지 체크한다.
  - 클래스 + 메서드 조건을 모두 비교한다. 이때 모든 메서드를 체크하는데, 포인트컷 조건에 하나하나 매칭해본다. 만약 조건에 맞는 것이 하나라도 있으면 프록시를 생성한다.
  - 조건에 맞는 것이 하나도 없으면 프록시를 생ㅅ어할 필요가 없으므로 프록시를 생성하지 않는다.
- 어드파이스 적용 여부 판단 - 사용 단계
  - 프록시가 호출되었을 때 부가 기능인 어드바이스를 적용할지 말지 포인트컷을 보고 판단한다.
- 프록시를 모든 곳에 생성하는 것은 비용 낭비이다. 꼭 필요한 곳에 최소한의 프록시를 적용해야 한다. 그래서 자동 프록시 생성기는 모든 스프링 빈에 프록시를 적용하는 것이 아니라 포인트컷으로 한번 필터링해서 어드바이스가 사용될 가능성이 있는 곳에만 프록시를 생성한다.

### 하나의 프록시, 여러 Advisor 적용
- 여러 포인트컷의 조건을 모두 만족하는 객체가 있다면 프록시 자동 생성기는 이 객체에 프록시를 하나만 생성한다.
- 프록시 팩토리가 생성하는 프록시는 내부에 여러 advisor를 포함할 수 있기 때문이다. 따라서 프록시를 여러 개 생성해서 비용을 낭비할 이유가 없다.
- 스프링 AOP도 동일한 방식으로 동작한다.

# 8. @Aspect AOP
### @Aspect 프록시 - 적용
- `@Aspect`는 애노테이션으로 매우 편리하게 포인트컷과 어드바이스로 구성되어 있는 어드바이저 생성 기능을 지원한다.
- `@Around("execution()")`
  - `@Around`의 값에 포인트컷 표현식을 넣는다. 표현식은 AspectJ 표현식을 사용한다.
  - `@Around`의 메서드는 어드바이스가 된다.
- `ProceedingJoinPoint joinPoint` : 어드바이스에서 살펴본 `MethodInvocation invocation`과 유사한 기능. 내부에 실제 호출 대상, 전달 인자, 그리고 어떤 객체와 어떤 메서드가 호출되었는지 정보가 포함되어 있다.
- `joinPonit.proceed()` : 실제 호출 대상을 호출한다.

### 자동 프록시 생성기의 2가지 역할
- 자동 프록시 생성기는 `@Aspect`를 찾아서 이것을 Advisor로 변환해서 저장한다.
- 자동 프록시 생성기 `AnnotationAwareAspectJAutoProxyCreator`는 Advisor를 자동으로 찾아와서 필요한 곳에 프록시를 생성하고 적용해준다.

### @Aspect를 어드바이저로 변환해서 저장하는 과정
- 1. 실행 : 스프링 애플리케이션 로딩 시점에 자동 프록시 생성기를 호추한다.
- 2. 모든 @Aspect 빈 조회 : 자동 프록시 생성기는 스프링 컨테이너에서 @Aspect 애노테이션이 붙은 스프링 빈을 모두 조회한다.
- 3. 어드바이저 생성 : @Aspect 어드바이저 빌더를 통해 @Aspect 애노테이션 정보를 기반으로 어드바이저를 생성한다.
- 4. @Aspect 기반 어드바이저 저장 : 생성한 어드바이저를 @Aspect 어드바이저 빌더 내부에 저장한다.

### @Aspect 어드바이저 빌더
- `BeanFactoryAspectJAdvisorsBuilder` 클래스
- `@Aspect`의 정보를 기반으로 포인트컷, 어드바이스, 어드바이저를 생성하고 보관하며 @Aspect 어드바이저 빌더 내부에 저장소에 캐시한다.
- 캐시에 어드바이저가 이미 만들어져 있는 경우 캐시에 저장된 어드바이저를 반환한다.

### 자동 프록시 생성기의 작동 과정 - `@Asepct` 추가
- 1. 생성 : 스프링 빈 대상이 되는 객체를 생성한다. (@Bean, 컴포넌트 스캔)
- 2. 전달 : 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달
- 3. -1 Advisor 빈 조회 : 스프링 컨테이너에서 Advisor 빈을 모두 조회
- 3. -2 @Aspect Advisor 조회 : @Aspect 어드바이저 빌더 내부에 저장된 Advisor를 모두 조회
- 4. 프록시 적용 대상 체크 : 3-1, 3-2 에서 조회한 Advisor에 포함되어 있는 포인트컷을 사용해서 해당 객체가 프록시를 적용할 대상인지 아닌지 판단. 이때 객체의 클래스 정보는 물론이고, 해당 객체의 모든 메서드를 포인트컷에 하나하나 모두 매칭해본다. 조건이 하나라도 만족하면 프록시 적용 대상이 된다.
- 5. 프록시 생성 : 프록시 적용 대상이면 프록시를 생성하고 프록시를 반환한다. 그래서 프록시를 스프링 빈으로 등록한다. 만약 프록시 적용 대상이 아니라면 원본 객체를 반환해서 원본 객체를 스프링 빈으로 등록한다.
- 6. 빈등록 반환된 객체는 스프링 빈으로 등록된다.

### @Aspect - 정리
- 실무에서 프록시를 적용할 때는 대부분 이 방식을 사용한다.
- 횡단 관심사(cross-cutting concerns) : 애플리케이션의 여러 기능들 사이에 걸쳐서 들어가는 관심사
- `@Aspect`는 여러 곳에 걸쳐있는 횡단 관심사의 문제를 해결하는 방법

# 9. 스프링 AOP 개념
### AOP 소개 - 핵심 기능과 부가 기능
- 핵심 기능 : 해당 객체가 제공하는 고유의 기능
- 부가 기능 : 핵심 기능을 보조하기 위해 제공되는 기능. 단독으로 사용되지 않고, 핵심 기능과 함께 사용됨.
  - 부가 기능은 여러 클래스에 걸쳐서 함께 사용됨. 이러한 부가 기능은 횡단 관심사가 됨.
  - 부가 기능의 적용 문제
    - 부가 기능을 적용할 때 아주 많은 반복이 필요하다.
    - 부가 기능이 여러 곳에 퍼져서 중복 코드를 만들어낸다.
    - 부가 기능을 변경할 때 중복 때문에 많은 수정이 필요하다.
    - 부가 기능의 적용 대상을 변경할 때 많은 수정이 필요하다.

### AOP 소개 - 애스펙트
- 부가 기능을 핵심 기능에서 분리하고 한 곳에서 관리하도록 함.
- 해당 부가 기능을 어디에 적용할지 선택하는 기능도 있음.
- 위의 두 가지 기능을 합해서 하나의 모듈로 만든 것이 바로 애스펙트(Aspect)
- 즉, 애스팩트는 부가 기능과 해당 부가 기능을 어디에 적용할지 정의한 것
- 애스펙트를 사용한 프로그래밍 방식을 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)
- AOP는 OOP를 대체하기 위한 것이 아니라 횡단 관심사를 깔끔하게 처리하기 어려운 OOP의 부족한 부분을 보조하는 목적으로 개발됨.

### AspectJ 프레임워크
- 자바 프로그래밍 언어에 대한 완벽한 관점 지향 확장
- 횡단 관심사의 깔끔한 모듈화
  - 오류 검사 및 처리
  - 동기화
  - 성능 최적화(캐싱)
  - 모니터링 및 로깅

### AOP 적용 방식
- 컴파일 시점 적용
- 클래스 로딩 시점 적용
- 런타임 시점 적용 (프록시)

#### 컴파일 시점 적용
- .java 소스 코드를 컴파일러를 사용해서 .class를 만드는 시점에 부가 기능 로지을 추가
- AspectJ가 제공하는 특별한 컴파일러 사용
- 부가 기능 코드가 핵심 기능이 있는 컴파일된 코드 주변에 실제로 붙어 버림. 이를 위빙이라고 함.
- 단점 
  - 컴파일 시점에 부가 기능을 적용하려면 특별한 컴파일러도 필요하고 복잡하다.

#### 클래스 로딩 시점 적용
- 자바를 실행하면 자바 언어는 .class파일을 JVM 내부의 클래스 로더에 보관한다. 이때 중간에서 .class 파일을 조작한 다음 JVM에 올릴 수 있다.
- 참고로 수 많은 모니터링 툴들이 이 방식을 사용하며, 이 시점에 애스펙트를 적용하는 것을 로드 타임 위빙이라고 한다.
- 단점
  - 자바를 실행할 때 특별한 옵션(java -javaagent)을 통해 클래스 로더 조작기를 지정해야 하는데 이 부분이 번거롭고 운영이 어렵다.

#### 런타임 시점 적용
- 컴파일도 다 끝나고, 클래스 로더에 클래스도 다 올라가서 이미 자바가 실행되고 난 다음을 말함.
- 자바의 메인main 메서드가 이미 실행된 다음이다. 즉 자바 언어가 제공하는 범위 안에서 부가 기능을 적용해야 한다.
- 스프링과 같은 컨테이너의 도움을 받고 프록시와 DI, 빈 포스트 프로세서 같은 개념들을 총 동원해야 한다. (프록시 방식의 AOP)
- 프록시를 사용하기 때문에 AOP 기능에 일부 제약이 있으나, 특별한 컴파일러나 자바를 실행할 때 복잡한 옵션과 클래스 로더 조작기를 설정하지 않아도 됨.
- 스프링만 있으면 얼마든지 AOP를 적용할 수 있음.

#### 정리
- 컴파일 시점 : 실제 대상 코드에 애스펙트를 통한 부가 기능 호출 코드가 포함됨. AspectJ를 직접 사용.
- 클래스 로딩 시점 : 실제 대상 코드에 애스펙트를 통한 부가 기능 호출 코드가 포함됨. AspectJ를 직접 사용.
- 런타임 시점 : 실제 대상 코드는 그대로 유지되며, 대신에 프록시를 통해 부가 기능이 적용됨. 따라서 항상 프록시를 통해야 부가 기능을 사용할 수 있음. 스프링 AOP가 이 방식을 사용.

### AOP 적용 위치
- 적용 가능 지점(조인 포인트, Join Point): 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행
- AspectJ를 사용해서 컴파일 시점과 클래스 로딩 시점에 적용하는 AOP는 바이트 코드를 실제 조작하기 때문에 해당 기능을 모든 지점에 다 적용할 수 있음.
- 프록시 방식을 사용하는 스프링 AOP는 메서드 실행 지점에만 AOP를 적용할 수 있음. (AspectJ를 직접 사용하는 방식이 아님. 문법만 차용)
  - 프록시는 메서드 오버라이딩 개념으로 동작함. 따라서 생성자나 static 메서드, 필드 값 접근에는 프록시 개념이 적용될 수 없음.
  - 프록시를 사용하는 스프링 AOP의 조인 포인트는 메서드 실행으로 제한됨.
- 프록시 방식을 사용하는 스프링 AOP는 스프링 컨테이너가 관리할 수 있는 스프링 빈에만 AOP를 적용할 수 있음.

### AOP 용어 정리
- 조인 포인트(Join Point)
  - 어드바이스가 적용될 수 있는 위치, 메소드 실행, 생성자 호출, 필드 값 접근, static 메서드 접근 같은 프로그랭 실행 중 지점
  - 조인 포인트는 추상적인 개념이다. AOP를 적용할 수 있는 모든 지점이라고 생각하면 됨.
  - 스프링 AOP는 프록시 방식을 사용하므로 조인 포인트는 항상 메소드 실행 지점으로 제한됨.
- 포인트컷(Pointcut)
  - 조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능
  - 주로 AspectJ 표현식을 사용해서 지정
  - 프록시를 사용하는 스프링 AOP는 메서드 실행 지점만 포인트컷으로 선별 가능
- 타켓(Target)
  - 어드바이스를 받는 객체, 포인트컷으로 결정
- 어드바이스(Advice)
  - 부가 기능
  - 특정 조인 포인트에서 Aspect에 의해 취해지는 조치
  - Around(주변), Before(전), After(후)와 같은 다양한 종류의 어드바이스가 있음
- 애스팩트(Aspect)
  - 어드바이스 + 포인트컷을 모듈화한 것
  - `@Aspect`
  - 여러 어드바이스와 포인트 컷이 함께 존재
- 어드바이저(Advisor)
  - 하나의 어드바이스와 하나의 포인트 컷으로 구성
  - 스프링 AOP에서만 사용되는 특별한 용어
- 위빙(Weaving)
  - 포인트컷으로 결정한 타겟의 조인 포인트에 어드바이스를 적용하는 것
  - 위빙을 통해 핵심 기능 코드에 영향을 주지 않고 부가 기능을 추가할 수 있음
  - AOP 적용을 위해 애스펙트를 객체에 연결한 상태
    - 컴파일 타임(AspectJ Compiler)
    - 로드 타임 
    - 런타임 (스프링 AOP는 런타임, 프록시 방식)
- AOP 프록시
  - AOP 기능을 구현하기 위해 만든 프록시 객체, 스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시이다.

# 10. 스프링 AOP 구현
- `@Aspect`는 애프펙트라는 표식이지 컴포넌트 스캔이 되지는 않는다. 이를 AOP로 사용하려면 스프링 빈으로 등록해야 한다.
- @Bean, @Component, @Import 등의 방법 사용 가능

### @Around
- `@Around` 애노테이션 값은 포인트컷이 된다. 이 때 값은 AspectJ 포인트컷 표현식을 따른다.
- `@Around` 애노테이션의 메서드는 어드바이스가 된다.
- 스프링은 프록시 방식의 AOP를 사용하므로 프록시를 통하는 메서드만 적용 대상이 된다.

### @Pointcut
- `@Pointcut`에 포인트컷 표현식을 사용
- 메서드 이름과 파라미터를 합쳐서 포인트컷 시그니처라고 한다.
- 메서드의 반환 타입은 void여야 한다.
- 코드 내용은 비운다.
- `@Around` 어드바이스에서는 포인트컷을 직접 지정해도 되지만, 포인트컷 시그니처를 사용해도 된다.
- 내부에서만 사용하면 private을 사용해도 되지만, 다른 애스펙트에서 참고하려면 public을 사용해야 한다.
- `@Pointcut` 애노테이션을 사용하면 하나의 포인트컷 표현식을 여러 어드바이스에서 함께 사용할 수 있다. 다른 클래스에 있는 외부 어드바이스에서도 이 포인트컷을 사용할 수 있다.
