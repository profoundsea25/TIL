> 김영한님의 [스프링 핵심 원리 - 고급편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8) 강의 내용 정리입니다.

# 2. 쓰레드 로컬
### 동시성 문제
- 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제
- 여러 쓰레드가 같은 인스턴스의 필드에 접근해야 하지 때문에 트래픽이 적은 상황에서는 확률상 잘 나타나지 않고, 트래픽이 점점 많아질수록 자주 발생
- 특히 스프링 빈처럼 싱글톤 객체의 필드를 변경하며 사용할 때 이러한 동시성 문제를 조심해야 함.
- 동시성 문제는 지역 변수에서는 발생하지 않음. 지역 변수는 쓰레드마다 각각 다른 메모리 영역이 할당됨.
- 동시성 문제가 발생하는 곳은 인스턴스의 필드(주로 싱글톤에서 자주 발생), 또는 static 같은 공용 필드에 접근할 때 발생
- 동시성 문제는 값을 읽기만 하면 발생하지 않음. 어디선가 값을 변경하기 때문에 발생
- 동시성 문제를 해결하기 위해 사용하는 것이 바로 쓰레드 로컬

### ThreadLocal
- 쓰레드 로컬이란 해당 쓰레드만 접근할 수 있는 특별한 저장소
- 해당 쓰레드가 쓰레드 로컬을 모두 사용하고 나면 `ThreadLocal.remove()`를 호출해서 쓰레드 로컬에 저장된 값을 제거해주어야 한다.
- 값을 저장할 때는 `.set()`, 값을 조회할 때는 `.get()`
- 쓰레드 로컬의 값을 사용 후 제거하지 않고 그냥 두면 WAS(톰캣)처럼 쓰레드 풀을 사용하는 경우에 심각한 문제가 발생할 수 있다.

# 3. 템플릿 메서드 패턴과 콜백 패턴
### 템플릿 메서드 패턴
- 이름 그대로 템플릿을 사용하는 방식
- 템플릿은 기준이 되는 거대한 틀
- 템플릿이라는 틀에 변하지 않는 부분을 몰아둔다. 그리고 일부 변하는 부분을 별도로 호출해서 해결한다.
- 부모 클래스에 변하지 않는 템플릿 코드를 두고, 변하는 부분은 자식 클래스에 두고 상속과 오버라이딩을 사용해서 처리한다.
#### 정의 BY GOF
- 템플릿 메서드 디자인 패턴의 목적은 다음과 같습니다.
- "작업에서 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스로 연기합니다. 템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의할 수 있습니다."
- 부모 클래스에 알고리즘의 골격인 템플릿을 정의하고, 일부 변경되는 로직은 자식 클래스에 정의하는 것
- 이렇게 하면 자식 클래스가 알고리즘의 전체 구조를 변경하지 않고, 특정 부분만 재정의할 수 있음.
- 결국 상속과 오버라이딩을 통한 다형성으로 문제를 해결

#### 단점
- 템플릿 메서드 패턴은 상속을 사용. 따라서 상속에서 오는 단점들을 그대로 안고간다.
- 특히 자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합되는 문제가 있음. (의존관계에 대한 문제)
- 강하게 의존한다 = 자식 클래스의 코드에 부모 클래스의 코드가 명확하게 적혀 있다는 뜻
- 자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않음. 그러나 부모 클래스를 알아야 함.
- 이것은 좋은 설계가 아님. 이런 잘못된 의존관계 때문에 부모 클래스를 수정하면, 자식 클래스에도 영향을 줄 수 있음.
- 추가로 상속 구조 때문에 별도의 클래스나 익명 내부 클래스를 만들어야 하는 부분도 복잡함.

### 전략 패턴 (Strategy Pattern)
- 템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴
- 전략 패턴은 변하지 않는 부분을 `Context`라는 곳에 두고, 변하는 부분을 `Strategy`라는 인터페이스를 만들고 해당 인터페이스를 구현하도록 해서 문제를 해결한다.
- 상속이 아니라 위임으로 문제를 해결하는 것이다.
- 전략 패턴에서 `Context`는 변하지 않는 템플릿 역할을 하고, `Strategy`는 변하는 알고리즘 역할을 한다.
- "알고리즘 제품군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만들자. 전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다." by GOF
- 컨텍스트는 크게 변하지 않지만, 그 속에서 strategy를 통해 일부 전략이 변경된다.
- 전략 패턴의 핵심은 `Context`는 `Strategy` 인터페이스에만 의존한다는 점이다. 덕분에 `Strategy`의 구현체를 변경하거나 새로 만들어도 `Context` 코드에는 영향을 주지 않는다.
- 스프링의 의존 관계 주입에서 사용하는 방식
- 변하지 않는 부분을 `Context`에 두고, 변하는 부분을 `Strategy`를 구현해서 만든다. 그리고 `Context`의 내부에 `Strategy`를 주입해서 사용한다.

#### 전략 패턴 실행 순서
1. `Context`에 원하는 `Strategy` 구현체를 주입한다.
2. 클라이언트는 `Context`를 실행한다.
3. `Context`는 `Context` 로직을 시작한다.
4. `Context` 로직 중간에 `Strategy`를 호출해서 주입받은 `Strategy` 로직을 실행한다.
5. `Context`는 나머지 로직을 실행한다.

#### 단점
- `Context`와 `Strategy`를 조립한 이후에는 전략을 변경하기가 번거롭다는 점
  - `Context`에 setter를 제공해서 `Strategy`를 넘겨 받아 변경하는 해결책 -> `Context`를 싱글톤으로 사용할 때 동시성 이슈 등 고려할 점이 많음.
  - 그래서 전략을 실시간으로 변경해야 하면 차라리 `Context`를 하나 더 생성하고 그곳에 다른 `Strategy`를 주입하는 것이 더 나은 선택일 수 있음.

#### 직접 파라미터 전달하기
- `Context`와 `Strategy`를 '선 조립, 후 실행' 하는 방식이 아니라 `Context`를 실행할 때마다 전략을 인수로 전달
- 클라이언트는 `Context`를 실행하는 시점에 원하는 `Strategy`를 전달할 수 있다. 따라서 이전 방식과 비교해서 원하는 전략을 더운 유연하게 변경할 수 있다.

#### 직접 파라미터 전달하기 전략 패턴 실행순서
1. 클라이언트는 `Context`를 실행하면서 인수로 `Strategy`를 전달한다.
2. `Context`는 로직을 실행한다.
3. `Context`는 파라미터로 넘어온 `Strategy`의 로직을 실행한다.
4. `Context`의 로직이 종료된다.

#### 정리
- V1 : `Context`필드에 `Strategy`를 저장하는 방식의 전략 패턴
  - 선 조립, 후 실행 방법에 적합
  - `Context`를 실행하는 시점에는 이미 조립이 끝났기 때문에 전략을 신경쓰지 않고 단순히 실행만 하면 됨
- V2 : `Context`에 `Strategy`를 전달받는 방식의 전략 패턴
  - 실행할 때마다 전략을 유연하게 변경할 수 있음
  - 단점 : 실행할 때마다 전략을 계속 지정해주어야 함
- 전략 패턴의 의도 : 변하는 부분과 변하지 않는 부분을 분리하는 것
- 변하지 않는 부분을 템플릿이라고 하고, 그 템플릿 안에서 변하는 부분에 약간 다른 '코드 조각'을 넘겨서 실행하는 것이 목적.
- 따라서 이 때에는 V2가 더 적합

### 템플릿 콜백 패턴 31~
