# [Kotlin in Action(2/e)](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=358099845)
- 지은이: 세바스티안 아이그너, 로만 엘리자로프, 스베트라나 이사코바, 드미트리 제메로프
- 옮긴이: 오현석
- 출판사: 에이콘출판
- 읽은 날짜: 2025.03.10 ~ 2025.
- 북 스터디로 진행 (카뱅)

## 5. 람다를 사용한 프로그래밍

### 람다란
- 다른 함수에 전달할 수 있는 작은 코드 조각
- 일련의 동작을 다른 함수에 넘기거나 변수에 저장하기 위해 사용
- 자바에서는 예전에 익명 내부 클래스를 사용했지만 너무 번거로워 자바 8에서 람다가 등장하였다.
- 람다를 사용하면 더 간결하게 표현할 수 있다. 함수 선언을 할 필요가 없다.

### 코틀린 람다
- 람다가 인자를 하나만 사용하고, 구체적인 이름을 붙이고 싶지 않다면 `it`이라는 암시적 이름을 사용할 수 있다.
- 단순히 함수나 프로퍼티에 위임할 경우 멤버 참조(`::`)를 사용할 수 있다.
- 항상 중괄호(`{}`)로 둘러싸여 있다.
  - 인자 주변 목록에 괄호가 없다.
  - 화살표(`->`)가 인자와 람다 본문을 구분한다.
- 코드의 일부분을 블록으로 둘러싸 실행하고 싶다면 `run {}`을 사용하라.
- 컴파일러가 문맥으로 유추 가능한 인자 타입을 굳이 적지 않아도 된다.
  - 컴파일러가 타입을 유추할 수 없을 때만 명시하자.
- 람다가 어떤 함수의 유일한 인자이거나 마지막 인자인 경우, 빈 괄호(`()`)를 생략할 수 있다.
  - ex) `map() {}`(X) `map {}`(O)
- 둘 이상의 람다를 인자로 받는 함수는 람다를 괄호 밖으로 빼낼 수 없다.
- 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않아 타입을 명시해야 한다.
- 본문이 여러 줄인 경우, 본문의 맨 마지막에 있는 식이 람다의 결괏값이 된다. 명시적인 `return`이 필요하지 않다.

### 변수 캡처(capturing variables)
- 함수 안에 익명 내부 클래스를 선언하면, 그 클래스 안에서 함수의 파라미터와 로컬 변수를 참조할 수 있다. 람다 안에서도 동일한 일을 할 수 있다.
- 람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의보다 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.
- 코틀린과 자바 람다의 다른 점 중 하나는 코틀린 람다 안에서는 파이널 변수(불변 변수)가 아닌 변수에 접근할 수 있다는 것이다.
  - 람다 안에서 바깥의 변수를 변경해도 된다.
  - 람다 안에서 접근할 수 있는 외부 변수를 '람다가 캡처한 변수'라고 한다.
- 기본적으로 함수 안에 정의된 로컬 변수의 생명주기는 함수가 반환되면 끝난다.
  - 하지만 어떤 함수가 자신의 로컬 변수를 캡처한 람다를 반환하거나 다른 변수에 저장한다면 로컬 변수의 생명주기와 함수의 생명주기가 달라질 수 있다.
- 코틀린에서는 캡처한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 캡처한 변수를 읽거나 쓸 수 있다.
  - 파이널 변수를 캡처한 경우 - 람다 코드를 변수 값과 함께 저장
  - 파이널이 아닌 변수를 캡처한 경우 - 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다.
- 람다를 비동기적으로 실행되는 코드로 활용하는 경우, 로컬 변수 변경은 람다가 실행될 때만 일어난다.

### 멤버 참조(member reference)
- 함수를 값으로 바꿀 수 있다. 이중 콜론(`::`)을 사용한다. 이를 멤버 참조라고 한다.
- 정확히 한 메서드를 호출하거나 한 프로퍼티에 접근하는 함수 값을 만들어준다.
- 최상위 함수나 프로퍼티를 참조하는 경우, `::method` 식으로 참조 가능하다.
- 생성자 참조는 클래스 생성 작업을 연기하거나 저장해둘 수 있다. `::`뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다.
- 확장함수도 멤버 참조와 동일하게 접근할 수 있다.

### 단일 추상 메서드(Simple Abstract Method) 인터페이스
- 추상 메서드가 단 하나뿐인 인터페이스
- 함수형 인터페이스를 파라미터로 받는 모든 자바 메서드에 람다를 전달할 수 있다.
- 이 때, 함수형 인터페이스에 맞는 익명 클래스를 컴파일러가 구현한다.
  - 람다가 자신이 정의된 함수의 변수에 접근하지 않는다면, 함수가 호출될 때마다 람다에 해당하는 익명 객체가 재사용된다. (그때그때 만들어지지 않는다.)
  - 람다가 자신을 둘러싼 환경의 변수를 캡처하면 더 이상 각각의 함수 호출에 같은 인스턴스를 재사용할 수 없다.
    - 이런 경우 컴파일러는 호출마다 새로운 인스턴스를 만들고 그 객체 안에 캡처한 변수를 저장한다.
- `inline` 표시가 되있는 람다는 익명 클래스가 생성되지 않는다.
  - 대부분의 라이브러리 함수에는 `inline`이 붙어있다.
- 대부분의 경우 람다를 함수형 인터페이스 인스턴스로 변환하는 과정은 자동으로 일어난다.
- SAM 생성자는 SAM 인터페이스의 인스턴스로 명시적으로 변환해준다. ex) `Runnalbe { some() }`
  - 컴파일러가 변환을 자동으로 수행하지 못하는 맥락에서 사용할 수 있다.
- 람다는 인스턴스 자신을 가리키는 `this`를 사용할 수 없다. `this`가 필요한 경우, 람다 대신 익명 객체를 직접 구현한다.

### 코틀린에서 SAM 인터페이스 정의: `fun interface`
- 코틀린 함수형 인터페이스는 정확히 하나의 추상 메서드만 포함하지만 다른 비추상 메서드를 여럿 가질 수 있다.

### 수신 객체 지정 람다: `with, apply, also`
- 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메서드를 호출할 수 있게 한다.
- `with`
  - `public inline fun <T, R> with(receiver: T, block: T.() -> R): R` 
  - 어떤 객체의 이름을 반복하지 않고도 그 객체에 대해 다양한 연산을 수행하는 기능
  - 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다. 그래서 `this` 접근이 가능하다. (생략도 가능하다.)
  - `with`가 반환하는 값은 람다 코드를 실행한 결과이다. 그 결과는 람다식의 본문에 있는 마지막 식의 값이다.
- `apply`
  - `public inline fun <T> T.apply(block: T.() -> Unit): T`
  - `with`와 거의 동일하다. 유일한 차이는, `apply`는 항상 자신에 전달된 객체를 반환한다. `(T) -> T`
  - 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화해야 하는 경우 `apply`가 유용하다.
    - 자바의 빌더와 비슷하다.
- `also`
  - `public inline fun <T> T.also(block: (T) -> Unit): T`
  - 수신 객체에 대해 어떤 동작을 수행한 후 수신 객체를 돌려준다.
  - 주된 차이는 `also`의 람다 안에서는 수신 객체를 인자로 참조한다는 점이다.
    - 따라서 파라미터 이름을 부여하거나 디폴트 이름인 it을 사용해야 한다.
  - 원래 수신 객체를 인자로 받는 동작을 실행할 때 유용하다. 객체에 대해 추가 작업을 실행할 수 있다.
    - "그리고(also) 다음을 객체에게 수행한다."로 읽을 수 있다.
