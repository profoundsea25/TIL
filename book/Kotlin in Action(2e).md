# [Kotlin in Action(2/e)](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=358099845)
- 지은이: 세바스티안 아이그너, 로만 엘리자로프, 스베트라나 이사코바, 드미트리 제메로프
- 옮긴이: 오현석
- 출판사: 에이콘출판
- 읽은 날짜: 2025.03.10 ~ 2025.
- 북 스터디로 진행 (카뱅)

## 1장. 코틀린이란 무엇이며, 왜 필요한가?
- 코틀린은 맨 처음에 '더 나은 자바'로 시작했다.
  - 개발자들이 저지를 수 있는 일반적인 유형의 오류를 방지한다.
  - 현대적 언어 설계 패러다임을 포용한다. (다중 패러다임 언어)
    - 객체지향 언어와 함수형 언어의 아이디어를 조합했다.
  - 자바가 쓰이던 모든 곳에 더 편리하게 쓸 수 있는 언어이다.
- 코틀린은 정적 타입 지정(statically typed) 언어이다.
  - 핵심적인 장점은 프로그램의 모든 식의 타입을 컴파일 시점에 알 수 있다.
  - 컴파일러가 타입을 추론한다.
  - 성능, 신뢰성, 유지 보수성
- 코틀린의 주 목적
  - 현재 자바가 사용되고 있는 모든 용도에 적합하면서도 더 간결하고 생산적이며 안전한 대체 언어를 제공하는 것
  - 더 적은 코드로 더 편하게 목표를 달성한다.

### 코틀린의 철학
- "상호운용성에 초점을 맞춘 실용적이고 간결하며 안전한 언어"
- 실용적이다.
  - 코틀린은 실제 문제를 해결하기 위한 언어이다. 많은 개발자들의 의견을 반영했다.
  - IDE 지원이 좋다. (IntelliJ)
- 간결하다.
  - 코드가 더 간단하고 간결할수록 내용을 파악하기가 더 쉽다. 이때 언어 자체의 간결성도 중요하다.
  - 언어가 간결하다는 것
    - 그 언어로 작성된 코드를 읽을 때 의도를 쉽게 파악할 수 있는 구문 구조를 제공한다.
    - 이해할 때 방해가 될 수 있는 부가적인 준비 코드가 적다.
  - ex. getter, setter, 생성자 파라미터 등을 사용하지 않음. 강력한 타입 추론. 라이브러리 함수.
  - 중요한 것은 읽고 이해하는 데 시간이 덜 걸린다.
- 안전하다.
  - 프로그래밍 언어가 안전하다는 뜻은, 프로그램에서 발생할 수 있는 오류 중에서 일부 유형의 오류를 프로그램 설계가 원천적으로 방지해준다는 뜻이다.
  - JVM에서 실행한다는 사실은 이미 상당한 안정성이 있다.
    - 메모리 안전성을 보장한다.
    - 버퍼 오버플로를 방지한다.
    - 동적으로 할당하나 메모리를 잘못 사용하는 문제를 예방할 수 있다.
    - 읽기 전용 변수를 쉽게 정의할 수 있다. 이는 다중 스레드 애플리케이션에서 안전성을 더 보장한다.
  - 컴파일 시점에서 오류를 더 방지한다.
    - `NullPointerException`
      - 코틀린 타입 시스템은 null이 될 수 없는 값을 추적하며 실행 시점에 NPE가 발생할 수 있는 연산을 사용하는 코드를 금지시킨다.
    - 클래스 타입 캐스팅
      - 코틀린은 타입 검사와 캐스트를 한 연산자로 수행한다.
- 상호운용성이 좋다.
  - 자바의 기존 라이브러리를 사용할 수 있다.
  - 자바 코드에서 코틀린 코드를 호출할 때도 아무런 노력이 필요하지 않다.

## 2장. 코틀린 기초
- '코틀린스러운' 코드란?
  - 코틀린에서 제공하는 syntactic sugar를 적절히 사용해 코드를 작성하는 것.
  - 코틀린 커뮤니티에서 일반적으로 받아들여지는 프로그래밍 스타일과 잘 들어맞고, 언어 설계자들이 권장하는 방식을 따르는 코드.

### 문(statement)와 식(expression)의 구분
- statement
  - 자신을 둘러싼 가장 안쪽 블록의 최상위 요소로 존재
  - 아무런 값을 만들어내지 않는다.
  - ex. 루프(for, while)
- expression
  - 값을 만들어낸다.
  - 다른 식의 하위 요소로 계산에 참여할 수 있다.

### 식 본문 함수
- 코틀린에서는 식 본문 함수(expression body function)이 자주 쓰인다.
- 반환 타입을 명시하지 않아도 컴파일러가 타입을 추론한다.
  - 블록 본문 함수는 타입 명시가 필수다.
- 라이브러리를 작성할 때는 반환 타입을 명시하라.

### 2.2 행동과 데이터 캡슐화: 클래스와 프로퍼티
- 프로퍼티(property) = 필드와 접근자(getter)
- `val`, `var` 모두 비공개 필드를 갖는다.
- 보통 프로퍼티에는 그 값을 저장하기 위한 필드가 있다. (backing field)
- 원한다면 프로퍼티 값을 그때그때 계산할 수도 있다. (커스텀 접근자)

### 2.3 enum과 when
- when도 if와 마찬가지로 값을 만들어내는 식(expression)이다.
- when 식의 대상 값을 변수에 넣을수도 있다.
  - ex `when(val color = someMethod()) {...}`

### (새로 안 것들)
- `is`로 타입을 확인했다면, 해당 변수를 그 타입으로 변환하지 않아도 된다.
  - 변수에 든 값이 변할 수 없는 경우에만 작동한다. `val`이면서 커스텀 접근자가 아니어야 한다.
- `{name}@ while (...)` 등으로 반복문에 이름을 붙일 수 있다.
  - `break@{name}`, `continue@{name}`을 통해 이름 붙인 반복문을 제어할 수 있다.

### 2.5 코틀린에서 예외 던지고 잡아내기
- 코틀린은 체크 예외와 언체크 예외를 구별하지 않는다.
  - 예외 처리 규칙이 실제로는 오류 발생을 방지하지 못하는 경우가 자주 있기 때문이다.


## 3. 함수 정의와 호출
- `@JvmOverloads`
  - 자바에서 코틀린 함수를 자주 호출해야 해서 자바 측에서 편하게 코틀린 함수를 호출하고 싶을 때 사용
    - 코틀린 함수를 자바에서 호출할 때는 모든 인자를 명시해야 하기 때문이다.
  - 코틀린 컴파일러가 자동으로 맨 마지막 파라미터로부터 파라미터를 하나씩 생략한 오버로딩한 자바 메서드를 추가
#### 3.3.4 확장 함수는 오버라이드할 수 없다.
- 확장 함수는 클래스의 일부가 아니다.
- 메서드 시그니처가 완전히 같은 확장 함수를 상위 클래스와 하위 클래스에 대해 정의할 수 있다. 하지만 실제 호출될 함수는 확장 함수를 호출할 때 수신 객체로 지정한 변ㅌ수의 컴파일 시점의 타입에 의해 결정된다.
  - 즉, 동적으로 결정되지 않는다.
- 어떤 클래스의 확장 함수와 멤버 함수의 메서드 시그니처가 같다면 멤버 함수가 호출된다.

#### 3.3.5 확장 프로퍼티
- 프로퍼티라는 이름으로 불리기는 하지만 상태를 저장할 방법이 없기 떄문에 실제로 확장 프로퍼티는 아무 상태도 가질 수 없다.
  - 뒷받침하는 필드가 없어 기본 게터 구현을 제공할 수 없으므로 최소한 게터는 꼭 정의를 해야 한다.


## 4. 클래스, 객체, 인터페이스


## 5. 람다를 사용한 프로그래밍

### 람다란
- 다른 함수에 전달할 수 있는 작은 코드 조각
- 일련의 동작을 다른 함수에 넘기거나 변수에 저장하기 위해 사용
- 자바에서는 예전에 익명 내부 클래스를 사용했지만 너무 번거로워 자바 8에서 람다가 등장하였다.
- 람다를 사용하면 더 간결하게 표현할 수 있다. 함수 선언을 할 필요가 없다.

### 코틀린 람다
- 람다가 인자를 하나만 사용하고, 구체적인 이름을 붙이고 싶지 않다면 `it`이라는 암시적 이름을 사용할 수 있다.
- 단순히 함수나 프로퍼티에 위임할 경우 멤버 참조(`::`)를 사용할 수 있다.
- 항상 중괄호(`{}`)로 둘러싸여 있다.
  - 인자 주변 목록에 괄호가 없다.
  - 화살표(`->`)가 인자와 람다 본문을 구분한다.
- 코드의 일부분을 블록으로 둘러싸 실행하고 싶다면 `run {}`을 사용하라.
- 컴파일러가 문맥으로 유추 가능한 인자 타입을 굳이 적지 않아도 된다.
  - 컴파일러가 타입을 유추할 수 없을 때만 명시하자.
- 람다가 어떤 함수의 유일한 인자이거나 마지막 인자인 경우, 빈 괄호(`()`)를 생략할 수 있다.
  - ex) `map() {}`(X) `map {}`(O)
- 둘 이상의 람다를 인자로 받는 함수는 람다를 괄호 밖으로 빼낼 수 없다.
- 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않아 타입을 명시해야 한다.
- 본문이 여러 줄인 경우, 본문의 맨 마지막에 있는 식이 람다의 결괏값이 된다. 명시적인 `return`이 필요하지 않다.

### 변수 캡처(capturing variables)
- 함수 안에 익명 내부 클래스를 선언하면, 그 클래스 안에서 함수의 파라미터와 로컬 변수를 참조할 수 있다. 람다 안에서도 동일한 일을 할 수 있다.
- 람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의보다 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.
- 코틀린과 자바 람다의 다른 점 중 하나는 코틀린 람다 안에서는 파이널 변수(불변 변수)가 아닌 변수에 접근할 수 있다는 것이다.
  - 람다 안에서 바깥의 변수를 변경해도 된다.
  - 람다 안에서 접근할 수 있는 외부 변수를 '람다가 캡처한 변수'라고 한다.
- 기본적으로 함수 안에 정의된 로컬 변수의 생명주기는 함수가 반환되면 끝난다.
  - 하지만 어떤 함수가 자신의 로컬 변수를 캡처한 람다를 반환하거나 다른 변수에 저장한다면 로컬 변수의 생명주기와 함수의 생명주기가 달라질 수 있다.
- 코틀린에서는 캡처한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 캡처한 변수를 읽거나 쓸 수 있다.
  - 파이널 변수를 캡처한 경우 - 람다 코드를 변수 값과 함께 저장
  - 파이널이 아닌 변수를 캡처한 경우 - 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다.
- 람다를 비동기적으로 실행되는 코드로 활용하는 경우, 로컬 변수 변경은 람다가 실행될 때만 일어난다.

### 멤버 참조(member reference)
- 함수를 값으로 바꿀 수 있다. 이중 콜론(`::`)을 사용한다. 이를 멤버 참조라고 한다.
- 정확히 한 메서드를 호출하거나 한 프로퍼티에 접근하는 함수 값을 만들어준다.
- 최상위 함수나 프로퍼티를 참조하는 경우, `::method` 식으로 참조 가능하다.
- 생성자 참조는 클래스 생성 작업을 연기하거나 저장해둘 수 있다. `::`뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다.
- 확장함수도 멤버 참조와 동일하게 접근할 수 있다.

### 단일 추상 메서드(Simple Abstract Method) 인터페이스
- 추상 메서드가 단 하나뿐인 인터페이스
- 함수형 인터페이스를 파라미터로 받는 모든 자바 메서드에 람다를 전달할 수 있다.
- 이 때, 함수형 인터페이스에 맞는 익명 클래스를 컴파일러가 구현한다.
  - 람다가 자신이 정의된 함수의 변수에 접근하지 않는다면, 함수가 호출될 때마다 람다에 해당하는 익명 객체가 재사용된다. (그때그때 만들어지지 않는다.)
  - 람다가 자신을 둘러싼 환경의 변수를 캡처하면 더 이상 각각의 함수 호출에 같은 인스턴스를 재사용할 수 없다.
    - 이런 경우 컴파일러는 호출마다 새로운 인스턴스를 만들고 그 객체 안에 캡처한 변수를 저장한다.
- `inline` 표시가 되있는 람다는 익명 클래스가 생성되지 않는다.
  - 대부분의 라이브러리 함수에는 `inline`이 붙어있다.
- 대부분의 경우 람다를 함수형 인터페이스 인스턴스로 변환하는 과정은 자동으로 일어난다.
- SAM 생성자는 SAM 인터페이스의 인스턴스로 명시적으로 변환해준다. ex) `Runnalbe { some() }`
  - 컴파일러가 변환을 자동으로 수행하지 못하는 맥락에서 사용할 수 있다.
- 람다는 인스턴스 자신을 가리키는 `this`를 사용할 수 없다. `this`가 필요한 경우, 람다 대신 익명 객체를 직접 구현한다.

### 코틀린에서 SAM 인터페이스 정의: `fun interface`
- 코틀린 함수형 인터페이스는 정확히 하나의 추상 메서드만 포함하지만 다른 비추상 메서드를 여럿 가질 수 있다.

### 수신 객체 지정 람다: `with, apply, also`
- 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메서드를 호출할 수 있게 한다.
- `with`
  - `public inline fun <T, R> with(receiver: T, block: T.() -> R): R` 
  - 어떤 객체의 이름을 반복하지 않고도 그 객체에 대해 다양한 연산을 수행하는 기능
  - 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다. 그래서 `this` 접근이 가능하다. (생략도 가능하다.)
  - `with`가 반환하는 값은 람다 코드를 실행한 결과이다. 그 결과는 람다식의 본문에 있는 마지막 식의 값이다.
- `apply`
  - `public inline fun <T> T.apply(block: T.() -> Unit): T`
  - `with`와 거의 동일하다. 유일한 차이는, `apply`는 항상 자신에 전달된 객체를 반환한다. `(T) -> T`
  - 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화해야 하는 경우 `apply`가 유용하다.
    - 자바의 빌더와 비슷하다.
- `also`
  - `public inline fun <T> T.also(block: (T) -> Unit): T`
  - 수신 객체에 대해 어떤 동작을 수행한 후 수신 객체를 돌려준다.
  - 주된 차이는 `also`의 람다 안에서는 수신 객체를 인자로 참조한다는 점이다.
    - 따라서 파라미터 이름을 부여하거나 디폴트 이름인 it을 사용해야 한다.
  - 원래 수신 객체를 인자로 받는 동작을 실행할 때 유용하다. 객체에 대해 추가 작업을 실행할 수 있다.
    - "그리고(also) 다음을 객체에게 수행한다."로 읽을 수 있다.

## 6. 컬렉션과 시퀀스

- 람다를 인자로 받는 함수에 내부 로직의 복잡도를 생각하라. 연산이 반복되지는 않는지 고려하라.
- 항상 작성하는 코드로 인해 어떤 일이 벌어질지 명확히 이해해야 한다. 

### 컬렉션 함수
- 원소 제거와 변환: `filter`, `map`
  - `filter`: 컬렉션을 순회하며 주어진 람다가 true를 반환하는 원소들만 모은다.
    - `filterIndexed`: 원소의 인덱스를 포함하여 추출
    - `filterKeys`: map에서 키 기준 추출
    - `filterValues`: map에서 값 기준 추출
  - `map`: 입력 컬렉션의 원소를 변환한다.
    - `mapIndexed`: 원소의 인덱스를 포함한 `map` 연산
    - `mapKeys`: map에서 키를 변환 (Map<K1, V) -> Map<K2, V>)
    - `mapValues`: map에서 값을 변환 (Map<K, V1> -> Map<K, V2>)
- 컬렉션 값 누적: `reduce`, `fold`
  - 컬렉션의 정보를 종합한다.
  - 원소로 이뤄진 컬렉션을 받아서 한 값을 반환한다. 이 값은 accumulator(누적)을 통해 점진적으로 만들어진다.
  - 람다는 각 원소에 대해 호출되며 새로운 누적 값을 반환해야 한다.
  - `reduce`
    - 1번째 원소를 accumulator에 넣어서 시작한다.
    - 빈 리스트에서 호출하면 Exception 발생
  - `fold`
    - `reduce`와 비슷하지만, 초기값을 설정할 수 있다.
  - `runningReduce`, `runningFold`
    - `reduce`와 `fold`이 최종 결과값만 반환한다면, running이 붙은 함수들은 모든 중간 결과를 포함한 리스트를 반환한다.
- 컬렉션에 술어 적용: `all`, `any`, `none`, `count`, `find`
  - `all`: 모든 원소들이 조건을 만족하는지 판별
  - `any`: 원소들 중 하나라도 조건을 만족하는지 판별
    - `!all { predicate } == any { !predicate }`
  - `none`: 모든 원소들이 조건을 만족하지 않음을 판별 (=`!any`)
  - empty list 에선 어떻게 동작할까?
    - `all` -> 항상 true (조건을 만족하지 않는 원소를 댈 수 없기 때문)
    - `any` -> 항상 false (조건을 만족하는 원소가 없기 때문)
    - `none` -> 항상 true (any와 반대)
  - `count`: 조건을 만족하는 원소의 개수 반환
    - `filter { }.size`와 중간 과정이 다르다. `filter`는 중간 컬렉션을 만들지만, `count`는 원소 개수만 추적한다.
  - `find`: 조건을 만족하는 첫 번째 원소 반환
    - 원소가 전혀 없으면 `null` 반환 (`firstOrNull`과 같다.)
- 파티션을 분할해 리스트의 쌍으로 만들기: `partition`
  - `partition`: 조건을 만족하는 그룹과 그렇지 않은 그룹으로 나눈다. 전체 컬렉션을 2번 순회하지 않는다.
- 리스트를 여러 그룹으로 이뤄진 맵으로 바꾸기: `groupBy`
  - `groupBy`: 컬렉션의 원소를 어떤 특성에 따라 여러 그룹으로 나눌 때 사용
    - 컬렉션의 원소를 구분하는 특성이 key, 각 그룹이 value가 된다.
- 컬렉션을 맵으로 변환: `associate`, `associateWith`, `associateBy`
  - `associate`
    - 입력 컬렉션의 원소로부터 키/값 쌍을 만들어낸다.
    - 입력 시 중위 함수 `to`를 사용해 키/값 쌍을 표현한다.
  - `associateWith`
    - 컬렉션의 원래 원소를 키로 사용
    - 작성한 람다는 그 원소에 대응하는 값을 만든다.
  - `associateBy`
    - 컬렉션의 원래 원소를 값으로 사용
    - 작성한 람다는 그 원소에 대응하는 키를 만든다.
    - 키가 겹칠 경우 가장 마지막 결과가 저장된다.
- 가변 컬렉션의 원소 변경: `replaceAll`, `fill`
  - `replaceAll`
    - 지정한 람다로 얻은 결과로 컬렉션의 모든 원소를 변경한다.
    - `MutableList`에서 사용 가능하다.
  - `fill`
    - 가변 리스트의 모든 원소를 똑같은 값으로 바꾸는 경우 사용
- 컬렉션의 특별한 경우 처리: `ifEmpty`
  - 컬렉션에 아무 원소가 없을 때 기본값을 생성하는 람다를 제공한다.
- 컬렉션 나누기: `chunked`, `windowed`
  - `chunked`
    - 컬렉션을 주어진 크기로 서로 겹치지 않는 부분으로 나눌 때 사용.
    - 마지막으로 만들어진 청크의 크기는 정한 사이즈보다 작을 수 있다.
  - `windowed`
    - 슬라이딩 윈도우를 생성한다. 정한 길이만큼 인덱스를 1씩 밀어서 리스트들을 생성한다.
- 컬렉션 합치기: `zip`
  - 별도의 두 리스트를 한꺼번에 종합할 때 사용. 종합하면서 변환도 가능하다.
  - 결과 컬렉션은 두 입력 컬렉션 중 더 짧은 쪽의 길이와 같다.
  - `zip`은 항상 2개씩 합칠 수 있다. 중위 연산자로 여러개 겹치더라도 flat하게 합쳐지지 않는다. ex. ((A, B), C)
- 내포된 컬렉션의 원소 처리: `flatMap`, `flatten`
  - `flatMap`
    - 내포된 컬렉션 없이 컬렉션을 만들 수 있다.
    - 주어진 원소들을 변환한 다음, 하나의 리스트로 만든다.
  - `flatten`
    - 변환하는 것 없이 내포된 컬렉션을 하나의 컬렉션으로 만들고 싶을 때 사용

### 시퀀스(Sequence)
- 컬렉션 함수들은 결과 컬렉션을 즉시(eagerly) 생성한다.
  - 연쇄 호출하면, 매 단계마다 계산 중간 결과를 새로운 컬렉션으로 만든다.
- 시퀀스는 자바 스트림처럼 중간 임시 컬렉션을 만들지 않고 연산한다.
  - 시퀀스는 게으르게(lazy) 연산한다.
  - 연쇄적인 연산을 효율적으로 수행한다.
- `asSequence` 확장함수를 통해 어떤 컬렉션이든 시퀀스로 바꿀 수 있다.
- 큰 컬렉션에 대해 연산을 연쇄할 때는 시퀀스를 사용하라.
  - 크기가 충분히 크지 않다면 즉시 계산의 연산 효율이 더 좋다.
- 모든 연산은 각 원소에 대해 순차적으로 적용된다.
- 컬렉션의 경우 연산의 순서가 성능에 영향을 끼친다.
  - 연쇄 연산에서 더 빨리 원소들을 제거(filter)수록 코드의 성능이 더 좋아진다.

### 시퀀스 연산 실행: 중간 연산과 최종 연산
- 중간 연산
  - 다른 시퀀스를 반환
  - 최초 시퀀스의 원소를 변환하는 방법을 안다.
  - 항상 지연 연산
  - 최종 연산이 호출되지 않으면 아무 연산도 하지 않는다.
- 최종 연산
  - 결과를 반환. 모든 연산을 수행.
  - 시퀀스에서 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 수 또는 다른 객체

### 시퀀스 만들기
- `asSequence()`
  - 컬렉션을 시퀀스로 변환한다.
- `generateSequence`
  - 이전의 원소를 인자로 받아 다음 원소를 계산한다.

## 7. 널이 될 수 있는 값

### 7.1 Nullablility
- NPE를 피할 수 있게 돕는 코틀린 타입 시스템
- 가능한 null 문제를 실행 시점에서 컴파일 시점으로 옮김.
  - 널 여부를 타입 시스템에 추가하여 컴파일러가 관련 오류를 컴파일 시 미리 감지하여, 런타임 예외 가능성을 줄인다.

### 7.2 Null이 될 수 있는 타입
- 코틀린 타입 시스템은 널이 될 수 있는 타입을 명시적으로 지원한다.
- null을 포함하는 타입을 받을 수 있게 하려면 타입 이름에 물음표(?)를 명시해야 한다.
- 물음표가 없다면 null 참조가 불가능하다.
- 모든 타입은 기본적으로 null이 아니다. 명시적으로 ?가 붙어야 null이다.

### 7.3 타입의 의미 자세히 살펴보기
- 타입 = 가능한 값의 집합과, 그런 값들에 대해 수행할 수 있는 연산의 집합
- 특정 타입(클래스)와 null은 엄연히 다르다. 자바 타입 시스템도 서로 다른 것으로 취급한다.
  - `instanceof` 연산자도, null은 String이 아니라고 답한다.
  - null이 아님을 추가로 검사하기 전에 그 변수가 어떤 연산을 할 수 있을지 알 수 없다.
  - `@NotNull`/`@Nullable`이나 `Optional`로도 null을 완벽히 안전하게 처리할 수 없다.
- 코틀린은 널이 될 수 있는 타입과 아닌 타입을 구분하여 연산 가능성을 명확히 한다.
  - 실행시점에서는 널이 될 수 있는 타입과 그렇지 않은 타입은 같다.
  - 래퍼 타입이 아니다. 그래서 널이 될 수 있는 타입을 처리하는 데 실행 시점 부가 비용이 들지 않는다.

### 7.4 안전한 호출 연산자로 null 검사와 메서드 호출 합치기: `?.`
- 안전한 호출 연산자 `?.`
  - null 검사와 메서드 호출을 한 연산으로 수행
  - 호출하는 값이 null이 아니라면 일반 메서드 호출처럼 동작
  - 호출하려는 값이 null이면 null 반환

### 7.5 엘비스 연산자로 null에 대한 기본값 제공 : `?:`
- 엘비스 연산자 `?:`
  - null 대신 사용할 기본값을 지정하는 연산자
  - 첫번째 값이 null이 아니면 그 값을 반환
  - 첫번째 값이 null이면 두번째 값을 반환
- 코틀린에서는 `return`, `throw`도 식이기 때문에 엘비스 연산자 뒤에 쓸 수 있다.

### 7.6 예외를 발생시키지 않고 안전하게 타입을 캐스트하기: `as?`
- `as?`
  - 어떤 값을 지정한 타입으로 변환한다. 대상 타입으로 값을 변환할 수 없으면 null을 반환한다.

### 7.7 널 아님 단언: `!!`
- `!!`
  - 어떤 값이든 널이 아닌 타입으로 바꾼다.
  - 실제 null에 대해 !!를 적용하면 NPE가 발생한다.
  - NPE가 발생하면 사용하는 곳이 아닌 단언문이 선언된 곳을 가리킨다.
    - 스택 트레이스가 몇 번째 줄인지만 알려주기 때문에, 한 줄에 여러 `!!`를 쓰는 일을 피하라.
  - 컴파일러에게 "나는 이 값이 null이 아님을 알고 있으며, 잘못 되었따면 예외가 발생해도 감수하겠다."라는 말하는 것과 같다.

### 7.8 `let` 함수
- `let`
  - `let`을 안전한 호출 연산자(`.?`)와 함께 사용하여, 널이 될 수 있는 값을 널이 아닌 값만 인자로 받는 함수에 넘길 때 자주 사용한다.
  - 긴 식의 결과를 저장하는 변수를 따로 만들 필요가 없다.
  - null이 아닌 경우에만 코드 블록을 실행하고 싶을 때 사용한다.
  - 어떤 식의 결과를 변수에 담되 그 영역을 한정시키고 싶을 때 독립적으로 사용한다.
- `apply`
  - 빌더 스타일을 사용해 객체 프로퍼티를 설정할 때 사용
- `also`
  - 객체에 어떤 동작을 실행한 후 원래의 객체를 다른 연산에 사용하고 싶을 때
- `with`
  - 하나의 객체에 대해 이름을 반복하지 않으면서 여러 함수 호출을 그룹으로 묶고 싶을 때
- `run`
  - 객체를 설정한 다음에 별도의 결과를 돌려주고 싶을 때

### 7.9 직접 초기화하지 않는 널이 아닌 타입: 지연 초기화 프로퍼티
- 코틀린에서는 클래스 안의 널이 아닌 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메서드 안에서 초기화할 수는 없다.
  - 일반적으로 생성자에서 모든 프로퍼티를 초기화해야 한다.
  - 프로퍼티 타입이 널이 될 수 없는 타입이라면 반드시 널이 아닌 값으로 그 프로퍼티를 초기화해야 한다.
- 이를 해결하기 위해 지연 초기화(lazy-initialize)를 사용할 수 있다.
- `lateinit` 변경자를 붙이면 나중에 초기화할 수 있다.
  - 지연 초기화 프로퍼티는 항상 `var`이어야 한다.
  - `val`은 `final` 필드로 컴파일 되기 때문이다.
  - 반드시 클래스 멤버일 필요는 없고, 함수 본문 안의 지역 변수나 최상위 프로퍼티도 지연 초기화할 수 있다.

### 7.10 안전한 호출 연산자 없이 타입 확장: 널이 될 수 있는 타입에 대한 확장
- 널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null 값을 다루는 강력한 도구로 활용할 수 있다.
  - 메서드 호출이 null을 수신 객체로 받고 내부에서 null을 처리하게 만들 수 있다.

### 7.11 타입 파라미터의 널 가능성
- 코틀린에서 함수나 클래스의 모든 타입 파라미터는 기본적으로 null이 될 수 있다.
  - 타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T가 널이 될 수 있는 타입이다. (즉, T는 `Any?`로 추론된다.)
  - 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상계(upper bound)를 지정해야 한다.
    - `<T: Any>`

### 7.12 널 가능성과 자바
- 자바와 코틀린은 혼용할 때, 널 가능성 어노테이션(`@Nullable`, `@NotNull`)이 없는 경우, 자바의 타입은 코틀린의 플랫폼 타입이 된다.
- 플랫폼 타입
  - 코틀린이 널 관련 정보를 알 수 없는 타입
  - 널이 될 수 있는 타입으로 처리해도 되고, 널이 될 수 없는 타입으로 처리해도 된다. 모든 연산이 허용된다.
- 자바 API를 다룰 때는 조심하라. null이 될 수 있는지 확인해야 한다.
- 자바 클래스나 인터페이스를 코틀린에서 구현할 경우 널 가능성을 제대로 처리하는 일이 중요하다.

## 8장. 기본 타입, 컬렉션, 배열

### 8.1 원시 타입과 기본 타입
- 코틀린은 원시 타입과 래퍼 타입을 구분하지 않는다.
- 래퍼 타입을 따로 구분하지 않으면 편리하다. + 원시 타입의 값에 대해 메서드를 호출할 수 있다.
- 실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방식으로 표현된다.
- 대부분의 경우 코틀린 `Int`는 자바 `int`로 컴파일 된다.
- 코틀린에서 널이 될 수 있는 원시 타입을 사용하면 그 타입은 자바의 래퍼 타입으로 컴파일 된다.
- 제네릭을 쓰는 경우 래퍼 클래스로 컴파일 된다.
  - JVM이 타입 인자로 원시 타입을 허용하지 않기 때문이다.
- 코틀린은 자바와 다르게 한 숫자 타입을 다른 숫자 타입으로 자동 변환하지 않는다. 명시적으로 변환 메서드를 호출해야 한다.
  - (주의) `Long.toInt()`의 경우, Int 범위를 벗어나는 경우 일부를 잘라낸다.
- 리터럴(123L, 2U, 0.42f 등)을 사용한 경우 명시적으로 변환할 필요는 없다.
- 문자열을 수나 boolean으로 변환하기.
  - String.toInt() (숫자 변환 실패 시 Exception 발생)
  - String.toIntOrNull() (숫자 변환 or Null)
  - String.toBoolean (대소문자 구분하지 않음)
  - String.toBooleanStrict (소문자 "true"인 경우만 true)
- `Any`와 `Any?`
  - 코틀린에서는 `Any 타입`이 모든 널이 될 수 없는 타입의 조상
    - `toString()`, `equals()`, `hashCode()` 메서드 포함
    - `Any` 타입에 원시 타입 값을 할당하면 자동으로 박싱된다.
  - 자바에서는 `Object`가 그 역할지만, `int`같은 원시 타입을 포함하지 않는다.
  - `wait`, `notify` 등을 사용하고 싶다면 `Object`로 캐스팅해야 한다.
- `Unit`
  - 자바 `void`와 같은 기능
  - 코틀린에서 메서드의 반환 타입을 명시하지 않으면 `Unit`이 된다.
  - `Unit`은 타입 인자로 쓸 수 있다.
- `Nothing` 타입: 이 함수는 결코 반환되지 않는다.
  - 함수가 정상적으로 끝나지 않았음을 표현
  - `Nothing`은 아무 값도 포함하지 않기 때문에, 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다.

### 8.2 컬렉션과 배열
- 널이 될 수 있는 값의 컬렉션과 널이 될 수 없는 값의 컬렉션
  - ex. `List<Int?>?`
    - 리스트 자체가 null이 될 수도 있고, 원소도 null이 될 수도 있다.
  - `filterNotNull`: null이 아닌 원소만 거르는 컬렉션 메서드
- 읽기 전용과 변경 가능한 컬렉션
  - 코틀린은 컬렉션 안의 데이터에 접근하는 인터페이스와 컬렉션 안의 데이터를 변경하는 인터페이스를 분리했다.
    - kotlin `Collection` 인터페이스에는 원소에 접근하는 메서드는 있지만 원소를 추가하거나 제거하는 메서드는 없다.
    - kotlin `MutableCollection` 인터페이스에 컬렉션의 데이터를 수정하는 메서드가 있다.
  - 가능하면 코드에서 항상 읽기 전용 인터페이스를 사용하는 것을 일반적인 규칙으로 삼아라.
    - 컬렉션 변경이 필요할 때만 변경 가능한 버전을 사용하라.
  - 읽기 전용 컬렉션이라도 꼭 변경 불가능하지는 않다.
    - 읽기 전용 컬렉션이 thread-safe하지 않음을 명심하라.
- 코틀린 컬렉션과 자바 컬렉션은 밀접히 연관됨
  - 모든 코틀린 컬렉션은 그에 상응하는 자바 컬렉션 인터페이스의 인스턴스이다.
    - 코틀린과 자바 사이를 오갈 때 아무 변환이 필요 없다.
    - 자바 `Collection` 타입에 코틀린 `Collection`이나 `MutableCollection` 타입을 쓸 수 있다.
  - 코틀린의 컬렉션 인터페이스는 읽기 전용과 변경 가능으로 나뉜다.
    - `ArrayList`는 `MutableList`를, `HashSet`은 `MutableSet`을 상속한 것처럼 취급한다.
  - 자바 코드와 코틀린 코드를 혼용하며 컬렉션을 쓴다면 주의해야 한다.
    - 코틀린에서 null 불가능하거나 수정 불가능이라 하더라도, 자바에서 nullable하거나 수정할 수 있다.
- 자바에서 선언한 컬렉션은 코틀린에서 플랫폼 타입으로 보임
  - 플랫폼 타입의 컬렉션은 코틀린에서 읽기 전용 컬렉션 혹은 변경 가능한 컬렉션 어느 쪽으로도 취급할 수 있다.
  - 주의할 점
    - 컬렉션 자체가 null이 될 수 있는가?
    - 컬렉션의 원소가 null이 될 수 있는가?
    - 컬렉션이 수정 가능한가?
  - 자바 인터페이스나 클래스가 어떤 맥락에서 사용되는지 정확히 알아야 한다.
- 성능과 상호운용을 위해 객체의 배열이나 원시 타입의 배열을 만들기
  - 코틀린에서 배열의 타입을 표현하기 위한 제네릭을 사용한다. 따라서 그 타입 인자는 항상 객체다. (원시 타입일 수 없다.)
  - 원시 타입의 배열을 표현하기 위한 별도 클래스가 있다. ({원시타입명}Array)
    - ex. IntArray, ByteArray ...
    - 이는 제네릭을 사용한 배열과 다르게 박싱하지 않는다.
  - 코틀린에서는 배열에도 컬렉션의 확장 함수가 있다. (`map`, `filter` ...)
    - 다만 반환타입은 `List`임을 유의하라.

## PART 2. 코틀린을 코틀린답게 사용하기

## 9장. 연산자 오버로딩과 다른 관례

- Convention: 코틀린에서 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 것
  - ex. plus 함수는 + 연산자로 사용할 수 있다.

### 9.1 산술 연산자를 오버로드해서 임의의 클래스에 대한 연산을 더 편리하게 만들기
- 연산자를 오버로드하려면 `operator` 키워드를 붙인다.
- 확장함수로도 연산자 오버로드가 가능하다.
- 코틀린에서 미리 정한 연산자만 오버로드 할 수 있다.
- 이항 연산에 필요한 두 인자가 같은 타입일 필요는 없다.
  - 이럴 경우 교환법칙(`a op b == b op a`)이 적용되지 않을 수 있다.
  - 서로 다른 타입에 각각 연산자 오버로드를 통해 교환법칙을 성립하게 만들 수 있다.
- 이항 연산자 종류
  - `+`: plus
  - `-`: minus
  - `*`: times
  - `/`: div
  - `%`: mod
- 기타
  - 자바의 비트 연산자는 코틀린에 없다. 다만, 대응되는 기능을 가진 중위 함수(infix fun)이 존재한다.
- 이항 연산자를 오버로드하면, 복합 대입 연산자를 지원한다.
  - ex) `plus`를 오버로드하면, `+=`도 자동으로 함께 오버로드된다.
- 복합 대입 연산자를 따로 오버로드 하고 싶다면, `{연산}Assign` 등의 함수를 오버로드하면 된다.
  - `plusAssign`, `minusAssign`, `timesAssign` ...
- 일반적으로 이항 연산자와 복합 대입 연산자를 동시에 정의하는 것을 지양한다.
- 단항 연산자도 오버로드할 수 있다.
- 단항 연산자 종류
  - `+`: unaryPlus
  - `-`: unaryMinus
  - `!`: not
  - `++`: inc
  - `--`: dec

### 9.2 비교 연산자를 오버로딩해서 객체들 사이의 관계를 쉽게 검사
- `equals`: `==`, `!=`
  - `==`는equals 호출과 null 검사로 컴파일 된다.
    - `a == b` -> `a?.equals(b) ?: (b == null)`
  - `===`는 두 피연산자가 서로 같은 객체를 가르키는지(동등성)를 비교한다.
    - `===`는 오버로딩할 수 없다.
  - `Any` 클래스에서 `operator` 키워드가 붙기 때문에, 하위 클래스에서는 `override`만 붙이면 된다.
- 순서 연산자: `compareTo`
  - 한 객체와 다른 객체의 크기를 비교해 정수로 나타냄.
  - 코틀린은 비교 연산자(<, >, <=, >=)를 `compareTo`로 컴파일한다.
  - `p1 < p2` 는 `p1.compareTo(p2) < 0`과 같다.
  - `Comparable`에 `operator`가 붙어있으므로, 상속하는 클래스에서는 `override`만 붙인다.
  - `compareValuesBy`: 두 객체와 여러 비교 함수(람다 혹은 메서드 참조)를 인자로 받는다.
  - 필드를 직접 비교하면 코드는 좀 더 복잡해지지만 비교 속도는 훨씬 더 빨라진다.

### 9.3 컬렉션과 범위에 대해 쓸 수 있는 관례
- `[]`: get과 set
  - 인덱스 접근 연산자 `a[b]`는 get 연산
  - 인덱스 접근 연산자에 값을 대입하면 set 연산
  - `operator fun get(...)`으로 함수를 정의하면, `[]`를 통해 원소를 접근할 수 있다.
  - `operator fun set(...)`으로 함수를 정의하면, `[]`를 통해 원소를 대입할 수 있다.
    - set이 받는 마지막 파라미터 값이 대입 연산자의 오른쪽, 나머지 파라미터 값은 인덱스 연산자에 들어간다.
- `in`
  - 원소가 컬렉션이나 범위에 속하는지 검사(contains 메서드)
  - 컬렉션에 있는 원소를 이터레이션 할 때 사용
- `..`: 범위 만들기
  - `rangeTo` 메서드를 정의해 `..`(시작과 끝 포함) 범위를 만들 수 있다.
  - `rangeUntil` 메서드를 정의해 `..<`(시작 포함, 끝 제외) 범위를 만들 수 있다.
  - rangeTo나 rangeUntil은 연산 우선순위가 낮다.
- iterator 관례
  - for 루프는 `in` 연산자를 사용한다.
  - 이때의 `in`은 `iterator()`를 호출한다음, `hasNext`와 `next` 호출을 반복하는 식으로 변환된다.
  - `iterator` 메서드를 확장 함수로 정의해도 사용할 수 있다.

### 9.4 `component` 함수를 사용해 구조 분해 선언 제공
- 구조 분해 선언(destructuring declaration)
  - 복합적인 값을 분해해서 별도의 여러 지역 변수를 한꺼번에 초기화할 수 있다.
- 구조 분해 선언의 각 변수를 초기화하고자 `componentN`이라는 함수를 호출한다.
  - `N`은 구조 분해 선언에 있는 변수 위치에 따라 붙는 번호
- data class의 주 생성자에 들어있는 프로퍼티에 대해서 컴파일러가 자동으로 `componentN` 함수를 만든다.
- 함수에서 여러 값을 반환할 때 유용
- 배열과 컬렉션도 구조 분해 선언을 할 수 있다.
  - 코틀린 표준 라이브러리는 컬렉션의 맨 앞 다섯 원소에 대한 `componentN` 메서드를 제공한다.
- `Pair`나 `Triple` 클래스를 사용한면 더 단순하게 사용할 수 있다.
  - 다만, 그 안에 담겨있는 원소의 의미를 말해주지 않으므로 표현력을 잃게 된다.
- 변수 선언이 들어갈 수 있는 장소라면 어디든 구조 분해 선언을 사용할 수 있다.
- 컴포넌트가 여럿 있는 객체에 대해 구조 분해 선언을 사용할 때, 변수 중 일부가 필요가 없을 경우
  - 변수 이름을 `_`로 할 수 있다.
  - 구조 분해 선언에서 뒤쪽의 구조 분해 선언은 생략할 수 있다.
- 구조 분해 선언 구현은 위치에 의한 것이다. 즉, 구조 분해 연산의 결과가 오직 인자의 위치에 따라 결정된다.
  - 변수의 이름은 중요하지 않다. 그래서 순서를 유의하지 않으면 의도와 다르게 할당 될 수 있다.
  - 복잡한 엔티티에 대해 구조 분해 선언의 사용을 가능한 한 피하라.

### 9.5 프로퍼티 접근자 로직 재활용: 위임 프로퍼티
- 위임 프로퍼티(delegated property)
  - 접근자 로직을 매번 재구현할 필요 없이 쉽게 구현할 수 있다.
  - 위임은 객체가 직접 작업을 수행하지 않고 다른 도우미 객체가 그 작업을 처리하도록 하는 디자인 패턴을 말한다.
    - 이 때 작업을 처리하는 도우미 객체를 위임 객체라고 부른다.
- `var p: Type by Delegate()`
  - p 프로퍼티는 접근자 로직은 다른 객체에 위임한다.
  - Delegate 클래스의 인스턴스를 위임 객체로 사용한다.
  - by 뒤에 있는 식을 계산해 위임에 쓰일 객체를 얻는다.
  - 컴파일러는 숨겨진 도우미 프로퍼티를 만들고 그 프로퍼티를 위임 객체의 인스턴스로 초기화한다.
  - p 프로퍼티는 바로 그 위임 객체에게 자신의 작업을 위임한다.
  ```kotlin
  class Foo {
    private val delegate = Delegate()

    var p: Type
      set(value: Type) = delegate.setValue(..., value)
      get() = delegate.getValue(...)
  }
  ```
  - Delegate 클래스는
    - `getValue`와 `setValue` 메서드를 제공해야 한다.
      - 변경 가능한 프로퍼티만 `setValue`를 사용한다.
    - `provideDelegate`는 선택적으로 구현할 수 있다. 이 함수는 최초 생성 시 검증 로직을 수행하거나 위임이 인스턴스화 되는 방식을 변경할 수 있다.
    - 이런 함수들은 멤버/확장 함수 모두 가능하다.
- `by lazy()`를 사용한 지연 초기화
  - 지연 초기화(lazy initialization)란, 객체의 일부분을 초기화하지 않고 남겨뒀다가 실제로 그 부분의 값이 필요할 경우 초기화할 때 쓰이는 패턴이다.
    - 초기화 과정에서 자원을 많이 사용하거나 객체를 사용할 때마다 꼭 초기화하지 않아도 되는 프로퍼티에 대해 지연 초기화 패턴을 사용할 수 있다.
  - backing property
    - 클래스에서 같은 개념을 표현하는 프로퍼티를 2개 사용하고, 비공개 프로퍼티 앞에 `_`을 붙인다.
  - `lazy { /* getValue 메서드 */ }`
    - 인자는 값을 초기화할 때 호출할 람다.
    - lazy 함수는 thread-safe
    - 필요하면 동기화에 필요한 락을 lazy 함수에 전달할 수도 있고, 다중 스레드 환경에서 사용하지 않을 프로퍼티를 위해 lazy 함수가 동기화를 생략하게 할 수도 있다.
- 위임 프로퍼티 구현
  - `getValue`와 `setValue`를 구현한다. 이 함수들 앞에는 `operator`가 붙는다.
  - 이 함수들은 파라미터 2개를 받는다.
    - `thisRef: Any?`: 설정하거나 읽을 프로퍼티가 들어있는 인스턴스
    - `porp: KProperty<*>`: 프로퍼티를 표현하는 객체
  - `by` 오른쪽에 있는 식이 꼭 새 인스턴스를 만들 필요는 없다. 함수 호출, 다른 프로퍼티, 다른 식이 `by` 오른쪽에 올 수 있다.
    - 다만, 오른쪽 식을 계산한 결과인 객체는 컴파일러가 호출할 수 있는 올바른 타입의 `getValue`와 `setValue`를 반드시 제공해야 한다.
- 위임 프로퍼티는 커스텀 접근자가 있는 감춰진 프로퍼티로 변환된다.
  - Map/MutableMap 인터페이스는 getValue/setValue 확장 함수가 있어 위임을 지원한다.
  - Exposed 프레임워크에서 DB에 대한 Entity 컬럼을 위임으로 표현한다.

## 10장. 고차 함수: 람다를 파라미터와 반환값으로 사용

### 10.1 다른 함수를 인자로 받거나 반환하는 함수 정의: 고차 함수
- 람다를 인자로 받는 함수를 정의하려면, 함수 타입은 람다의 파라미터 타입과 반환 타입을 지정한다.
  - 방법
    - 함수 파라미터의 타입을 괄호 안에 넣고,
    - 화살표를 추가한 다음,
    - 함수의 반환 타입을 지정한다.
  - ex. `val someMethod: (Int?, String) -> Unit = ...`
  - 반환타입의 `Unit`은 생략할 수 없다.
- 인자로 전달 받은 함수 호출
  - 일반 함수와 같이, 함수 이름 뒤에 괄호를 붙이고 괄호 안에 원하는 인자를 콤마(,)로 구분한다.
  ```kotlin
    fun calculate(operation: (Int, Int) -> Int) {
      return operation(1, 2)
    }
  ```
  - 파라미터 타입에도 이름을 설정할 수 있지만, 활용할 때 그 이름이 강제되지는 않는다.
  ```kotlin
    fun calculate(operation: (first: Int, second: Int) -> Int) {
      return operation(1, 2)
    }

    fun main() {
      calculate { x, y -> x + y }
      calculate { a, b -> a * b }
    }
  ```
  - 예시
  ```kotlin
    fun String.filter(predicate: (Char) -> Boolean): String {
      return buildString {
        for (char in this) {
          if (predicate(char)) append(char)
        }
      }
    }

    fun main() {
      "asdqwezxc".filter { it in 'a'..'n' }
    }
  ```
- 자바에서 코틀린 람다를 사용할 수 있다.
  - 다만, `Unit`을 반환하는 함수의 경우 자바에서 `Unit.INSTANCE`를 명시적으로 반환해야 한다. (`void`를 반환할 수 없다.)
- 컴파일 시, 내부적으로 `FunctionN` 인터페이스를 만들어 활용한다. (N은 인자 개수)
  - 해당 인터페이스에는 `operator fun invoke()`가 선언되어 있다.
  - 파라미터 개수 제한 없이 원하는 만큼 파라미터를 사용하는 함수에 대한 인터페이스를 사용할 수 있다.
- 함수 타입 선언 시, 기본값을 지정할 수 있다.
  - 다른 디폴트 파라미터 값과 마찬가지로 함수 타입에 대한 기본값 선언도 = 뒤에 람다를 넣으면 된다.
  - 예시
  ```kotlin
    fun <T> Collection<T>.joinToString(
      separator: String = ",",
      prefix: String = "",
      postfix: String = "",
      transform: (T) -> String = { it.toString() }	
    ): String {
      val result = StringBuilder(prefix)
      
      for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(separator)
        result.append(transform(element))
      }

      result.append(postfix)
      return result.toString()
    }
  ```
- 함수에서 함수를 반환할 수도 있다. (생각보다 많이 쓰이지는 않는다.)
- 람다를 활용해 중복을 줄여 코드 재사용성을 높일 수 있다.
  - 람다는 반복적인 행동을 추출할 수 있다.
  ```kotlin
    fun List<SiteVisit>.avgDurationFor(predicate: (SiteVisit) -> Boolean) = 
      filter(predicate).map(SiteVisit::duration).average()

    // 활용
    list.avgDurationFor { it.os in setOf(OS.IOS, OS.ANDROID) }
    list.avgDurationFor { it.os == OS.IOS && it.path == "/signup" }
  ```

### 10.2 인라인 함수를 사용해 람다의 부가 비용 없애기
- 보통 람다는 익명 클래스로 컴파일된다. 이는 부가 비용이 추가된다.
  - 람다 식마다 새로운 클래스가 생긴다.
  - 람다가 변수를 캡처한 경우 람다 정의가 포함된 코드를 호출하는 시점마다 새로운 객체가 생긴다.
- 따라서 람다를 사용하는 구현은 똑같은 코드를 직접 실행하는 함수보다 덜 효율적이다.
#### 10.2.1 인라이닝이 작동하는 방식
- `inline`을 함수에 붙이면 컴파일러는 그 함수가 쓰이는 위치에 함수 호출을 생성하는 대신, 함수를 구현하는 코드로 바꿔치기 해준다.
#### 10.2.2 인라인 함수의 제약
- 모든 함수를 인라이닝을 할 수는 없다.
- 인라인 함수의 본문에서 람다식을 바로 호출하거나 다른 인라인 함수의 인자로 전달하는 경우에는 인라이닝할 수 있다. 그 외에는 컴파일 에러가 난다.
- 둘 이상의 람다를 인자로 받는 함수에서 일부 람다만 인라이닝하고 싶다면, 인라이닝 하면 안 되는 람다의 파라미터 이름 앞에 `noinline` 키워드를 붙여 인라이닝을 금지할 수 있다.
#### 10.2.3 컬렉션 연산 인라이닝
- 컬렉션 함수는 대부분 인라인 함수이다.
  - 연쇄적으로 사용할 경우, 중간 연산 결과물(리스트)가 생성된다.
- 중간 결과물을 만들지 않기 위해, `asSequence()`를 붙여 시퀀스로 처리할 수 있다.
  - 다만, 시퀀스 함수는 인라인이 아니기 때문에 람다를 컴파일 했을 때 익명 객체가 생긴다.
  - 따라서 성능의 이유로 무조건 시퀀스로 변환해서는 안 된다.
  - 시퀀스가 의미 있을 때는 컬렉션의 크기가 클 때 뿐이다.
#### 10.2.4 언제 함수를 인라인으로 선언할지 결정
- `inline`키워드는 람다를 인자로 받는 함수만 성능이 좋아질 가능성이 높다.
  - 인라이닝을 통해 없앨 수 있는 부가 비용이 상당하다.
    - 함수 호출 비용을 줄일 수 있다.
    - 람다를 표현하는 클래스와 람다 인스턴스에 해당하는 객체를 만들 필요도 없어진다.
  - JVM은 함수 호출과 람다를 인라이닝해줄 정도로 똑똑하지는 않다.
  - 인라이닝을 사용하면 일반 람다에서는 사용할 수 없는 몇 가지 기능을 사용할 수 있다.
    - non-local return
- 다만, `inline` 변경자를 함수에 붙일 때는 코드 크기에 주의해야 한다.
  - 인라이닝한 함수의 크기가 큰 경우 함수 본문에 해당하는 바이트코드를 모든 호출 지점에 복사해 넣으면 바이트코드가 전체적으로 아주 커질 수 있다.
  - 그럴 경우 람다 인자와 무관한 코드를 별도의 비인라인 함수로 빼낼 수 있다.
  - 코틀린 표준 라이브러리가 제공하는 인라인 함수들은 모두 크기가 아주 작다.
#### 10.2.5 withLock, use, useLines로 자원 관리를 위해 인라인된 람다 사용
- `withLock`: 락을 획득 후 작업하고, 락을 해제하는 함수
  ```kotlin
      val l. Lock = ReentrantLock()
      l.withLock{
           // 락에 의해 보호되는 자원 사용
      }
  
      fun <T> Lock.withLock(action: () -> T): T {
          lock()
          try {
              return action()
          } finally {
              unlock()
          }
      }
  ```
- `use`: 닫을 수 있는(Closable을 구현한 객체)에 대해 호출하는 인라인 확장 함수
  - 람다를 호출하고 사용 후 자원이 확실히 닫히게 한다. 람다가 정상적으로 끝났는지 예외를 던졌는지 관계 없다.
  - 코틀린에서는 `try-with-resources`가 없다. 코틀린에서는 `use` 함수가 있기 때문이다.
  ```kotlin
      fun readFirstFromFile(fileName: String): String {
          BufferedReader(FileReader(fileName))
              .use { br -> return br.readLine() }
      }
  ```
- `useLines`: `File`과 `Path`에 대해 정의돼 있고, 람다가 문자열 시퀀스에 접근한다.
  ```kotlin
      fun readFirstLineFromFile(fileName: String): String {
          Path(fileName).useLines {
              return it.first()
          }
      }
  ```

### 10.3 람다에서 변환: 고차 함수에서 흐름 제어
#### 10.3.1 람다 안의 return 문: 람다를 둘러싼 함수에서 반환
- 인라인 함수의 람다 안에서 `return`을 사용하면 람다에서만 반환되는 것이 아니라, 그 람다를 호출하는 함수가 실행을 끝내고 반환된다. 이를 비지역적 return(non-local return)이라고 한다.
- 인라이닝되지 않은 함수에 전달되는 람다 안에서 `return`을 사용할 수 없다.
#### 10.3.2 람다로부터 반환: 레이블을 사용한 `return`
- 람다 안에서 지역적 `return`은 `for` 루프의 `break`과 비슷한 역할을 한다. 람다의 실행을 끝내고 람다를 호출했던 코드의 실행을 계속 이어간다. 이를 비지역적 `return`과 구분하기 위해 레이블을 사용해야 한다.
  - `return`으로 실행을 끝내고 싶은 람다식 앞에 레이블을 붙이고, `return` 키워드 뒤에 그 레이블을 추가한다.
  ```kotlin
      // 람다에 레이블을 붙이는 경우
      fun lookFor(people: List<Person>) {
          people.forEach someLabel@{
              if (it.name != "Alice") return@someLabel
              print("Found!")
          }
      }
      
      // 람다에 레이블이 없는 경우
      fun lookFor(people: List<Person>) {
          people.forEach {
              if (it.name != "Alice") return@forEach
              print("Found!")
          }
      }
  ```
- 람다식의 레이블을 명시하면 함수 이름을 레이블로 사용할 수 없다.
- 람다식에는 레이블이 2개 이상 붙을 수 없다.
- `this`도 똑같은 방법으로 사용할 수 있다.
#### 10.3.3 익명 함수: 기본적으로 로컬 `return`
- 익명함수는 람다식을 작성하는 다른 문법적 형태이다. 그러나 `return` 쓰임새에서 차이가 있다.
  - 익명 함수의 `return` 익명 함수 자체 반환한다.
  - 람다의 `return`은 람다를 감싼 바깥 함수를 반환시킨다.

## 11장. 제네릭스

### 11.1 타입 인자를 받는 타입 만들기: 제네릭 타입 파라미터
- 제네릭을 사용하면 타입 파라미터를 받는 타입을 정의할 수 있다.
- 제네릭 타입의 인스턴스가 만들어질 때는 타입 파라미터를 구체적인 타입 인자로 치환한다.
- 코틀린 컴파일러는 보통 타입과 마찬가지로 타입 인자도 추론할 수 있다.
  - 빈 리스트를 만들 때는 타입 인자를 추론할 근거가 없기 때문에 직접 타입 인자를 명시해야 한다.
- 코틀린은 raw type을 지원하지 않는다.
  - ex. `ArrayList()`는 선언할 수 없다. `ArrayList<Int>()`처럼 반드시 타입 인자가 있어야 한다.
#### 11.1.1 제네릭 타입과 함께 동작하는 함수와 프로퍼티
- 모든 타입을 다룰 수 있도록 하기 위해 제네릭을 사용한다.
- 제네릭 함수를 호출할 때는 반드시 구체적 타입으로 타입 인자를 넘겨야 한다.
- 멤버 메서드, 최상위 함수, 확장 함수에서 타입 파라미터를 선언할 수 있다.
- 확장 프로퍼티만 제네릭으로 선언할 수 있다.
  - ex.
  ```kotlin
    val <T> List<T>.first: T
      get() = this[0]
  ```
  - 일반 프로퍼티는 타입 파라미터를 가질 수 없다.
    - 여러 타입의 값을 클래스에 저장할 수 없기 때문이다.
#### 11.1.2 제네릭 클래스를 `<>`을 사용해 선언한다.
- 클래스/인터페이스 이름 뒤에 `<T>`와 같이 붙이면 제네릭을 만들 수 있다.
  - 본문 안에서 타입 파라미터를 다른 일반 타입처럼 사용할 수 있다.
  - ex. `interface List<T>`
- 제네릭 클래스/인터페이스를 확장하는 클래스를 정의하려면 기반 타입의 제네릭 파라미터에 대해 타입 인자를 지정해야 한다. 구체 타입도 되고, 타입 파라미터를 그대로 사용할 수도 있다.
  - ex. `class StringList : List<String>`
  - ex. `class ArrayList<T> : List<T>`
#### 11.1.3 제네릭 클래스나 함수가 사용할 수 있는 타입 제한: 타입 파라미터 제한
- 타입 파라미터 제한(type parameter constraint)
  - 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능
  - 어떤 타입을 제네릭 타입의 타입 파라미터에 대한 상계(upper bound)로 지정하면  타입인자는 반드시 그 상계 타입이거나 그것의 하위 타입이어야 한다.
  - ex. `fun <T : Number> List<T>.sum(): T` 상위 타입이 Number인 타입만 사용 가능하다.
  - 상계 타입을 정하면, 그 타입을 상계 타입의 값으로 취급할 수 있다. 메서드를 호출할 수 있다.
```kotlin
  // 타입 파라미터를 제약하는 함수 선언
  fun <T : Comparable<T>> max(first: T, seconde: T): T {
    return if (first > second) first else second
  }
  
  // 타입 파라미터에 둘 이상의 제약을 가해야 하는 경우
  fun <T> ensureTrailingPeriod(seq: T) where T : CharSequence, T : Appendable {
    if (!seq.endWith('.')) {
      seq.append('.')
    }
  }
```
#### 11.1.4 명시적으로 타입 파라미터를 널이 될 수 없는 타입으로 표시해서 널이 될 수 있는 타입 인자 제외시키기
- 아무런 상계를 정하지 않은 타입 파라미터는 `Any?`를 상계로 정한다.
- 널이 될 수 없는 타입만 사용하고 싶다면 최소한 상계로 `Any`를 명시해야 한다.
- 널을 허용하는 타입 파라미터를 사용하되, 특정 메서드에서는 널이 될 수 없음을 보장하고 싶다면, `t: T & Any` 등으로 표현한다.

### 11.2 실행 시점 제네릭스 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터
- 제네릭은 실행 시점에 인스턴스의 타입 인자 정보가 들어가지 않는다. 이를 타입 소거(type erasure)라고 한다.
#### 11.2.1 실행 시점에 제네릭 타입 클래스의 타입 정보를 찾을 때 한계: 타입 검사와 캐스팅
- 코틀린 제네릭 정보도 런타임에 지워진다. 실행 시점에서 어떤 타입의 원소를 저장하는지 알 수 없다.
- 실행 시점에는 타입 인자를 검사할 수 없다.
- 타입 소거는 저장해야 하는 타입 정보의 크기를 줄여 애플리케이션의 전체 메모리 사용량을 줄이는 장점이 있다.
- star projection: 인자를 알 수 없는 제네릭 타입을 표현할 때 쓴다. (ex. `List<*>`)
- 컴파일 시점에는 `is` 검사를 수행해 타입 캐스팅을 안전하게 할 수 있다.
#### 11.2.2 실체화된 타입 파라미터를 사용하는 함수는 타입 인자를 실행 시점에 언급할 수 있다.
- 인라인 함수의 타입 파라미터는 실체화된다. 즉 인라인 함수는 타입 인자를 알 수 있다.
- 어떤 함수에 `inline`을 붙이면 컴파일러는 그 함수를 호출한 식을 모두 함수를 구현하는 코드로 바꾼다.
  - 인라인 함수로 바꾸면 람다 코드를 위한 익명 클래스 객체가 생성하지 않아 성능이 더 좋아질 수 있다.
- `reified`로 지정하면 타입 파라미터의 타입을 실행 시점에도 알 수 있다.
```kotlin
  inline fun <reified T> Iterable<*>.filterIsInstance(): List<T> {
    val destination = mutableListOf<T>()
    for (element in this) {
      if (element is T) {
        destination.add(element)
      }
    }
    return destination
  }
```
- 인라인 함수에서만 실체화된 타입 인자를 쓸 수 있는 이유
  - 컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 그 함수가 호출되는 모든 지점에 삽입한다.
  - 컴파일러는 실체화된 타입 인자를 사용해 인라인 함수를 호출하는 각 부분의 정확한 타입 인자를 알 수 있다.
  - 따라서 컴파일러는 타입 인자로 쓰인 구체적인 클래스를 참조하는 바이트코드를 생성해 삽입할 수 있다.
  - 만들어진 바이트코드는 타입 파라미터가 아니라 구체적인 타입을 사용하므로 실행 시점에 벌어지는 타입 소거의 영향을 받지 않는다.
- 자바 코드에서 `reified`를 사용한 `inline` 함수를 호출할 수 없다.
- `inline`을 사용하는 이유는 실체화된 타입 파라미터를 사용하기 위함일수도 있다.
- 성능을 좋게 하려면 인라인 함수의 크기를 계속 관찰해야 한다. 함수가 커지면 실체화된 타입에 의존하지 않는 부분을 별도의 일반 함수로 뽑아내는 편이 낫다.
#### 11.2.3 클래스 참조를 실체화된 타입 파라미터로 대신함으로써 java.lang.Class 파라미터 피하기
- 코틀린의 `AClass::class.java`는 자바의 `AClass.class`와 같다.
```kotlin
// before
val serviceImpl = ServiceLoader.load(Service::class.java)

// after
val serviceImpl = loadService<Service>()

inline fun <reified T> loadService() {
  return ServiceLoader.load(T::class.java)
}
```
#### 11.2.4 실체화된 타입 파라미터가 있는 접근자 정의
- 제네릭 타입에 대해 프로퍼티 접근자를 정의하는 경우 프로퍼티를 `inline`으로 표시하고 타입 파라미털르 `reified`로 하면 타입 인자에 쓰인 구체적인 클래스를 참조할 수 있다.
```kotlin
inline val <reified T> T.canonical: String
  get() = T::class.java.canonicalName
```
#### 11.2.5 실체화된 타입 파라미터의 제약
- 할 수 있는 것
  - 타입 검사, 캐스팅 (`is/as`)
  - 코틀린 리플렉션 API(`::class`)
  - javaClass 접근 (`::class.java`)
  - 다른 함수를 호출할 때 타입 인자로 사용
- 할 수 없는 것
  - 인스턴스 생성
  - 동반 객체 메서드 호출
  - 실체화하지 않은 타입으로 실체화된 타입을 요구하는 함수 호출
  - 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 `reified`로 지정하는 것

### 11.3 변성은 제네릭과 타입 인자 사이의 하위 타입 관계를 기술
- 변성(variance)은 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념
  - `List<String>`과 `List<Any>`
#### 11.3.1 변성은 인자를 함수에 넘겨도 안전한지 판단하게 해준다.
#### 11.3.2 클래스, 타입, 하위 타입
- 어떤 타입 A의 값이 필요한 모든 장소에 어떤 타입 B의 값을 넣어도 아무 문제가 없다면 타입 B는 타입 A의 하위 타입이다.
  - 모든 타입은 자신의 하위 타입이다.
  - A타입이 B타입의 하위 타입이라면 B는 A의 상위 타입이다.
  - ex) Int는 Number의 하위 타입이다. Int는 Int의 하위 타입이다.
  - 널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입이다. 하지만 두 타입은 같은 클래스다.
- 서로 다른 두 타입 A와 B에 대해 `MutableList<A>`가 항상 `MutableList<B>`의 하위 타입도 아니고 상위 타입도 아닌 경우에, 제네릭 타입이 타입 파라미터에 대해 무공변(invariant)이라고 말한다.
  - 자바에서는 모든 클래스가 무공변이다.
- A가 B의 하위 타입이라면 `List<A>`는 `List<B>`의 하위 타입이다. 이를 공변적(covariant)라고 한다.
#### 11.3.3 공변성은 하위 타입 관계를 유지한다.
- 공변적인 클래스는 제네릭 클래스에 대해 A가 B의 하위 타입일 때 `List<A>`가 `List<B>`의 하위 타입인 경우를 말한다. 이를 "하위 타입 관계를 유지한다."라고 한다.
- 코틀린에서 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 이름 앞에 `out`을 넣어야 한다.
  - `interface List<out T>`
- 타입 파라미터를 공변적으로 만들면 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환값으로 사용할 수 있다.
- 타입의 위치
  - out: 함수의 반환 타입으로만 쓰일 수 있다.
  - in: 함수의 파라미터 타입에만 쓰일 수 있다.
  -  생성자 파라미터는 in/out 어느 쪽도 아니다.
- 타입 안정성을 위해 공변적 파라미터는 항상 out 위치에만 있어야 한다.
- val은 out에만 해당되며, var는 in/out 모두 해당된다.
- private 메서드의 파라미터는 in/out 모두 아니다.
  - 변성 규칙은 클래스 외부의 사용자가 클래스를 잘못 사용하는 일을 막기 위한 것이기 때문에, 클래스 내부 구현에는 적용되지 않는다.
#### 11.3.4 반공변성은 하위 타입 관계를 뒤집는다.
- 반공변성(contravariance)을 가진 클래스의 하위 타입 관계는 그 클래스의 타입 파라미터의 상하위 타입 관계와 반대다.
  - ex. `Comparator`
  ```kotlin
    interface Comparator<in T> {
      fun compare(e1: T, e2: T): Int
    }
  ```
  - T 타입의 값을 소비하기만 한다. 즉, T가 `in` 위치에서만 쓰인다. 따라서 T 앞에는 `in` 키워드가 붙는다.
- 타입 B가 타입 A의 하위 타입일 때, `Consumer<A>`가 `Consumer<B>`의 하위 타입인 관계가 성립한다면 제네릭 클래스는 타입 인자 T에 대해 반공변이다.
- `in` 키워드가 붙은 타입이 이 클래스의 메서드 안으로 전달돼 메서드에 의해 소비된다는 뜻이다.
  - 그 타입 인자를 오직 `in` 위치에서만 사용할 수 있다.
- 클래스나 인터페이스가 어떤 타입 파라미터에 대해서는 공변적이면서 다른 타입 파라미터에 대해서는 반공변적일 수 있다.
  ```kotlin
    interface Function1<in P, out R> {
      operator fun invoke(p: P): R
    }
  ```
#### 11.3.5 사용 지점 변성을 사용해 타입이 언급되는 지점에서 변성 지정
- 선언 지점 변성(declaration site variance)
  - 클래스를 선언하면서 변성을 지정하면 그 클래스를 사용하는 모든 장소에서 변성 지정자가 영향을 끼치므로 편리하다. (코틀린)
- 사용 지점 변성(use-site variance)
  - 타입 파라미터가 있는 타입을 사용할 때마다 그 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시 (자바)
  - 코틀린도 사용 지점 변성을 지원한다.
- ex.
```kotlin
  // 무공변 파라미터 타입을 사용하는 데이터 복사 함수
  fun <T> copyData(source: MutableList<T>, destination: MutableList<T>) {
    for (item in source) {
      destination.add(item)
    }
  }
  
  // 타입 파라미터가 둘인 데이터 복사 함수
  fun <T: R, R> copyData(source: MutableList<T>, destination: MutableList<R>) {
    for (item in source) {
      destination.add(item)
    }
  }
  
  // 아웃-프로젝션 타입 파라미터를 사용하는 데이터 복사 함수
  fun <T> copyData(source: MutableList<out T>, destination: MutableList<T>) {
    for (item in source) {
      destination.add(item)
    }
  }
```
- 타입 선언에서 타입 파라미터를 사용하는 위치라면 어디에나 변성 변경자를 붙일 수 있다.
- 인터페이스/클래스에서 선언한 변성은 사용할 때 매번 선언할 필요는 없다.
  - ex. List는 `List<out T>`라고 선언되어 있으므로, 사용할 때는 `List<T>`라고 써도 `out`이 적용된다.
#### 11.3.6 스타 프로젝션: 제네릭 타입 인자에 대한 정보가 없음을 표현하고자 * 사용
- 스타 프로젝션(star projection)
  - 원소 타입이 알려지지 않은 경우 사용
  - ex. `List<*>`
- `MutableList<*>`와 `MutableList<Any?>`의 차이
  - `MutableList<*>`: 어떤 정해진 구체적인 타입의 원소만을 담는 리스트지만, 그 원소의 타입을 정확히 모름을 의미
  - `MutableList<Any?>`: 모든 타입의 원소를 담을 수 있음을 의미
  -
  ```kotlin
    val list: MutableList<Any?> = mutableListOf('a', 1, "qwe")
    val chars = mutableListOf('a', 'b', 'c')
    val unknown: MutableList<*> = if (Random.nextBoolean()) list else chars

    unknown.add(42) // 컴파일 에러: 메서드 호출 금지
  ```
- 반공변 타입 파라미터에 대한 스타 프로젝션은 `<in Nothing>`과 같기 때문에, 사용할 수 없다.
  - 제네릭 클래스가 소비자 역할을 하는데, 정확히 어떤 대상을 소비할지 알 수 없다는 뜻이다.
  - ex. `Consumer<*>`
- 타입 인자에 대한 정보가 중요하지 않을 때 스타 프로젝션을 사용한다.
  - 파라미터를 시그니터에서 전혀 언급하지 않거나 데이터를 읽기는 하지만 구체적인 타입은 신경 쓰지 않을 때 스타 프로젝션을 쓴다.
- 스타프로젝션을 사용할 떄는 값을 만들어내는 메서드만 호출할 수 있고, 그 값의 타입에는 신경쓰지 말아야 한다.
- 스타 프로젝션을 쓰면서 안전한 타입 캐스팅하기
```kotlin
object Validator {
  private val validators = mutableMapOf<KClass<*>, FieldValidator<*>>()

  // 타입을 일치시키지 않고 바로 set하는 경우와 비교하면 더 안전하다.
  fun <T: Any> registerValidator(kClass: KClass<T>, fieldValidator: FieldValidator<T>) {
    validators[kClass] = fieldValidator
  }

  // get에 타입 검사 로직을 집어넣어 안전성을 높인다.
  @Suppress("UNCHECKED_CAST")
  operator fun <T: Any> get(kClass: KClass<T>): FieldValidator<T> = 
    validators[kClass] as? FieldValidator<T> ?: throw RuntimeException()
}

fun main() {
  Validators.registerValidator(String::class, DefaultStringValidator)
  Validators.registerValidator(Int::class, DefaultIntValidator)
  Validators[String::class].validate("Kotlin")
  Validators[Int::class].validate(42)
}
```
#### 11.3.7 타입 별명
- 타입 별명은 기존 타입에 대해 다른 이름을 부여한다.
- `typealias` 키워드 뒤에 별명을 적어 타입 별명 선언을 할 수 있다.
- 코드를 더 쉽게 이해하기 위해 함수형 타입에 새로운 맥락을 부여할 수 있다.
- 다만, 실제로 이해하기 더 쉬워지는지는 득실을 따져봐야 한다.
- 타입 별명은 컴파일 시 원래 타입으로 치환된다. 따라서 타입 안정성을 더 높여주지는 않는다.
- 최소한의 부가 비용으로 타입 안정성을 추가하는 것이 목적이라면 인라인 클래스를 사용하라.


## 12장. 어노테이션과 리플렉션
- 어노테이션: 라이브러리가 요구하는 의미를 클래스에 부여
- 리플렉션: 실행 시점에 컴파일러 내부 구조를 분석

### 12.1 어노테이션 선언과 적용
- 어노테이션을 사용하면 선언에 추가적인 메타데이터를 연관시킬 수 있다.
- 어노테이션이 설정된 방식에 따라 메타데이터를 소스코드, 컴파일된 클래스 파일, 런타임에 대해 작동하는 도구를 통해 접근할 수 있다.
#### 12.1.1 어노테이션을 적용해 선언에 표지 남기기
- 어노테이션을 적용하려면 `@`와 어노테이션 이름을 선언 앞에 넣으면 된다.
- 어노테이션의 인자
  - 기본 타입의 값, 문자열, 이넘, 클래스 참조(`A::class`), 다른 어노테이션 클래스(`@`를 사용하지 않음), 배열(`[]` 안에 표현)
  - 임의의 프로퍼티를 인자로 사용할 수 없다. 프로퍼티를 어노테이션 인자로 사용하려면 그 앞에 `const`를 붙여야 한다.
    - `const`가 붙은 프로퍼티를 컴파일 시점 상수로 취급한다.
#### 12.1.2 어노테이션이 참조할 수 있는 정확한 선언 지정: 어노테이션 타깃
- 사용 지점 타깃(user-site target) 선언을 통해 어노테이션을 붙일 요소를 정할 수 있다.
- 사용 지점 타깃(use-site target) 선언을 통해 어노테이션을 붙일 요소를 정할 수 있다.
  - ex. 자바에서 함수나 프로퍼티를 사용하는 방법을 변경하고 싶을 때 JvmName 어노테이션을 사용한다.
  ```kotlin
      class Example {
          @get:JvmName("getter")
          @set:JvmName("setter")
          var name: String = "EXAMPLE"
      }
  ```
  - 종류
    - property, field, get, set, receiver, param, setparam, delegate, file
- 자바에 선언된 어노테이션을 사용해 프로퍼티에 붙이면, 기본적으로 프로퍼티의 필드에 그 어노테이션이 붙는다.
- 코틀린으로 어노테이션을 선언하면 프로퍼티에 직접 적용할 수 있는 어노테이션을 만들 수 있다.
- 클래스/함수 선언이나 타입만 사용할 수 있는 자바와 달리, 코틀린에서는 어노테이션 인자로 클래스/함수 선언이나 타입 외의 임의의 식을 허용한다.
  - ex. `@Suppress`: 컴파일러 경고 무시
#### 12.1.3 어노테이션을 활용해 JSON 직렬화 제어 (예시 - jkid)
- 살펴볼 기능
  - `@JsonExclude`: 직렬화/역직렬화를 무시하는 프로퍼티 표시
  - `@JsonName`: 프로퍼티를 표현하는 키 값을 임의의 문자열로 표현
#### 12.1.4 어노테이션 선언
- `class` 키워드 앞에 `annotation`을 붙인다.
  ```kotlin
      annotation class JsonExclude
  ```
- 어노테이션 클래스는 선언이나 식과 관련 있는 메타데이터의 구조만 정의하기 때문에 내부에 아무 코드도 들어있을 수 없다. 따라서 본문을 정의할 수 없다.
- 파라미터가 있는 어노테이션을 정의하려면 어노테이션 클래스의 주 생성자에 파라미터를 선언해야 한다.
  - 모든 파라미터를 `val`로 선언해야 한다.
  ```kotlin
      annotation class JsonName(val name: String)
  ```
- 자바 어노테이션과 비교
  - `value` 라는 메서드가 기본적으로 있다.
  - 어노테이션을 적용할 때, `value`를 제외한 모든 애트리뷰트에는 이름을 명시해야 한다.
  - 코틀린은 어노테이션의 인자 이름을 명시해도 되고, 생략해도 된다.
#### 12.1.5 메타어노테이션: 어노테이션을 처리하는 방법 제어
- 메타어노테이션(meta-annotation): 어노테이션 클래스에 적용하는 어노테이션
  - 컴파일러가 어노테이션을 처리하는 방법을 제어한다.
- `@Target`
  - 어노테이션을 적용할 수 있는 요소의 유형을 지정한다.
  - `@Target`을 지정하지 않으면 모든 선언에 적용할 수 있는 어노테이션이 된다.
  - 메타 어노테이션을 만들어야 한다면 `AnnotationTarget.ANNOTATION_CLASS`를 사용
  - `AnnotationTarget.PROPERTY`로 지정한 어노테이션을 자바 코드에서는 사용할  수 없다.
  ```kotlin
      @Target(AnnotationTarget.PROPERTY)
      annotation class JsonExclude
  ```
- `@Retention`
  - 어노테이션 클래스를 소스 수준에서 유지할지, .class 파일에 저장할지, 실행 시점에 리플렉션을 사용해 접근할 수 있게 할지 정하는 메타 어노테이션
  - 자바 컴파일러는 기본적으로 .class 파일에 저장한다. (그래서 런타임에는 사용할 수 없다.)
  - 대부분의 어노테이션은 런타임에도 사용할 수 있어야 하므로 코틀린의 기본값은 `RUNTIME`이다.
#### 12.1.6 어노테이션 파라미터로 클래스 사용
```kotlin
annotation class SomeAnnotation(val targetClass: KClass<out Any>)
```
#### 12.1.7 어노테이션 파라미터로 제네릭 클래스 받기
```kotlin
annotation class SomeAnnotation(val targetClass: KClass<out SomeClass<*>>)
```

### 12.2 리플렉션: 실행 시점에 코틀린 객체 내부 관찰
- 리플렉션
  - 실행 시점에 객체의 프로퍼티와 메서드에 접근할 수 있게 해주는 방법
  - 타입과 관계없이 객체를 다뤄야 하거나 객체가 제공하는 메서드나 프로퍼티 이름을 오직 실행 시점에만 알 수 있는 경우 사용
#### 12.2.1 코틀린 리플렉션 API: `KClass`, `KCallable`, `KFunction`, `KProperty`
- `KClass`
  - 클래스 안에 있는 모든 선언을 열거하고 각 선언에 접근하거나 클래스의 상위 클래스를 얻는 등의 작업이 가능하다.
  - `SomeClass::class` 형식으로 KClass의 인스턴스를 얻을 수 있다.
- `KCallable`
  - 함수와 프로퍼티를 아우르는 공통 상위 인터페이스
  - 그 안에 `call` 메서드가 있으며, 이를 사용해 함수나 프로퍼티의 getter를 호출할 수 있다.
    - `call`에는 함수 인자를 vararg 로 받는다.
    - `call`은 함수 인자가 선언한 것과 정확히 동일해야 한다.
  ```kotlin
      fun foo(x: Int) = println(x)

      fun main() {
          val kFunction = ::foo
          kFunction.call(42)
      }
  ```
- `KFunctionN : KCallable`
  - 컴파일러가 생성하는 합성 타입
  - `KFunctionN`은 `KFunction`을 확장한다.
  - N과 파라미터 개수가 같은 invoke를 추가로 포함한다.
- `KProperty : KCallable`
  - `call`은 프로퍼티의 getter를 호출한다.
  - 프로퍼티 값을 얻기 더 좋은 방법은 `get` 메서드를 사용하는 것이다.
  - 최상위 프로퍼티의 경우, 읽기 전용(val)은 `KProperty0`으로, 가변(var)은 `KMutableProperty0` 인터페이스의 인스턴스로 표현되며, 둘 다 인자가 없는 `get`메서드를 제공한다.
  - 멤버 프로퍼티는 `KProperty1`이나 `MutablePropery1` 인스턴스로 표현된다. 그 안에는 인자가 1개인 `get` 메서드가 들어있다.
    - `get` 메서드를 통해 프로퍼티 값을 얻으려면 값을 얻을 수신 객체 인스턴스를 넘겨야 한다.
  ```kotlin
      class Person(val name: String, val age: Int)

      fun main() {
          val person = Person("Alice", 29)
          val memberProperty = Person::age
          println(memberProperty.get(person))
      }
  ```
- 최상위 수준이나 클래스 안에 정의된 프로퍼티만 리플렉션으로 접근할 수 있다.
  - 함수의 로컬 변수에는 접근할 수 없다.
#### 12.2.2 리플렉션을 사용해 객체 직렬화 구현
```kotlin
// StringBuilder 확장함수로 구현하는 이유는, `append`와 같은 메서드를 간결하게 호출하기 위함.
private fun StringBuilder.serializeObject(obj: Any) {
	val kClass = obj::class as KClass<Any>
	val properties = kClass.memberProperties

	properties.joinToStringBuilder(
		this,
		prefix = "{",
		postfix = "}",
	) { prop -> // prop의 타입은 KProperty1<Any, *>
		serializeString(prop.name)
		append(": ")
		serializePropertyValue(prop.get(obj)) // prop.get(obj) 타입은 Any?
	}
}
```
#### 12.2.3 어노테이션을 활용해 직렬화 제어
- 프로퍼티에 선언된 어노테이션을 접근하려면, `KProperty`의 `annotations` 프로퍼티 혹은 `findAnnotation()` 메서드를 사용할 수 있다.
```kotlin
// 프로퍼티 필터링을 포함하는 객체 직렬화
private fun StringBuilder.serializeObject(obj: Any) {
	(obj::class as KClass<Any>)
		.memberProperties
		.filter { it.findAnnotation<JsonExclude>() == null }
		.joinToStringBuilder(this, prefix = "{", postfix = "}") {
			serializeProperty(it. obj)
		}
}

// 하나의 프로퍼티 직렬화하기
private fun StringBuilder.serializeProperty(
	prop: KProperty1<Any, *>, obj: Any
) {
	val jsonNameAnn = prop.findAnnotation<JsonName>()
	val propName = jsonNameAnn?.name ?: prop.name
	serializeString(propName)
	append(": ")
	val value = prop.get(obj)
	val jsonValue = prop.getSerializer()?.toJsonValue(value) ?: value
	serializePropertyValue(jsonValue)
}

// 프로퍼티의 값을 직렬화하는 직렬화기 가져오기
fun KProperty<*>.getSerializer(): ValueSerializer<Any?>? {
	val customSerializerAnn = findAnnotation<CustomSerializer>()
		?: return null
	val serializerClass = customSerializerAnn.serializerClass
	val valueSerializer = serializerClass.objectInstance
		?: serializerClass.createInstance()
	@Suppress("UNCHECKED_CAST")
	return valueSerializer as ValueSerializer<Any?>
}
```
- 일반 클래스와 object 클래스는 모두 `KClass`로 표현된다.
  - 다만 object로 선언된 싱글턴 객체는 `objectInstance` 프로퍼티가 null이 아니다.
  - 일반 객체는 인스턴스에 접근하려면 `createInstance()`로 새 인스턴스를 만들어야 한다.
#### 12.2.5 callBy()와 리플렉션
- `KCallable.call`은 디폴트 파라미터를 지원하지 않는다. 따라서 디폴트 파라미터를 지원하는 `KCallable.callBy`를 사용해야 한다.
  ```kotlin
      interface KCallable<out R> {
          fun callBy(args: Map<KParameter, Any?>): R
      }
  ```
- `callBy` 메서드
  - 파라미터와 해당하는 값을 연결해주는 맵을 인자로 받는다.
  - 파라미터 순서를 지킬 필요가 없다.
  - 맵에 없으면 파라미터 기본값을 사용한다.
  - 최종적으로 객체의 주 생성자를 호출한다.
- `Ktype` 실행 시점의 표현을 얻으려면 `typeOf<T>()` 함수를 사용하면 된다.


## 13장. DSL 만들기
- 코틀린 DSL 설계는 코틀린 언어의 여러 특성을 활용
  - 1. 수신 객체 지정 람다
    - 코드 블록에서 이름(변수)이 가리키는 대상을 결정하는 방식을 변경해 DSL 구조를 더 쉽게 만든다.
  - 2. `invoke()` 관례
    - DSL 코드 안에서 람다와 프로퍼티 대입을 더 유연하게 조합

### 13.1 API에서 DSL로: 표현력이 좋은 커스텀 코드 구조 만들기
- DSL의 궁극적인 목표는 코드의 가독성과 유지 보수성을 가장 좋게 유지하는 것이다.
  - 개별 클래스에 집중하는 것뿐만 아니라, 다른 클래스와 상호작용하는 지점인 API를 살펴보아야 한다.
- 모든 개발자는 API를 훌륭하게 만들기 위해 노력해야 하낟.
- API가 깔끔하다는 의미
  - 1. 코드를 읽는 독자가 어떤 일이 벌어질지 명확하게 이해할 수 있어야 한다. 이름과 개념을 잘 선택한다.
  - 2. 코드에 불필요한 구문이나 번잡한 준비 코드가 가능한 한 적어야 한다.
    - DSL이 주로 초점을 맞추는 것도 이런 간결함이다.
  - 깔끔한 API는 언어에 내장된 기능과 거의 구분할 수 없다.
- 깔끔한 API를 위한 코틀린의 기능들: 확장 함수, 중위 함수 호출, 람다의 `it`, 연산자 오버로딩, `get` 등
#### 13.1.1 도메인 특화 언어
- DSL이란
  - 범용 프로그래밍 언어: 컴퓨터로 풀 수 있는 모든 문제를 충분히 풀 수 있는 기능을 제공
    - 명령적(imperative)이다.
      - 어떤 연산을 완수하기 위해 필요한 각 단계를 순서대로 정확히 기술
  - 도메인 특화 언어: 특정 과업 또는 영역(도메인)에 맞춰 그 영역에 필요하지 않은 기능을 제외
    - ex. SQL, 정규식
    - 스스로 제공하는 기능을 제한하여 오히려 더 효율적으로 자신의 목표를 달성
    - 선언적(declarative)이다.
      - 원하는 결과를 기술하기만 하고 그 결과를 달성하기 위해 필요한 세부 실행은 언어를 해석하는 엔진에 맡긴다.
      - 실행 엔진이 결과를 얻는 과정을 전체적으로 한꺼번에 최적화하기 때문에 선언적 언어가 더 효율적인 경우가 자주 있다.
- DSL은 큰 단점이 있는데, 범용 언어로 만든 호스트 애플리케이션과 DSL을 함께 조합하기 어렵다는 것이다.
  - 이를 해결하기 위해 코틀린은 코틀린 내부에서 DSL을 만들 수 있도록 설계되었다.
#### 13.1.3 DSL의 구조
- DSL의 특징은 구조(문법)이다. 그래서 언어라고 부를 수 있다.
- 전형적인 라이브러리는 여러 메서드로 이뤄지며 클라이언트는 그런 메서드를 한 번에 하나씩 호출함으로써 사용한다.
- 코틀린 DSL에서는 보통 람다를 내포시키거나 메서드 호출을 연쇄시키는 방식으로 구조를 만든다.

### 13.2 구조화된 API 구축: DSL에서 수신 객체 지정 람다 사용
#### 13.2.1 수신 객체 지정 람다와 확장 함수 타입
- 수신 객체 지정 람다를 사용하는 이유는, 람다에서 자기 자신에 대한 호출을 생략해서 표현하고자 함이다.
- 람다를 선언할 때, 일반 함수 타입 대신 확장 함수 타입을 사용하여 구현할 수 있다.
```kotlin
// 일반 람다
fun buildString(
	action: (StringBuilder) -> Unit
): String {
	val sb = StringBuilder()
	action(sb)
	return sb.toString()
}

// 활용
fun main() {
	val s = buildString {
		it.append("1")
		it.append("2")
	}
}

// 수신 객체 지정 람다
fun buildString(
	action: StringBuilder.() -> Unit
): String {
	val sb = StringBuilder()
	sb.action()
	return sb.toString()
}

// 활용
fun main() {
	val s = buildString {
		append("1")
		append("2")
	}
}
```
- 소스코드에서 수신 객체 지정 람다는 일반 람다와 똑같아 보인다.
  - 람다에 수신 객체가 있는지 알아보려면 그 람다가 전달되는 함수 시그니처를 살펴봐야 한다.
- 수신 객체 지정 람다가 다른 수신 객체 지정 람다 안에 들어가면 안쪽 람다에서 외부 람다에 정의된 수신 객체를 사용할 수 있다.
  - 이를 막기 위해 `@DslMarker` 어노테이션을 사용해 내포된 람다에서 외부 람다의 수신 객체에 접근하지 못하게 제한할 수 있다.
```kotlin
fun createSimpleTable() = createHTML().table {
	this@table.tr {
		(this.tr).td {
			 // this@table, this@tr, this@td 접근 가능
		}
	}
}
```
- 수신 객체 지정 람다를 사용하면 코드 블록 내부에서 이름 결정 규칙을 바꿀 수 있어 API에 구조를 추가할 수 있다.
  - 구조는 DSL과 평범한 메서드 호출 시퀀스를 구별하는 가장 큰 특징이다.
#### 13.2.3 코틀린 빌더: 추상화와 재사용을 가능하게 해준다.
- 코틀린 내부 DSL을 사용하면 일반 코드와 마찬가지로 반복되는 내부 DSL 코드 조각을 새 함수로 묶어 재사용할 수 있다.

### 13.3 `invoke` 관례를 사용해 더 유연하게 블록 내포시키기
- `invoke` 관례를 사용하면 함수처럼 호출할 수 있다.
  - 잘못사용하면 이해하기 어려운 코드가 될 수 있다.
#### 13.3.1 `invoke` 관례를 사용해 더 유연하게 블록 내포시키기
- `operator fun invoke(...)`를 정의하면 `SomeClass()` 같은 형식으로 사용할 수 있다.
- `invoke` 메서드 시그니처에 대한 요구 사항은 없다. 원하는 대로 파라미터 개수나 타입을 지정할 수 있다.
  - 오버로딩한 여러 시그니처를 모두 다 활용할 수 있다.
#### 13.3.2 DSL의 `invoke` 관례: 그레이들 의존관계 선언
- 내포된 블록 구조를 허용하는 한편, 평평한 함수 호출 구조도 함께 제공하는 API를 만들고 싶은 경우
```kotlin
class DependencyHandler {
	fun implementation(coordinate: String) { /* do something */}
	
	operator fun invoke(body: DependencyHandler.() -> Unit) {
		body()
	}
}

fun main() {
	val dependecies = DependencyHandler()

	dependencies.implementation("...")
	
	// dependencies 안에 람다를 받는 `invoke` 메서드를 정의하면 호출할 수 있다.
	// 완전히 풀어쓰면 dependencies.invoke({...})이 된다.
	dependencies {
		implementation("...")
	}	
}
```

### 13.4 실전 코틀린 DSL
#### 13.4.1 중위 호출 연쇄시키기: 테스트 프레임워크의 `should` 함수
- 깔끔한 DSL을 만들려면 코드에 쓰이는 기호의 수를 줄여야 한다.
- 중위 함수
```kotlin
// from kotest
infix fun <T> T.should(matcher: Matcher<T>) = matcher.test(this)
```
#### 13.4.3 멤버 확장 함수: SQL을 위한 내부 DSL
- 멤버 확장(member extension)
  - 클래스 안에서 확장 함수와 확장 프로퍼티를 선언
  - 선언된 클래스의 멤버인 동시에 그들이 확장하는 다른 타입의 멤버이기도 하다.
  - 클래스 영역 바깥에서는 멤버 확장 프로퍼티/메서드를 사용할 수 없다.
    - = 메서드/프로퍼티가 적용되는 범위를 제한할 수 있다.
    - = 각 함수를 사용할 수 있는 맥락을 제어할 수 있다.
- 예제: `Exposed`
```kotlin
class Table {
	// Table 클래스 또는 Table을 상속받은 클래스 내에서만 사용할 수 있다.
	fun Column<Int>.autoIncrement(): Column<Int>
}
```


## PART 3. 코루틴과 플로우를 활용한 동시성 프로그래밍

## 14. 코루틴
### 14.1 동시성과 병렬성
- 동시성은 여러 작업을 동시에 실행하는 것을 말한다. 코드를 여러 부분으로 나눠서 동시에 수행할 수 있는 능력이다.
- 병렬성은 여러 작업을 여러 CPU 코어에서 물리적으로 동시에 실행하는 것을 말한다.
- 코루틴을 사용하면 동시성 계산과 병렬성 계산을 모두 할 수 있다.

### 14.2 코틀린의 동시성 처리 방법: 일시 중단 함수와 코루틴
- 코틀린을 통해 비동기적으로 실행되는 넌블럭킹 동시성 코드를 우아하게 작성할 수 있다.
- 스레드보다 코루틴이 훨씬 더 가볍게 작동한다.
- 구조화된 동시성을 통해 코루틴은 동시성 작업과 그 생명주기를 관리할 수 있다.

### 14.3 스레드와 코루틴 비교
- 스레드
  - JVM에서 병렬 프로그래밍과 동시성 프로그래밍을 위한 고전적인 추상화
  - 서로 독립적으로 동시에 실행되는 코드 블록을 지정할 수 있다.
  - `thread { }` 함수를 통해 스레드를 편하게 사용할 수 있다.
  - JVM에서 생성하는 각 스레드는 일반적으로 운영체제가 관리하는 스레드이다. 이러한 시스템 스레드를 생성하고 관리하는 것은 비용이 많이 든다.
    - 시스템 스레드는 몇 메가바이트의 메모리를 할당 받는다.
    - 스레드 간 전환은 운영체제 커널 수준에서 실행된다.
  - 기본적으로 독립적인 프로세스로 존재한다. 작업을 관리하고 조정하는데 어렵다.
    - 특히 취소, 예외 처리 등
- 코루틴
  - 코틀린에서 스레드에 대한 대안으로 도입.
  - 코루틴은 일시 중단 가능한 계산을 나타낸다.
  - 코루틴은 초경량 추상화다.
    - 10만개 이상의 코루틴을 쉽게 실행할 수 있다.
    - 생성하고 관리하는 비용이 저렴하다.
  - 시스템 자원을 블록시키지 않고 실행을 일시 중단할 수 있다. 그리고 나중에 중단 지점에서 실행을 재개할 수 있다.
  - 구조화된 동시성(structured concurrency) 개념을 통해 동시 작업의 구조와 계층을 확립하며, 취소 및 오류 처리를 위한 메커니즘을 제공한다.
  - 내부적으로 하나 이상의 JVM 스레드에서 실행된다.

### 14.4 잠시 멈출 수 있는 함수: 일시 중단 함수
- 코틀린 코루틴이 다른 동시성(스레드 등) 접근 방식과 다른 핵심 속성은 코드 형태를 크게 변경할 필요가 없다는 점이다. 코드는 여전히 순차적으로 보인다.
#### 14.4.1 일시 중단 함수를 사용한 코드는 순차적으로 보인다.
- 함수에 `suspend` 키워드를 붙여 넌블로킹 방식으로 구현할 수 있다.
  - 함수가 실행을 잠시 멈출 수도 있다는 뜻이다.
  - 일시 중단은 기저 스레드(main thread)를 블록시키지 않는다.
  - 대신 함수 실행이 일시 중단되면 다른 코드가 같은 스레드에서 실행될 수 있다.
- 코드 구조를 변경하지 않았다는 점에 주목해야 한다.
  - 코드는 여전히 순차적으로 보이지만 블로킹 코드의 단점은 사라졌다.

### 14.5 코루틴을 다른 접근 방법과 비교
#### 14.5.1 일시 중단 함수 호출
- 일시 중단 함수는 실해을 일시 중단할 수 있기 때문에 일반 코드 아무 곳에서나 호출할 수 없다.
  - 일시 중단 함수는 실행을 일시 중단할 수 있는 코드 블록 안에서만 호출할 수 있다.
  - 그런 블록 중 하나가 다른 일시 중단 함수일 수 있다.
  - 일시 중단 코드가 아닌 코드에서 일시 중단 함수를 호출하려고 하면 오류가 발생한다.
- 코루틴 빌더 함수를 사용하여 새로운 코루틴을 생성하고 일시 중단 함수를 호출하기 위한 진입점으로 사용된다.

### 14.6 코루틴의 세계로 들어가기: 코루틴 빌더
- 코루틴은 일시 중단 가능한 계산의 인스턴스다. 이를 다른 코루틴과 동시에 실행될 수 있는 코드 블록으로 생각할 수 있다.
- 코루틴을 생성할 때는 코루틴 빌더 함수 중 하나를 사용한다.
  - `runBlocking`: 블로킹 코드와 일시 중단 함수의 세계를 연결할 때 쓴다.
  - `launch`: 값을 반환하지 않는 새로운 코루틴을 시작할 때 쓴다.
  - `async`: 비동기적으로 값을 계산할 때 쓴다.
#### 14.6.1 일반 코드에서 코루틴의 세계로: `runBlocking` 함수
- 새 코루틴을 생성하고 실행하며, 해당 코루틴이 완료될 때까지 현재 스레드를 블록시킨다.
  - 코드 블록 내에서는 일시 중단 함수를 호출할 수 있다.
  - `runBlocking`은 하나의 스레드를 블로킹한다. 그러나 이 코루틴 안에서는 추가적인 자식 코루틴을 얼마든지 시작할 수 있고, 이 자식 코루틴들은 다른 스레드를 더 이상 블록시키지 않는다.
#### 14.6.2 발사 후 망각 코루틴 생성: `launch` 함수
- 새로운 자식 코루틴을 시작하는데 쓰인다.
- '발사 후 망각' 시나리오에서 사용된다. 어떤 코드를 실행하되, 그 결괏값을 기다리지 않는 경우에 적합하다.
- `launch` 함수는 `Job` 타입의 객체를 반환하는데, 이를 시작된 코루틴에 대한 핸들로 생각할 수 있다.
  - `Job` 객체를 사용하여 코루틴 실행을 제어할 수 있다. (ex. 취소를 촉발할 수 있다.)
#### 일시 중단된 코루틴은 어디로 가는가?
- 컴파일러는 코루틴을 일시 중단, 재개, 스케줄링하는 데 필요한 지원 코드를 생성한다.
- 일시 중단 함수의 코드는 컴파일 시점에 변환되고, 실행 시점에 코루틴이 일시 중단될 때 해당 시점의 상태 정보가 메모리에 저장된다. 이 정보를 바탕으로 나중에 실행을 복구하고 재개할 수 있다.
#### 14.6.3 대기 가능한 연산: `async` 빌더
- `async`는 `launch`와 마찬가지로 실행할 코드를 코루틴으로 전달하지만, 함수의 반환타입은 `Deferred<T>` 인스턴스다.
  - `Deferred`를 사용해 주로 할 일은 `await`라는 일시 중단 함수로 그 결과를 기다리는 것이다.
  - `await`을 호출하면 그 `Deferred`에서 결괏값이 사용 가능해질 때까지 루트 코루틴이 일시 중단된다.
- `Deferred` 객체는 아직 사용할 수 없는 값을 나타낸다. 따라서 그 값을 계산하거나 어디서 읽어와야만 한다.
  - 미래에 언젠가는 값을 알게 될 것이라는 약속, 연기된 계산 결괏값을 나타낸다.
- 독립적인 작업을 동시에 실행하고 그 결과를 기다릴 때만 `async`를 사용하면 된다.
  - 여러 작업을 동시에 시작할 필요가 없고 결과를 기다리지 않아도 된다면 `async`를 사용할 필요가 없다.

### 14.7 어디서 코드를 실행할지 정하기: 디스패처
- 코루틴은 스레드 위에 만들어진 추상화다. 코드가 실제로 어떤 스레드에서 실행될지 더 세밀하게 제어하기 위해 디스패처(dispatcher)를 사용한다.
