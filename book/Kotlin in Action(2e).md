# [Kotlin in Action(2/e)](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=358099845)
- 지은이: 세바스티안 아이그너, 로만 엘리자로프, 스베트라나 이사코바, 드미트리 제메로프
- 옮긴이: 오현석
- 출판사: 에이콘출판
- 읽은 날짜: 2025.03.10 ~ 2025.
- 북 스터디로 진행 (카뱅)

## 1. 코틀린이란 무엇이며, 왜 필요한가?

- 코틀린은 맨 처음에 '더 나은 자바'로 시작했다.
  - 개발자들이 저지를 수 있는 일반적인 유형의 오류를 방지한다.
  - 현대적 언어 설계 패러다임을 포용한다. (다중 패러다임 언어)
    - 객체지향 언어와 함수형 언어의 아이디어를 조합했다.
  - 자바가 쓰이던 모든 곳에 더 편리하게 쓸 수 있는 언어이다.
- 코틀린은 정적 타입 지정(statically typed) 언어이다.
  - 핵심적인 장점은 프로그램의 모든 식의 타입을 컴파일 시점에 알 수 있다.
  - 컴파일러가 타입을 추론한다.
  - 성능, 신뢰성, 유지 보수성
- 코틀린의 주 목적
  - 현재 자바가 사용되고 있는 모든 용도에 적합하면서도 더 간결하고 생산적이며 안전한 대체 언어를 제공하는 것
  - 더 적은 코드로 더 편하게 목표를 달성한다.

### 코틀린의 철학
- "상호운용성에 초점을 맞춘 실용적이고 간결하며 안전한 언어"
- 실용적이다.
  - 코틀린은 실제 문제를 해결하기 위한 언어이다. 많은 개발자들의 의견을 반영했다.
  - IDE 지원이 좋다. (IntelliJ)
- 간결하다.
  - 코드가 더 간단하고 간결할수록 내용을 파악하기가 더 쉽다. 이때 언어 자체의 간결성도 중요하다.
  - 언어가 간결하다는 것
    - 그 언어로 작성된 코드를 읽을 때 의도를 쉽게 파악할 수 있는 구문 구조를 제공한다.
    - 이해할 때 방해가 될 수 있는 부가적인 준비 코드가 적다.
  - ex. getter, setter, 생성자 파라미터 등을 사용하지 않음. 강력한 타입 추론. 라이브러리 함수.
  - 중요한 것은 읽고 이해하는 데 시간이 덜 걸린다.
- 안전하다.

## 5. 람다를 사용한 프로그래밍

### 람다란
- 다른 함수에 전달할 수 있는 작은 코드 조각
- 일련의 동작을 다른 함수에 넘기거나 변수에 저장하기 위해 사용
- 자바에서는 예전에 익명 내부 클래스를 사용했지만 너무 번거로워 자바 8에서 람다가 등장하였다.
- 람다를 사용하면 더 간결하게 표현할 수 있다. 함수 선언을 할 필요가 없다.

### 코틀린 람다
- 람다가 인자를 하나만 사용하고, 구체적인 이름을 붙이고 싶지 않다면 `it`이라는 암시적 이름을 사용할 수 있다.
- 단순히 함수나 프로퍼티에 위임할 경우 멤버 참조(`::`)를 사용할 수 있다.
- 항상 중괄호(`{}`)로 둘러싸여 있다.
  - 인자 주변 목록에 괄호가 없다.
  - 화살표(`->`)가 인자와 람다 본문을 구분한다.
- 코드의 일부분을 블록으로 둘러싸 실행하고 싶다면 `run {}`을 사용하라.
- 컴파일러가 문맥으로 유추 가능한 인자 타입을 굳이 적지 않아도 된다.
  - 컴파일러가 타입을 유추할 수 없을 때만 명시하자.
- 람다가 어떤 함수의 유일한 인자이거나 마지막 인자인 경우, 빈 괄호(`()`)를 생략할 수 있다.
  - ex) `map() {}`(X) `map {}`(O)
- 둘 이상의 람다를 인자로 받는 함수는 람다를 괄호 밖으로 빼낼 수 없다.
- 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않아 타입을 명시해야 한다.
- 본문이 여러 줄인 경우, 본문의 맨 마지막에 있는 식이 람다의 결괏값이 된다. 명시적인 `return`이 필요하지 않다.

### 변수 캡처(capturing variables)
- 함수 안에 익명 내부 클래스를 선언하면, 그 클래스 안에서 함수의 파라미터와 로컬 변수를 참조할 수 있다. 람다 안에서도 동일한 일을 할 수 있다.
- 람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의보다 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.
- 코틀린과 자바 람다의 다른 점 중 하나는 코틀린 람다 안에서는 파이널 변수(불변 변수)가 아닌 변수에 접근할 수 있다는 것이다.
  - 람다 안에서 바깥의 변수를 변경해도 된다.
  - 람다 안에서 접근할 수 있는 외부 변수를 '람다가 캡처한 변수'라고 한다.
- 기본적으로 함수 안에 정의된 로컬 변수의 생명주기는 함수가 반환되면 끝난다.
  - 하지만 어떤 함수가 자신의 로컬 변수를 캡처한 람다를 반환하거나 다른 변수에 저장한다면 로컬 변수의 생명주기와 함수의 생명주기가 달라질 수 있다.
- 코틀린에서는 캡처한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 캡처한 변수를 읽거나 쓸 수 있다.
  - 파이널 변수를 캡처한 경우 - 람다 코드를 변수 값과 함께 저장
  - 파이널이 아닌 변수를 캡처한 경우 - 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다.
- 람다를 비동기적으로 실행되는 코드로 활용하는 경우, 로컬 변수 변경은 람다가 실행될 때만 일어난다.

### 멤버 참조(member reference)
- 함수를 값으로 바꿀 수 있다. 이중 콜론(`::`)을 사용한다. 이를 멤버 참조라고 한다.
- 정확히 한 메서드를 호출하거나 한 프로퍼티에 접근하는 함수 값을 만들어준다.
- 최상위 함수나 프로퍼티를 참조하는 경우, `::method` 식으로 참조 가능하다.
- 생성자 참조는 클래스 생성 작업을 연기하거나 저장해둘 수 있다. `::`뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다.
- 확장함수도 멤버 참조와 동일하게 접근할 수 있다.

### 단일 추상 메서드(Simple Abstract Method) 인터페이스
- 추상 메서드가 단 하나뿐인 인터페이스
- 함수형 인터페이스를 파라미터로 받는 모든 자바 메서드에 람다를 전달할 수 있다.
- 이 때, 함수형 인터페이스에 맞는 익명 클래스를 컴파일러가 구현한다.
  - 람다가 자신이 정의된 함수의 변수에 접근하지 않는다면, 함수가 호출될 때마다 람다에 해당하는 익명 객체가 재사용된다. (그때그때 만들어지지 않는다.)
  - 람다가 자신을 둘러싼 환경의 변수를 캡처하면 더 이상 각각의 함수 호출에 같은 인스턴스를 재사용할 수 없다.
    - 이런 경우 컴파일러는 호출마다 새로운 인스턴스를 만들고 그 객체 안에 캡처한 변수를 저장한다.
- `inline` 표시가 되있는 람다는 익명 클래스가 생성되지 않는다.
  - 대부분의 라이브러리 함수에는 `inline`이 붙어있다.
- 대부분의 경우 람다를 함수형 인터페이스 인스턴스로 변환하는 과정은 자동으로 일어난다.
- SAM 생성자는 SAM 인터페이스의 인스턴스로 명시적으로 변환해준다. ex) `Runnalbe { some() }`
  - 컴파일러가 변환을 자동으로 수행하지 못하는 맥락에서 사용할 수 있다.
- 람다는 인스턴스 자신을 가리키는 `this`를 사용할 수 없다. `this`가 필요한 경우, 람다 대신 익명 객체를 직접 구현한다.

### 코틀린에서 SAM 인터페이스 정의: `fun interface`
- 코틀린 함수형 인터페이스는 정확히 하나의 추상 메서드만 포함하지만 다른 비추상 메서드를 여럿 가질 수 있다.

### 수신 객체 지정 람다: `with, apply, also`
- 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메서드를 호출할 수 있게 한다.
- `with`
  - `public inline fun <T, R> with(receiver: T, block: T.() -> R): R` 
  - 어떤 객체의 이름을 반복하지 않고도 그 객체에 대해 다양한 연산을 수행하는 기능
  - 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다. 그래서 `this` 접근이 가능하다. (생략도 가능하다.)
  - `with`가 반환하는 값은 람다 코드를 실행한 결과이다. 그 결과는 람다식의 본문에 있는 마지막 식의 값이다.
- `apply`
  - `public inline fun <T> T.apply(block: T.() -> Unit): T`
  - `with`와 거의 동일하다. 유일한 차이는, `apply`는 항상 자신에 전달된 객체를 반환한다. `(T) -> T`
  - 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화해야 하는 경우 `apply`가 유용하다.
    - 자바의 빌더와 비슷하다.
- `also`
  - `public inline fun <T> T.also(block: (T) -> Unit): T`
  - 수신 객체에 대해 어떤 동작을 수행한 후 수신 객체를 돌려준다.
  - 주된 차이는 `also`의 람다 안에서는 수신 객체를 인자로 참조한다는 점이다.
    - 따라서 파라미터 이름을 부여하거나 디폴트 이름인 it을 사용해야 한다.
  - 원래 수신 객체를 인자로 받는 동작을 실행할 때 유용하다. 객체에 대해 추가 작업을 실행할 수 있다.
    - "그리고(also) 다음을 객체에게 수행한다."로 읽을 수 있다.

## 6. 컬렉션과 시퀀스

- 람다를 인자로 받는 함수에 내부 로직의 복잡도를 생각하라. 연산이 반복되지는 않는지 고려하라.
- 항상 작성하는 코드로 인해 어떤 일이 벌어질지 명확히 이해해야 한다. 

### 컬렉션 함수
- 원소 제거와 변환: `filter`, `map`
  - `filter`: 컬렉션을 순회하며 주어진 람다가 true를 반환하는 원소들만 모은다.
    - `filterIndexed`: 원소의 인덱스를 포함하여 추출
    - `filterKeys`: map에서 키 기준 추출
    - `filterValues`: map에서 값 기준 추출
  - `map`: 입력 컬렉션의 원소를 변환한다.
    - `mapIndexed`: 원소의 인덱스를 포함한 `map` 연산
    - `mapKeys`: map에서 키를 변환 (Map<K1, V) -> Map<K2, V>)
    - `mapValues`: map에서 값을 변환 (Map<K, V1> -> Map<K, V2>)
- 컬렉션 값 누적: `reduce`, `fold`
  - 컬렉션의 정보를 종합한다.
  - 원소로 이뤄진 컬렉션을 받아서 한 값을 반환한다. 이 값은 accumulator(누적)을 통해 점진적으로 만들어진다.
  - 람다는 각 원소에 대해 호출되며 새로운 누적 값을 반환해야 한다.
  - `reduce`
    - 1번째 원소를 accumulator에 넣어서 시작한다.
    - 빈 리스트에서 호출하면 Exception 발생
  - `fold`
    - `reduce`와 비슷하지만, 초기값을 설정할 수 있다.
  - `runningReduce`, `runningFold`
    - `reduce`와 `fold`이 최종 결과값만 반환한다면, running이 붙은 함수들은 모든 중간 결과를 포함한 리스트를 반환한다.
- 컬렉션에 술어 적용: `all`, `any`, `none`, `count`, `find`
  - `all`: 모든 원소들이 조건을 만족하는지 판별
  - `any`: 원소들 중 하나라도 조건을 만족하는지 판별
    - `!all { predicate } == any { !predicate }`
  - `none`: 모든 원소들이 조건을 만족하지 않음을 판별 (=`!any`)
  - empty list 에선 어떻게 동작할까?
    - `all` -> 항상 true (조건을 만족하지 않는 원소를 댈 수 없기 때문)
    - `any` -> 항상 false (조건을 만족하는 원소가 없기 때문)
    - `none` -> 항상 true (any와 반대)
  - `count`: 조건을 만족하는 원소의 개수 반환
    - `filter { }.size`와 중간 과정이 다르다. `filter`는 중간 컬렉션을 만들지만, `count`는 원소 개수만 추적한다.
  - `find`: 조건을 만족하는 첫 번째 원소 반환
    - 원소가 전혀 없으면 `null` 반환 (`firstOrNull`과 같다.)
- 파티션을 분할해 리스트의 쌍으로 만들기: `partition`
  - `partition`: 조건을 만족하는 그룹과 그렇지 않은 그룹으로 나눈다. 전체 컬렉션을 2번 순회하지 않는다.
- 리스트를 여러 그룹으로 이뤄진 맵으로 바꾸기: `groupBy`
  - `groupBy`: 컬렉션의 원소를 어떤 특성에 따라 여러 그룹으로 나눌 때 사용
    - 컬렉션의 원소를 구분하는 특성이 key, 각 그룹이 value가 된다.
- 컬렉션을 맵으로 변환: `associate`, `associateWith`, `associateBy`
  - `associate`
    - 입력 컬렉션의 원소로부터 키/값 쌍을 만들어낸다.
    - 입력 시 중위 함수 `to`를 사용해 키/값 쌍을 표현한다.
  - `associateWith`
    - 컬렉션의 원래 원소를 키로 사용
    - 작성한 람다는 그 원소에 대응하는 값을 만든다.
  - `associateBy`
    - 컬렉션의 원래 원소를 값으로 사용
    - 작성한 람다는 그 원소에 대응하는 키를 만든다.
    - 키가 겹칠 경우 가장 마지막 결과가 저장된다.
- 가변 컬렉션의 원소 변경: `replaceAll`, `fill`
  - `replaceAll`
    - 지정한 람다로 얻은 결과로 컬렉션의 모든 원소를 변경한다.
    - `MutableList`에서 사용 가능하다.
  - `fill`
    - 가변 리스트의 모든 원소를 똑같은 값으로 바꾸는 경우 사용
- 컬렉션의 특별한 경우 처리: `ifEmpty`
  - 컬렉션에 아무 원소가 없을 때 기본값을 생성하는 람다를 제공한다.
- 컬렉션 나누기: `chunked`, `windowed`
  - `chunked`
    - 컬렉션을 주어진 크기로 서로 겹치지 않는 부분으로 나눌 때 사용.
    - 마지막으로 만들어진 청크의 크기는 정한 사이즈보다 작을 수 있다.
  - `windowed`
    - 슬라이딩 윈도우를 생성한다. 정한 길이만큼 인덱스를 1씩 밀어서 리스트들을 생성한다.
- 컬렉션 합치기: `zip`
  - 별도의 두 리스트를 한꺼번에 종합할 때 사용. 종합하면서 변환도 가능하다.
  - 결과 컬렉션은 두 입력 컬렉션 중 더 짧은 쪽의 길이와 같다.
  - `zip`은 항상 2개씩 합칠 수 있다. 중위 연산자로 여러개 겹치더라도 flat하게 합쳐지지 않는다. ex. ((A, B), C)
- 내포된 컬렉션의 원소 처리: `flatMap`, `flatten`
  - `flatMap`
    - 내포된 컬렉션 없이 컬렉션을 만들 수 있다.
    - 주어진 원소들을 변환한 다음, 하나의 리스트로 만든다.
  - `flatten`
    - 변환하는 것 없이 내포된 컬렉션을 하나의 컬렉션으로 만들고 싶을 때 사용

### 시퀀스(Sequence)
- 컬렉션 함수들은 결과 컬렉션을 즉시(eagerly) 생성한다.
  - 연쇄 호출하면, 매 단계마다 계산 중간 결과를 새로운 컬렉션으로 만든다.
- 시퀀스는 자바 스트림처럼 중간 임시 컬렉션을 만들지 않고 연산한다.
  - 시퀀스는 게으르게(lazy) 연산한다.
  - 연쇄적인 연산을 효율적으로 수행한다.
- `asSequence` 확장함수를 통해 어떤 컬렉션이든 시퀀스로 바꿀 수 있다.
- 큰 컬렉션에 대해 연산을 연쇄할 때는 시퀀스를 사용하라.
  - 크기가 충분히 크지 않다면 즉시 계산의 연산 효율이 더 좋다.
- 모든 연산은 각 원소에 대해 순차적으로 적용된다.
- 컬렉션의 경우 연산의 순서가 성능에 영향을 끼친다.
  - 연쇄 연산에서 더 빨리 원소들을 제거(filter)수록 코드의 성능이 더 좋아진다.

### 시퀀스 연산 실행: 중간 연산과 최종 연산
- 중간 연산
  - 다른 시퀀스를 반환
  - 최초 시퀀스의 원소를 변환하는 방법을 안다.
  - 항상 지연 연산
  - 최종 연산이 호출되지 않으면 아무 연산도 하지 않는다.
- 최종 연산
  - 결과를 반환. 모든 연산을 수행.
  - 시퀀스에서 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 수 또는 다른 객체

### 시퀀스 만들기
- `asSequence()`
  - 컬렉션을 시퀀스로 변환한다.
- `generateSequence`
  - 이전의 원소를 인자로 받아 다음 원소를 계산한다.
