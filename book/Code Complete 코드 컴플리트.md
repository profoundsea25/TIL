# [Code Complete 코드 컴플리트](https://search.shopping.naver.com/book/catalog/32478362459?cat_id=50010921&frm=PBOKPRO&query=Code+Complete&NaPm=ct%3Dmchh3jm8%7Cci%3D7c151d6319ecadc0116fc3b9c817860c033f2c68%7Ctr%3Dboknx%7Csn%3D95694%7Chk%3D6aab9121bce2be515c85c038f2d6b7bd5a6fe006)
- 지은이: 스티브 맥코넬 (서우석)
- 출판사: 위키북스
- 읽은 날짜: 2025.06.29 ~ 2025.

## 6장. 클래스 다루기
- 클래스는 연관성이 높고 잘 정의된 기능을 공유하는 데이터와 루틴의 모음이다.
  - 능력 있는 개발자가 되려면 현재 작업 중인 코드에 집중할 수 있게 프로그램에서 무시할 수 있는 부분을 최대화할 수 있어야 한다.
  - 클래스는 그러한 목표를 달성하기 위한 일차적인 도구다.

### 6.1 클래스의 토대: 추상 데이터형
- 추상 데이터형(Abstract Data Type, ADT)은 데이터와 데이터를 처리하는 연산의 집합이다.
  - 연산은 프로그램의 나머지 부분에 데이터가 무엇인지를 설명해주는 역할과 나머지 프로그램에서 그 데이터를 변경할 수 있게 해주는 역할을 한다.
- 객체 지향 프로그래밍을 이해하기 위해서는 ADT를 반드시 이해해야 한다.
  - ADT를 이해하지 못한다면 이름만 "클래스"인 클래스를 작성할 것이다.
  - 그런 클래스는 실제로는 연관성이 높지 않은 데이터와 루틴을 편의를 위해 보관하는 상자와 다를 게 없다.
- 전형적인 저수준 데이터형을 저수준 데이터형이 아닌 ADT로 만들거나 사용하라.
  - 사실상 모든 전형적인 데이터형을 ADT로 표현할 수 있다.

### 6.2 좋은 클래스 인터페이스
- 고급 클래스를 만들기 위한 가장 중요한 단계는 좋은 인터페이스를 만드는 것이다.
  - 표현하고자 하는 인터페이스를 잘 추상화하여 구현 세부 사항이 외부에 드러나지 않도록 한다.
#### 좋은 추상화
- 추상화는 복잡한 연산을 단순환 형태로 보여주는 능력이다.
- 클래스 인터페이스는 서로 밀접한 루틴들을 제공해야 한다.
- 클래스 추상화에 대한 평가는 공개 루틴의 집합, 즉 클래스의 인터페이스를 기초로 한다.
- 클래스 인터페이스가 일관된 추상화 수준을 갖도록 한다.
  - 각 클래스는 오직 하나의 ADT만 구현해야 한다.
- 클래스가 구현하고 있는 추상화가 무엇인지 이해해야 한다.
- 관련이 없는 정보를 다른 클래스로 옮겨라.
- 코드 변경 시 인터페이스의 추상화가 망가지지 않도록 주의한다.
- 인터페이스 추상화에 맞지 않는 공개 멤버를 추가하지 말라.
- 추상화와 응집도를 함께 고려하라.
  - 추상화와 응집도는 개념적으로 밀접한 연관이 있다.
  - 좋은 추상화를 제공하는 클래스 인터페이스는 일반적으로 강한 응집도를 갖는다.
#### 좋은 캡슐화
- 캡슐화는 세부 사항을 알고 싶어 할 때조차 이를 원천적으로 봉쇄해버리는 더 강력한 방법이다.
- 캡슐화 없이는 추상화가 꺠질 수 있기 때문에 이 두 개념은 연관되어 있다.
  - 경험상 추상화와 캡슐화 모두 갖고 있든지 둘 다 없든지 둘 중 하나다. 중간은 없다.
- 클래스와 멤버의 접근성을 최소화하라.
  - 중요한 지침은 "어떻게 해야 인터페이스 추상화의 무결성을 최상으로 유지할 수 있는가?"
  - 노출시키는 루틴이 추상화와 일관성이 있다면 노출시켜도 크게 문제가 없을 것이다.
  - 확신이 서지 않으면 일반적으로 숨기는 것이 숨기지 않는 것보다 낫다.
- 클래스의 사용자를 가정하지 말라.
  - 인터페이스 문서에 적혀 있는 것 외에는 인터페이스가 어떻게 사용될 것인지 또는 어떻게 사용되지 않을 것인지에 대해서 어떠한 가정도 해서는 안 된다.
- 인터페이스 문서만으로 클래스를 어떻게 사용해야 할지 알아낼 수 없을 때 소스코드를 꺼내서 구현부를 보는 것은 올바른 대처가 아니다.
  - 클래스의 개발자에게 연락해서 "클래스를 어떻게 사용해야 할지 잘 모르곘습니다."라고 말해야 한다.

### 6.3 설계와 구현 문제
- 상속은 코드와 데이터를 기본 클래스에 집중시킴으로써 여러 위치에서 반복적으로 사용하는 것을 피하게 해준다.
  - 파생 클래스는 기존 클래스의 특수화된 버전"이다."(is-a)
  - 상속은 프로그램을 복잡하게 만들기 때문에 위험하다.
- 리스코프 치환 원칙 : 서브클래스는 사용자가 그 차이점을 모른 채 기본 클래스의 인터페이스를 통해서 사용할 수 있어야 한다.
- 개발자가 서브 클래스를 구현할 때 의미적인 차이점에 대해서 끊임없이 생각해야 한다면 상속이 복잡성을 줄이기보다 늘리는 격이 된다.
- 인터페이스는 필요 없고 구현만 사용하고 싶다면 상속 대신 포함을 사용하라.
- 공통으로 사용되는 인터페이스와 데이터, 행위를 상속 단계에서 가능한 가장 높은 곳으로 옮겨라.
- 파생 클래스가 하나뿐인 기본 클래스를 의심하라.
  - 앞으로를 대비하는 가장 좋은 방법은 "언젠가는 구현될지도 모르는" 기본 클래스의 추가적인 계층을 설계하는 것이 아니라 가능한 현재의 작업을 분명하고 직관적이며 단순하게 만드는 것이다.
  - 필요한 것 이상으로 상속 구조를 만들면 안 된다.
- 깊은 상속 구조를 피하라.
  - 대부분의 사람이 상속 구조가 두세 단계 이상 되면 이해하는데 어려움을 겪었다.
  - 깊은 상속 구조는 오류의 증가와 깊이 연관되어 있다.
- 중복된 코드를 피하고 복잡성을 최소화하기 위해서 상속을 사용하고 있는지 확인하라.
#### 다중 상속
- 다중 상속은 객체에 일련의 속성을 추가하는 데 사용하는 간단한 클래스인 믹스인(Mixin)을 정의할 때 주로 쓸모가 있다.
- 모든 믹스인이 서로 완벽하게 독립적이기만 하면 다중 상속과 관련된 다이아몬드 상속 문제를 만들지 않는다.
#### 상속에 관한 규칙이 왜 이렇게 많은 것일까?
- 상속을 사용하면 그만큼 복잡성을 관리하기가 어렵기 때문이다.
- 복잡성을 관리하고 싶다면 상속을 최대한 멀리해야 한다.
#### 멤버 함수와 데이터
- 클래스에 가능한 한 적은 수의 루틴을 유지하라.
  - 클래스당 루틴 수가 늘어나는 것이 오류율 상승과 연관되어 있다.
- 클래스에서 호출되는 루틴의 수를 최소화하라.
  - 클래스에서 발견된 오류의 수가 루틴 내에서 호출되는 루틴의 수와 통계적으로 관련이 있다.
  - 클래스가 사용한 클래스가 많을수록 오류도 증가한다.
- 일반적으로 클래스가 다른 클래스와 협력하는 정도를 최소화하라.
#### 생성자
- 가능하다면 모든 멤버 데이터를 모든 생성자에서 초기화하라.
- 확실하지도 않은 성능 이득을 위해서 복잡성을 추가하는 것보다는 특별한 이유가 없다면 깊은 복사를 선택하라.

### 6.4 클래스를 작성하는 이유
- 클래스를 생성하는 가장 중요한 이유는 프로그램의 복잡성을 줄이는 것이다.
- 복잡성을 고립시킨다.
- 변경할 가능성이 있는 부분을 고립시켜서 변경의 효과를 단일 클래스나 소수의 클래스로 제한한다.
- 모든 것을 알고 있고 모든 것을 할 수 있는 전지전능한 클래스를 생성하지 말라.

### 체크리스트: 클래스 품질
- 클래스에 핵심적인 목적이 있는가?
- 클래스의 이름이 핵심적인 목적을 설명하는가?
- 클래스의 인터페이스가 클래스의 사용 방법을 분명하게 만들고 있는가?
- 클래스의 구현 세부 사항을 전혀 알 필요가 없을 정도로 클래스의 인터페이스가 추상적인가? 클래스를 블랙박스로 취급할 수 있는가?
- 관련 없는 정보를 클래스에서 제거했는가?
- 클래스를 컴포넌트 클래스로 분할하는 것에 대해 생각했는가? 최대한 분할했는가?


## 7장. 고급 루틴
- 루틴
  - 한 가지 목적을 위해서 호출할 수 있는 개별 메서드나 프로시저
  - 루틴은 프로그래밍 언어의 다른 어떤 기능보다도 프로그램을 읽고 이해하기 쉽게 만든다.
  - 루틴은 공간을 절약하고 성능을 향상하기 위해 발명된 가장 훌륭한 기법이기도 하다.

### 7.1 루틴을 작성하는 이유
- 복잡성을 줄인다. 프로그램의 복잡성을 줄이는 것이 루틴을 작성하는 가장 중요한 목적이다.
- 이해하기 쉬운 중간 단계의 추상화를 도입한다.
- 중복 코드를 피한다. 코드가 반복되면 루틴을 작성해야 한다.
- 클래스를 작성하는 이유의 상당수가 루틴을 작성하는 이유이기도 하다.
#### 루틴으로 작성하기에는 너무 단순해 보이는 연산
- 작은 루틴도 매우 유용하다.
  - 가독성을 향상시킨다.
  - 수정을 더 쉽게 한다. 루틴을 사용하지 않았을 때 중복되는 코드들에 수정사항이 생기면, 그 중복된 곳마다 수정을 해줘야 하는 부담을 줄일 수 있다.

### 7.2 루틴 수준의 설계
- 개별적인 루틴 수준에서는 응집성이라는 개념을 통해 설계에 도움을 받을 수 있다.
  - 루틴에서의 응집성을 루틴에 있는 연산들이 얼마나 밀접하게 연관되어 있는지를 나타낸다.
  - 즉, 루틴 내의 연산들이 얼마나 강하게 연결되어 있는지를 나타낸다.
- 루틴을 작성하는 목적은 한 가지 일을 잘하도록 하는 것이지 여러 가지 일을 처리하는 데 있지 않다.
- 가장 바람직한 응집성은 "기능적 응집성"이다. 루틴이 오직 하나의 연산만 처리하는 경우다.

### 7.3 좋은 루틴 이름
- 루틴이 하는 모든 것을 표현하라.
  - 루틴 이름에 모든 출력과 부수적인 효과를 설명하라.
  - 루틴이 가급적이면 부수적인 영향을 갖지 않도록 코드를 작성해서 루틴의 역할을 좀 더 분명하게 해야 한다.
- 의미가 없거나 모호하거나 뚜렷한 특징이 없는 동사를 사용하지 않기.
  - 해당 루틴과 관련된 루틴들을 재구성하여, 모든 루틴이 분명한 목적을 갖고 루틴의 기능을 정확하게 설명하는 이름을 갖도록 재구성하기.
- 루틴의 이름 길이에 신경 쓰지 않기.
  - 전반적으로 루틴 이름은 "명료함"에 초점을 맞춰야 한다.
  - 따라서 이름의 길이에 제약을 받지 않고 이해하기 쉽게 이름을 지어야 한다.
- 함수의 이름을 지을 때는 리턴 값에 관해서 설명하라.
- 프로시저에 객체의 이름을 포함시킬 필요가 없다.

### 7.4 루틴 길이에 대한 문제
- 결과적으로 200줄 이상의 긴 루틴을 작성하고 할 때는 주의해야 한다.

### 7.6 함수를 사용할 때 특별히 고려해야 할 사항
- 함수 이름은 언제나 함수가 반환하는 값을 고려해야 한다.


## 8장. 방어적 프로그래밍
- 방어적 프로그래밍의 핵심 개념은, 설령 다른 루틴의 잘못으로 인한 것이라도 루틴에 잘못되 데이터가 들어왔을 대 작성한 루틴에 아무런 문제가 발생하지 않도록 하는 데 있다.
  - 프로그램은 언제나 문제가 있고 지속해서 변경될 것이고, 똑똑한 개발자는 그러한 상황에 대처할 수 있는 코드를 개발할 것이다.

### 8.1 잘못된 입력으로부터 프로그램 보호
- 좋은 프로그램은 쓰레기를 입력받았더라도 절대로 쓰레기를 내보내지 않는다.
  - 쓰레기를 넣으면 아무것도 안 나오거나,
  - 쓰레기를 넣으면 오류 메시지를 출력하거나,
  - 어떤 쓰레기도 허용하지 않아야 한다.
- 엉성하고 안전하지 못한 프로그램만 "쓰레기를 넣으면 쓰레기가 나온다."
- 쓰레기 입력을 처리하기 위한 세 가지 방법
  - 외부로부터 들어오는 모든 데이터의 값을 검사한다.
  - 루틴의 모든 입력 매개변수 값을 검사한다.
  - 잘못된 입력을 어떻게 처리할지 결정한다.

### 8.2 어설션
- Assertion은 대게 루틴이나 매크로 실행 시 프로그램이 스스로 검사할 수 있도록 사용하는 코드다.
- 코드에서 가정한 것을 문서화하고 예상치 못한 조건을 찾아내기 위해서 어설션을 사용하라.
- 어설션은 일반적으로 개발 버전에서는 코드에 포함되어 컴파일되지만, 제품에서는 제외된다.

#### 어설션 사용 지침
- 발생이 예상되는 상황은 오류 처리 코드를 사용하고, 절대로 발생해서는 안 되는 조건은 어설션을 사용한다.
- 선행 조건과 후행 조건을 문서화하고 검증하는 데 어설션을 사용하라
  - 선행 조건: 루틴이나 클래스에서 다른 루틴을 호출하거나 객체를 생성하기 전에 반드시 참이어야 하는 특징. 루틴을 호출하는 쪽에서 반드시 지켜야 한다.
  - 후행 조건: 루틴이나 클래스를 호출하고 난 후에 반드시 참이어야 하는 조건. 호출된 코드나 클래스가 지켜야 한다.

### 8.3 오류 처리 기법
#### 견고함 대 정확성
- 정확성
  - 절대로 부정확한 결과를 반환할 수 없다는 것을 의미한다.
  - 부정확한 결과를 반환하는 것보다 아무 결과를 반환하지 않는 것이 더 좋다.
- 견고함
  - 부정확한 결과를 만들어 내더라도 소프트웨어가 작동할 수 있도록 계속 무언가를 하려고 애쓰는 것을 의미한다.
#### 오류 처리를 위한 상위 수준에서의 설계
- 접근 방법을 선택하고 나면 일관성 있게 따라야 한다.

### 8.4 예외
- 루틴에서 코드가 어떻게 처리해야 하는지를 모르는 예외적인 상황에 부딪히면 예외를 던진다.
- 예외를 사용해 무시되어서는 안 되는 오류를 프로그램의 다른 부분에 알린다.
- 예외는 절대로 일어나서는 안 되는 경우에 사용한다.
- 루틴에서 발생하는 예외는 다른 데이터형과 마찬가지로 루틴 인터페이스의 일부다.
- 예외를 발생시킨 모든 정보를 예외 메시지에 포함한다.

### 8.5 오류로 인한 손해를 막기 위한 방책
- 클래스의 공개 메서드는 데이터가 안전하지 않다고 가정하고 데이터를 검사하고 깨끗하게 만들어야 할 책임이 있다.
  - 데이터가 공개 메서드에 전달되고 나면 비공개 메서드는 그 데이터가 안전하다고 생각할 수 있다.
- 데이터가 입력되지마자 입력 데이터를 적절한 형태로 변환하라.
- 외부에 노출된 메서드에서는 예외를, 내부에서는 단언(어설션)을 사용하라.

### 8.6 디버깅 보조 도구
- 오류를 빠르게 발견하기 위함이다.
- 개발 중에는 개발을 좀 더 원활히 진행하도록 도와주는 도구를 사용한다.
  - 배포 버전과 동일한 제약 사항을 가할 필요는 없다.
- 예외적인 경우에는 개발 중에도 눈에 띄어야 하고 배포되는 버전의 코드가 실행 중일 때는 복구가 가능한 방법으로 처리되어야 한다.
- 배포 버전에서는 디버깅 보조 도구를 제거하라.

### 8.7 제품 코드를 얼마나 방어적으로 프로그래밍할 것인지 정하기
- 개발 과정 중에는 오류가 눈에 띄는 것이 낫다.
- 제품 개발 시에는 가능한 한 오류가 보이지 않도록 하고 프로그램이 복구되거나 품위 있게 실패하는 편이 낫다.
- 중요한 오류를 검사하는 코드는 남겨라.
- 오류가 정말로 사소하게 영향을 미친다면 오류 검사 코드를 제거한다.
- 오류 메시지가 친절한지 확인한다.
### 8.8 방어적 프로그래밍에 대해서 한 번 더 고민하기
- 모든 곳에서 매개변수를 검사하면 프로그램이 비대해지고 느려진다.
- 방어적일 필요가 있는 곳을 생각한 후, 우선순위를 정한다.


## 9장. 의사코드 프로그래밍 프로세스(PPP)
- 루틴과 클래스를 구현하기 위한 방법 중 하나.

### 9.1 클래스 및 루틴 개발 단계 요약
- 클래스 구현 방법
  1. 클래스에 대한 일반적인 설계를 작성한다.
    - 클래스의 구체적인 책임을 정의하고
    - 클래스가 숨길 "비밀"이 무엇인지 정의하고
    - 클래스 인터페이스가 추구할 추상화가 무엇인지 정확하게 정의한다.
  2. 클래스 내의 구체적인 루틴을 열거한다.
  3. 루틴을 구현한다.
  4. 전체적으로 클래스를 구현을 검사한다.
    - 각 루틴은 작성하면서 테스트한다.

### 9.2 전문가를 위한 의사코드
- 의사코드: 프로그램이 어떻게 작동할지 기술하는 자연어 문장과 같은 표기
  - 의사코드는 목적에 좀 더 초점을 맞춘다.
  - 특정 프로그래밍 언어의 문법적 요소를 피한다.
- 의사코드의 장점은, 주석 작업을 최소화할 수 있다는 것이다. (구현하면서 최소한의 의사코드로 정리한다.)

### 9.3 PPP를 이용한 루틴 구현
1. 루틴을 설계한다.
   - 선행 조건 검사
   - 루틴이 해결할 문제 정의
   - 루틴의 이름 결정
   - 루틴을 어떻게 테스트할 것인지 결정
   - 다른 코드를 재사용 가능한지 검토
   - 오류 처리를 생각
   - 자원과 속도의 목표를 설계
     - 성능에 문제가 있다고 판명되기 전까지는 미세한 부분을 개선하느라 시간을 낭비하지 않아야 한다.
   - 의사코드를 작성/검토
     - 다른 사람에게 "의사코드"를 검토받는 것 또한 의미가 있다. (코드보다 더 쉽게 읽을 수 있다.)
2. 루틴을 구현한다.
   - 루틴의 선언부 작성
   - 의사코드를 고수준의 주석으로 변환
   - 각 주석마다 코드를 작성
   - 코드를 더 나눠야 하는지 검사
     - 주석 아래의 코드가 비대해진다면, 별도의 루틴으로 나누거나 의사코드를 더 상세하게 작성한다.
3. 코드를 검사한다.
   - 구현한 코드가 정확한가?
   - 찾을 수 있는 모든 오류를 찾아야 한다. 나중에 수정하려고 하면 비용이 더 많이 든다.
   - 작동하는 루틴만으로는 충분하지 않다. 왜 작동하는지를 모른다면 알 때까지 연구하고 토론하고 다른 설계로 실험해 본다.
   - 컴파일러의 모든 오류 메시지와 경고의 원인을 제거한다.
4. 나머지를 정리한다.
5. 필요한 만큼 반복한다.


## 3부. 변수
## 10장. 변수 사용 시 고려할 사항
### 10.4 범위
- 한 번에 기억해야 하는 코드 줄 수가 적을 수록 코드는 더욱 이해하기 쉬워진다.
### 10.8 변수를 한 가지 목적으로만 사용하기
- 숨은 의미가 있는 변수를 피하라.
    - 변수를 이중 목적으로 사용하는 것이 자신에게는 명백해 보일지라도 다른 사람에게는 그렇지 않다.


## 11장. 변수 이름의 기능
### 11.1 좋은 이름을 위한 고려 사항
- 결과적으로 변수의 좋고 나쁨은 그 이름에 의해 주로 좌우된다.
- 변수 이름을 지을 때 그 이름이 변수가 나타내는 것을 완전하고 정확하게 설명하는지를 가장 중요하게 고려해야 한다.
- 변수가 표현하는 것을 단어로 서술하라.
- 이름은 가능한 한 구체적이어야 한다.
- 좋은 이름은 "어떻게"보다 "무엇"을 표현하는 경향이 있다.
- 변수 이름의 길이는 10~16자 사이가 디버깅하기에 좋다.
- 긴 이름은 거의 사용하지 않는 변수나 전역 변수에 좋고 짧은 이름은 지역 변수나 반복문 변수에 좋다.
- 코드에서 직관적으로 이해하지 못하는 부분이 있다면 변수의 이름을 다시 만들어라.
- 어떤 규약이든지 없는 것보다는 있는 게 낫다.
- 일반적으로 필요한 형식화 정도는 프로그램에서 작업하는 사람들의 수와 프로그램의 크기, 프로그램의 예상 수명에 따라서 달라진다.


## 12장. 기본 데이터형
- 크게 차이가 나는 숫자를 더해야 한다면, 우선 숫자를 구분하고 가장 작은 값부터 더한다.
- 판별식을 boolean 변수로 치환하고, 변수명으로 설명하면 가독성이 좋다.


## 4부 명령문
## 14장. 순차적 코드 구성하기
- 명령문이 특정한 순서로 작성되어야 하는 의존성을 갖고 있을 때는 의존성을 분명히 하기 위한 단계를 밟아야 한다.

### 14.2 순서가 중요하지 않은 명령문
- 기본 가이드라인: 연관된 작업을 함께 두는 근접성 원칙을 따른다.
- 프로그램을 여기저기 건너뛰지 않고 하향식으로 읽을 수 있게 개발하라.
  - 전문가들은 하향식 순서가 가독성에 가장 많은 영향을 미친다고 말한다.
- 코드를 그룹화하면 아주 밀접하면서도 전후 코드와는 아무 관계가 없는 코드를 발견하게 된다.
  - 그런 경우에는 밀접하게 연관된 코드를 별도의 루틴으로 리팩터링한다.


## 15장. 조건문 사용
- 가독성을 위한 팁
  - 일반적인 경우를 처리하는 코드를 먼저 작성하고 특별한 경우를 처리하라.
  - 정상적인 경우를 if문에 입력하기. else는 특별한 경우를 위해 쓴다.
  - else if가 들어가는 경우, 가장 흔한 경우를 첫 if에 배치하라.
- (코틀린 when, 자바 switch문) 기본값이 유효한 경우에만 default를 사용한다.
  - 오류를 발견하지 못할 가능성이 생긴다.
  - 가장 마지막 branch는 오류를 던져라.

## 16장. 반복문 제어
- 일반적으로, 모든 종료 조건을 한 곳에 입력한다.
  - 종료 조건을 분산시켜 놓으면 사실상 하나 또는 그 이상의 종료 조건을 디버깅이나 수정, 테스팅 중에 못 보고 지나치게 되기 때문이다.
- 머릿속에서 프로그램을 돌려보는 습관을 가져라.
  - 초기 코드 작성 시 오류가 적게 발생한다.
  - 디버깅 시 오류를 더 빨리 발견할 수 있다.
  - 프로그램에 대한 전체적인 이해도가 좋아진다.
  - 코드가 어떻게 동작하는지를 이해하고 있다는 것을 의미한다.
### 16.3 반복문을 쉽게 작성하는 법 - 안에서부터 밖으로
- 하나의 경우로 시작하라.
  - 그 경우를 문장으로 작성한 다음 들여쓰기 하고 그 문장 주위에 반복문을 입력한다.
  - 문장을 반목문 인덱스나 계산 표현식으로 바꾼다.
  - 기능을 완성할 때까지 이 과정을 반복한다.
  - 작업을 마치고 나서 필요한 모든 초기화 작업을 추가한다.

## 17장. 특이한 제어 구조
### 17.2 재귀문
- 재귀문은 일반적으로 문제의 작은 부분이 해결하기가 쉽고 큰 부분을 더 작게 쉽게 나눌 수 있는 경우에 사용.
- 일반적으로 유용하지 않음.
