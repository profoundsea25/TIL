# [Code Complete 코드 컴플리트](https://search.shopping.naver.com/book/catalog/32478362459?cat_id=50010921&frm=PBOKPRO&query=Code+Complete&NaPm=ct%3Dmchh3jm8%7Cci%3D7c151d6319ecadc0116fc3b9c817860c033f2c68%7Ctr%3Dboknx%7Csn%3D95694%7Chk%3D6aab9121bce2be515c85c038f2d6b7bd5a6fe006)
- 지은이: 스티브 맥코넬 (서우석)
- 출판사: 위키북스
- 읽은 날짜: 2025.06.29 ~ 2025.

## 6장. 클래스 다루기
- 클래스는 연관성이 높고 잘 정의된 기능을 공유하는 데이터와 루틴의 모음이다.
  - 능력 있는 개발자가 되려면 현재 작업 중인 코드에 집중할 수 있게 프로그램에서 무시할 수 있는 부분을 최대화할 수 있어야 한다.
  - 클래스는 그러한 목표를 달성하기 위한 일차적인 도구다.

### 6.1 클래스의 토대: 추상 데이터형
- 추상 데이터형(Abstract Data Type, ADT)은 데이터와 데이터를 처리하는 연산의 집합이다.
  - 연산은 프로그램의 나머지 부분에 데이터가 무엇인지를 설명해주는 역할과 나머지 프로그램에서 그 데이터를 변경할 수 있게 해주는 역할을 한다.
- 객체 지향 프로그래밍을 이해하기 위해서는 ADT를 반드시 이해해야 한다.
  - ADT를 이해하지 못한다면 이름만 "클래스"인 클래스를 작성할 것이다.
  - 그런 클래스는 실제로는 연관성이 높지 않은 데이터와 루틴을 편의를 위해 보관하는 상자와 다를 게 없다.
- 전형적인 저수준 데이터형을 저수준 데이터형이 아닌 ADT로 만들거나 사용하라.
  - 사실상 모든 전형적인 데이터형을 ADT로 표현할 수 있다.

### 6.2 좋은 클래스 인터페이스
- 고급 클래스를 만들기 위한 가장 중요한 단계는 좋은 인터페이스를 만드는 것이다.
  - 표현하고자 하는 인터페이스를 잘 추상화하여 구현 세부 사항이 외부에 드러나지 않도록 한다.
#### 좋은 추상화
- 추상화는 복잡한 연산을 단순환 형태로 보여주는 능력이다.
- 클래스 인터페이스는 서로 밀접한 루틴들을 제공해야 한다.
- 클래스 추상화에 대한 평가는 공개 루틴의 집합, 즉 클래스의 인터페이스를 기초로 한다.
- 클래스 인터페이스가 일관된 추상화 수준을 갖도록 한다.
  - 각 클래스는 오직 하나의 ADT만 구현해야 한다.
- 클래스가 구현하고 있는 추상화가 무엇인지 이해해야 한다.
- 관련이 없는 정보를 다른 클래스로 옮겨라.
- 코드 변경 시 인터페이스의 추상화가 망가지지 않도록 주의한다.
- 인터페이스 추상화에 맞지 않는 공개 멤버를 추가하지 말라.
- 추상화와 응집도를 함께 고려하라.
  - 추상화와 응집도는 개념적으로 밀접한 연관이 있다.
  - 좋은 추상화를 제공하는 클래스 인터페이스는 일반적으로 강한 응집도를 갖는다.
#### 좋은 캡슐화
- 캡슐화는 세부 사항을 알고 싶어 할 때조차 이를 원천적으로 봉쇄해버리는 더 강력한 방법이다.
- 캡슐화 없이는 추상화가 꺠질 수 있기 때문에 이 두 개념은 연관되어 있다.
  - 경험상 추상화와 캡슐화 모두 갖고 있든지 둘 다 없든지 둘 중 하나다. 중간은 없다.
- 클래스와 멤버의 접근성을 최소화하라.
  - 중요한 지침은 "어떻게 해야 인터페이스 추상화의 무결성을 최상으로 유지할 수 있는가?"
  - 노출시키는 루틴이 추상화와 일관성이 있다면 노출시켜도 크게 문제가 없을 것이다.
  - 확신이 서지 않으면 일반적으로 숨기는 것이 숨기지 않는 것보다 낫다.
- 클래스의 사용자를 가정하지 말라.
  - 인터페이스 문서에 적혀 있는 것 외에는 인터페이스가 어떻게 사용될 것인지 또는 어떻게 사용되지 않을 것인지에 대해서 어떠한 가정도 해서는 안 된다.
- 인터페이스 문서만으로 클래스를 어떻게 사용해야 할지 알아낼 수 없을 때 소스코드를 꺼내서 구현부를 보는 것은 올바른 대처가 아니다.
  - 클래스의 개발자에게 연락해서 "클래스를 어떻게 사용해야 할지 잘 모르곘습니다."라고 말해야 한다.

### 6.3 설계와 구현 문제
- 상속은 코드와 데이터를 기본 클래스에 집중시킴으로써 여러 위치에서 반복적으로 사용하는 것을 피하게 해준다.
  - 파생 클래스는 기존 클래스의 특수화된 버전"이다."(is-a)
  - 상속은 프로그램을 복잡하게 만들기 때문에 위험하다.
- 리스코프 치환 원칙 : 서브클래스는 사용자가 그 차이점을 모른 채 기본 클래스의 인터페이스를 통해서 사용할 수 있어야 한다.
- 개발자가 서브 클래스를 구현할 때 의미적인 차이점에 대해서 끊임없이 생각해야 한다면 상속이 복잡성을 줄이기보다 늘리는 격이 된다.
- 인터페이스는 필요 없고 구현만 사용하고 싶다면 상속 대신 포함을 사용하라.
- 공통으로 사용되는 인터페이스와 데이터, 행위를 상속 단계에서 가능한 가장 높은 곳으로 옮겨라.
- 파생 클래스가 하나뿐인 기본 클래스를 의심하라.
  - 앞으로를 대비하는 가장 좋은 방법은 "언젠가는 구현될지도 모르는" 기본 클래스의 추가적인 계층을 설계하는 것이 아니라 가능한 현재의 작업을 분명하고 직관적이며 단순하게 만드는 것이다.
  - 필요한 것 이상으로 상속 구조를 만들면 안 된다.
- 깊은 상속 구조를 피하라.
  - 대부분의 사람이 상속 구조가 두세 단계 이상 되면 이해하는데 어려움을 겪었다.
  - 깊은 상속 구조는 오류의 증가와 깊이 연관되어 있다.
- 중복된 코드를 피하고 복잡성을 최소화하기 위해서 상속을 사용하고 있는지 확인하라.
#### 다중 상속
- 다중 상속은 객체에 일련의 속성을 추가하는 데 사용하는 간단한 클래스인 믹스인(Mixin)을 정의할 때 주로 쓸모가 있다.
- 모든 믹스인이 서로 완벽하게 독립적이기만 하면 다중 상속과 관련된 다이아몬드 상속 문제를 만들지 않는다.
#### 상속에 관한 규칙이 왜 이렇게 많은 것일까?
- 상속을 사용하면 그만큼 복잡성을 관리하기가 어렵기 때문이다.
- 복잡성을 관리하고 싶다면 상속을 최대한 멀리해야 한다.
#### 멤버 함수와 데이터
- 클래스에 가능한 한 적은 수의 루틴을 유지하라.
  - 클래스당 루틴 수가 늘어나는 것이 오류율 상승과 연관되어 있다.
- 클래스에서 호출되는 루틴의 수를 최소화하라.
  - 클래스에서 발견된 오류의 수가 루틴 내에서 호출되는 루틴의 수와 통계적으로 관련이 있다.
  - 클래스가 사용한 클래스가 많을수록 오류도 증가한다.
- 일반적으로 클래스가 다른 클래스와 협력하는 정도를 최소화하라.
#### 생성자
- 가능하다면 모든 멤버 데이터를 모든 생성자에서 초기화하라.
- 확실하지도 않은 성능 이득을 위해서 복잡성을 추가하는 것보다는 특별한 이유가 없다면 깊은 복사를 선택하라.

### 6.4 클래스를 작성하는 이유
- 클래스를 생성하는 가장 중요한 이유는 프로그램의 복잡성을 줄이는 것이다.
- 복잡성을 고립시킨다.
- 변경할 가능성이 있는 부분을 고립시켜서 변경의 효과를 단일 클래스나 소수의 클래스로 제한한다.
- 모든 것을 알고 있고 모든 것을 할 수 있는 전지전능한 클래스를 생성하지 말라.

### 체크리스트: 클래스 품질
- 클래스에 핵심적인 목적이 있는가?
- 클래스의 이름이 핵심적인 목적을 설명하는가?
- 클래스의 인터페이스가 클래스의 사용 방법을 분명하게 만들고 있는가?
- 클래스의 구현 세부 사항을 전혀 알 필요가 없을 정도로 클래스의 인터페이스가 추상적인가? 클래스를 블랙박스로 취급할 수 있는가?
- 관련 없는 정보를 클래스에서 제거했는가?
- 클래스를 컴포넌트 클래스로 분할하는 것에 대해 생각했는가? 최대한 분할했는가?


## 7장. 고급 루틴
- 루틴
  - 한 가지 목적을 위해서 호출할 수 있는 개별 메서드나 프로시저
  - 루틴은 프로그래밍 언어의 다른 어떤 기능보다도 프로그램을 읽고 이해하기 쉽게 만든다.
  - 루틴은 공간을 절약하고 성능을 향상하기 위해 발명된 가장 훌륭한 기법이기도 하다.

### 7.1 루틴을 작성하는 이유
- 복잡성을 줄인다. 프로그램의 복잡성을 줄이는 것이 루틴을 작성하는 가장 중요한 목적이다.
- 이해하기 쉬운 중간 단계의 추상화를 도입한다.
- 중복 코드를 피한다. 코드가 반복되면 루틴을 작성해야 한다.
- 클래스를 작성하는 이유의 상당수가 루틴을 작성하는 이유이기도 하다.
#### 루틴으로 작성하기에는 너무 단순해 보이는 연산
- 작은 루틴도 매우 유용하다.
  - 가독성을 향상시킨다.
  - 수정을 더 쉽게 한다. 루틴을 사용하지 않았을 때 중복되는 코드들에 수정사항이 생기면, 그 중복된 곳마다 수정을 해줘야 하는 부담을 줄일 수 있다.

### 7.2 루틴 수준의 설계
- 개별적인 루틴 수준에서는 응집성이라는 개념을 통해 설계에 도움을 받을 수 있다.
  - 루틴에서의 응집성을 루틴에 있는 연산들이 얼마나 밀접하게 연관되어 있는지를 나타낸다.
  - 즉, 루틴 내의 연산들이 얼마나 강하게 연결되어 있는지를 나타낸다.
- 루틴을 작성하는 목적은 한 가지 일을 잘하도록 하는 것이지 여러 가지 일을 처리하는 데 있지 않다.
- 가장 바람직한 응집성은 "기능적 응집성"이다. 루틴이 오직 하나의 연산만 처리하는 경우다.

### 7.3 좋은 루틴 이름
- 루틴이 하는 모든 것을 표현하라.
  - 루틴 이름에 모든 출력과 부수적인 효과를 설명하라.
  - 루틴이 가급적이면 부수적인 영향을 갖지 않도록 코드를 작성해서 루틴의 역할을 좀 더 분명하게 해야 한다.
- 의미가 없거나 모호하거나 뚜렷한 특징이 없는 동사를 사용하지 않기.
  - 해당 루틴과 관련된 루틴들을 재구성하여, 모든 루틴이 분명한 목적을 갖고 루틴의 기능을 정확하게 설명하는 이름을 갖도록 재구성하기.
- 루틴의 이름 길이에 신경 쓰지 않기.
  - 전반적으로 루틴 이름은 "명료함"에 초점을 맞춰야 한다.
  - 따라서 이름의 길이에 제약을 받지 않고 이해하기 쉽게 이름을 지어야 한다.
- 함수의 이름을 지을 때는 리턴 값에 관해서 설명하라.
- 프로시저에 객체의 이름을 포함시킬 필요가 없다.

### 7.4 루틴 길이에 대한 문제
- 결과적으로 200줄 이상의 긴 루틴을 작성하고 할 때는 주의해야 한다.

### 7.6 함수를 사용할 때 특별히 고려해야 할 사항
- 함수 이름은 언제나 함수가 반환하는 값을 고려해야 한다.


## 8장. 방어적 프로그래밍
- 방어적 프로그래밍의 핵심 개념은, 설령 다른 루틴의 잘못으로 인한 것이라도 루틴에 잘못되 데이터가 들어왔을 대 작성한 루틴에 아무런 문제가 발생하지 않도록 하는 데 있다.
  - 프로그램은 언제나 문제가 있고 지속해서 변경될 것이고, 똑똑한 개발자는 그러한 상황에 대처할 수 있는 코드를 개발할 것이다.

### 8.1 잘못된 입력으로부터 프로그램 보호
- 좋은 프로그램은 쓰레기를 입력받았더라도 절대로 쓰레기를 내보내지 않는다.
  - 쓰레기를 넣으면 아무것도 안 나오거나,
  - 쓰레기를 넣으면 오류 메시지를 출력하거나,
  - 어떤 쓰레기도 허용하지 않아야 한다.
- 엉성하고 안전하지 못한 프로그램만 "쓰레기를 넣으면 쓰레기가 나온다."
- 쓰레기 입력을 처리하기 위한 세 가지 방법
  - 외부로부터 들어오는 모든 데이터의 값을 검사한다.
  - 루틴의 모든 입력 매개변수 값을 검사한다.
  - 잘못된 입력을 어떻게 처리할지 결정한다.

### 8.2 어설션
- Assertion은 대게 루틴이나 매크로 실행 시 프로그램이 스스로 검사할 수 있도록 사용하는 코드다.
- 코드에서 가정한 것을 문서화하고 예상치 못한 조건을 찾아내기 위해서 어설션을 사용하라.
- 어설션은 일반적으로 개발 버전에서는 코드에 포함되어 컴파일되지만, 제품에서는 제외된다.

#### 어설션 사용 지침
- 발생이 예상되는 상황은 오류 처리 코드를 사용하고, 절대로 발생해서는 안 되는 조건은 어설션을 사용한다.
- 선행 조건과 후행 조건을 문서화하고 검증하는 데 어설션을 사용하라
  - 선행 조건: 루틴이나 클래스에서 다른 루틴을 호출하거나 객체를 생성하기 전에 반드시 참이어야 하는 특징. 루틴을 호출하는 쪽에서 반드시 지켜야 한다.
  - 후행 조건: 루틴이나 클래스를 호출하고 난 후에 반드시 참이어야 하는 조건. 호출된 코드나 클래스가 지켜야 한다.

### 8.3 오류 처리 기법
#### 견고함 대 정확성
- 정확성
  - 절대로 부정확한 결과를 반환할 수 없다는 것을 의미한다.
  - 부정확한 결과를 반환하는 것보다 아무 결과를 반환하지 않는 것이 더 좋다.
- 견고함
  - 부정확한 결과를 만들어 내더라도 소프트웨어가 작동할 수 있도록 계속 무언가를 하려고 애쓰는 것을 의미한다.
#### 오류 처리를 위한 상위 수준에서의 설계
- 접근 방법을 선택하고 나면 일관성 있게 따라야 한다.

### 8.4 예외
