# [Code Complete 코드 컴플리트](https://search.shopping.naver.com/book/catalog/32478362459?cat_id=50010921&frm=PBOKPRO&query=Code+Complete&NaPm=ct%3Dmchh3jm8%7Cci%3D7c151d6319ecadc0116fc3b9c817860c033f2c68%7Ctr%3Dboknx%7Csn%3D95694%7Chk%3D6aab9121bce2be515c85c038f2d6b7bd5a6fe006)
- 지은이: 스티브 맥코넬 (서우석)
- 출판사: 위키북스
- 읽은 날짜: 2025.06.29 ~ 2025.

## 6장. 클래스 다루기
- 클래스는 연관성이 높고 잘 정의된 기능을 공유하는 데이터와 루틴의 모음이다.
  - 능력 있는 개발자가 되려면 현재 작업 중인 코드에 집중할 수 있게 프로그램에서 무시할 수 있는 부분을 최대화할 수 있어야 한다.
  - 클래스는 그러한 목표를 달성하기 위한 일차적인 도구다.

### 6.1 클래스의 토대: 추상 데이터형
- 추상 데이터형(Abstract Data Type, ADT)은 데이터와 데이터를 처리하는 연산의 집합이다.
  - 연산은 프로그램의 나머지 부분에 데이터가 무엇인지를 설명해주는 역할과 나머지 프로그램에서 그 데이터를 변경할 수 있게 해주는 역할을 한다.
- 객체 지향 프로그래밍을 이해하기 위해서는 ADT를 반드시 이해해야 한다.
  - ADT를 이해하지 못한다면 이름만 "클래스"인 클래스를 작성할 것이다.
  - 그런 클래스는 실제로는 연관성이 높지 않은 데이터와 루틴을 편의를 위해 보관하는 상자와 다를 게 없다.
- 전형적인 저수준 데이터형을 저수준 데이터형이 아닌 ADT로 만들거나 사용하라.
  - 사실상 모든 전형적인 데이터형을 ADT로 표현할 수 있다.

### 6.2 좋은 클래스 인터페이스
- 고급 클래스를 만들기 위한 가장 중요한 단계는 좋은 인터페이스를 만드는 것이다.
  - 표현하고자 하는 인터페이스를 잘 추상화하여 구현 세부 사항이 외부에 드러나지 않도록 한다.
#### 좋은 추상화
- 추상화는 복잡한 연산을 단순환 형태로 보여주는 능력이다.
- 클래스 인터페이스는 서로 밀접한 루틴들을 제공해야 한다.
- 클래스 추상화에 대한 평가는 공개 루틴의 집합, 즉 클래스의 인터페이스를 기초로 한다.
- 클래스 인터페이스가 일관된 추상화 수준을 갖도록 한다.
  - 각 클래스는 오직 하나의 ADT만 구현해야 한다.
- 클래스가 구현하고 있는 추상화가 무엇인지 이해해야 한다.
- 관련이 없는 정보를 다른 클래스로 옮겨라.
- 코드 변경 시 인터페이스의 추상화가 망가지지 않도록 주의한다.
- 인터페이스 추상화에 맞지 않는 공개 멤버를 추가하지 말라.
- 추상화와 응집도를 함께 고려하라.
  - 추상화와 응집도는 개념적으로 밀접한 연관이 있다.
  - 좋은 추상화를 제공하는 클래스 인터페이스는 일반적으로 강한 응집도를 갖는다.
#### 좋은 캡슐화
- 캡슐화는 세부 사항을 알고 싶어 할 때조차 이를 원천적으로 봉쇄해버리는 더 강력한 방법이다.
- 캡슐화 없이는 추상화가 꺠질 수 있기 때문에 이 두 개념은 연관되어 있다.
  - 경험상 추상화와 캡슐화 모두 갖고 있든지 둘 다 없든지 둘 중 하나다. 중간은 없다.
- 클래스와 멤버의 접근성을 최소화하라.
  - 중요한 지침은 "어떻게 해야 인터페이스 추상화의 무결성을 최상으로 유지할 수 있는가?"
  - 노출시키는 루틴이 추상화와 일관성이 있다면 노출시켜도 크게 문제가 없을 것이다.
  - 확신이 서지 않으면 일반적으로 숨기는 것이 숨기지 않는 것보다 낫다.
- 클래스의 사용자를 가정하지 말라.
  - 인터페이스 문서에 적혀 있는 것 외에는 인터페이스가 어떻게 사용될 것인지 또는 어떻게 사용되지 않을 것인지에 대해서 어떠한 가정도 해서는 안 된다.
- 인터페이스 문서만으로 클래스를 어떻게 사용해야 할지 알아낼 수 없을 때 소스코드를 꺼내서 구현부를 보는 것은 올바른 대처가 아니다.
  - 클래스의 개발자에게 연락해서 "클래스를 어떻게 사용해야 할지 잘 모르곘습니다."라고 말해야 한다.

### 6.3 설계와 구현 문제
- 상속은 코드와 데이터를 기본 클래스에 집중시킴으로써 여러 위치에서 반복적으로 사용하는 것을 피하게 해준다.
  - 파생 클래스는 기존 클래스의 특수화된 버전"이다."(is-a)
  - 상속은 프로그램을 복잡하게 만들기 때문에 위험하다.
- 리스코프 치환 원칙 : 서브클래스는 사용자가 그 차이점을 모른 채 기본 클래스의 인터페이스를 통해서 사용할 수 있어야 한다.
- 개발자가 서브 클래스를 구현할 때 의미적인 차이점에 대해서 끊임없이 생각해야 한다면 상속이 복잡성을 줄이기보다 늘리는 격이 된다.
- 인터페이스는 필요 없고 구현만 사용하고 싶다면 상속 대신 포함을 사용하라.
- 공통으로 사용되는 인터페이스와 데이터, 행위를 상속 단계에서 가능한 가장 높은 곳으로 옮겨라.
- 파생 클래스가 하나뿐인 기본 클래스를 의심하라.
  - 앞으로를 대비하는 가장 좋은 방법은 "언젠가는 구현될지도 모르는" 기본 클래스의 추가적인 계층을 설계하는 것이 아니라 가능한 현재의 작업을 분명하고 직관적이며 단순하게 만드는 것이다.
  - 필요한 것 이상으로 상속 구조를 만들면 안 된다.
- 깊은 상속 구조를 피하라.
  - 대부분의 사람이 상속 구조가 두세 단계 이상 되면 이해하는데 어려움을 겪었다.
  - 깊은 상속 구조는 오류의 증가와 깊이 연관되어 있다.
- 중복된 코드를 피하고 복잡성을 최소화하기 위해서 상속을 사용하고 있는지 확인하라.
#### 다중 상속
- 다중 상속은 객체에 일련의 속성을 추가하는 데 사용하는 간단한 클래스인 믹스인(Mixin)을 정의할 때 주로 쓸모가 있다.
- 모든 믹스인이 서로 완벽하게 독립적이기만 하면 다중 상속과 관련된 다이아몬드 상속 문제를 만들지 않는다.
#### 상속에 관한 규칙이 왜 이렇게 많은 것일까?
- 상속을 사용하면 그만큼 복잡성을 관리하기가 어렵기 때문이다.
- 복잡성을 관리하고 싶다면 상속을 최대한 멀리해야 한다.
#### 멤버 함수와 데이터
- 클래스에 가능한 한 적은 수의 루틴을 유지하라.
  - 클래스당 루틴 수가 늘어나는 것이 오류율 상승과 연관되어 있다.
- 클래스에서 호출되는 루틴의 수를 최소화하라.
  - 클래스에서 발견된 오류의 수가 루틴 내에서 호출되는 루틴의 수와 통계적으로 관련이 있다.
  - 클래스가 사용한 클래스가 많을수록 오류도 증가한다.
- 일반적으로 클래스가 다른 클래스와 협력하는 정도를 최소화하라.
#### 생성자
- 가능하다면 모든 멤버 데이터를 모든 생성자에서 초기화하라.
- 확실하지도 않은 성능 이득을 위해서 복잡성을 추가하는 것보다는 특별한 이유가 없다면 깊은 복사를 선택하라.

### 6.4 클래스를 작성하는 이유
- 클래스를 생성하는 가장 중요한 이유는 프로그램의 복잡성을 줄이는 것이다.
- 복잡성을 고립시킨다.
- 변경할 가능성이 있는 부분을 고립시켜서 변경의 효과를 단일 클래스나 소수의 클래스로 제한한다.
- 모든 것을 알고 있고 모든 것을 할 수 있는 전지전능한 클래스를 생성하지 말라.

### 체크리스트: 클래스 품질
- 클래스에 핵심적인 목적이 있는가?
- 클래스의 이름이 핵심적인 목적을 설명하는가?
- 클래스의 인터페이스가 클래스의 사용 방법을 분명하게 만들고 있는가?
- 클래스의 구현 세부 사항을 전혀 알 필요가 없을 정도로 클래스의 인터페이스가 추상적인가? 클래스를 블랙박스로 취급할 수 있는가?
- 관련 없는 정보를 클래스에서 제거했는가?
- 클래스를 컴포넌트 클래스로 분할하는 것에 대해 생각했는가? 최대한 분할했는가?


## 7장. 고급 루틴
- 루틴
  - 한 가지 목적을 위해서 호출할 수 있는 개별 메서드나 프로시저
  - 루틴은 프로그래밍 언어의 다른 어떤 기능보다도 프로그램을 읽고 이해하기 쉽게 만든다.
  - 루틴은 공간을 절약하고 성능을 향상하기 위해 발명된 가장 훌륭한 기법이기도 하다.

### 7.1 루틴을 작성하는 이유
- 복잡성을 줄인다. 프로그램의 복잡성을 줄이는 것이 루틴을 작성하는 가장 중요한 목적이다.
- 이해하기 쉬운 중간 단계의 추상화를 도입한다.
- 중복 코드를 피한다. 코드가 반복되면 루틴을 작성해야 한다.
- 클래스를 작성하는 이유의 상당수가 루틴을 작성하는 이유이기도 하다.
#### 루틴으로 작성하기에는 너무 단순해 보이는 연산
- 작은 루틴도 매우 유용하다.
  - 가독성을 향상시킨다.
  - 수정을 더 쉽게 한다. 루틴을 사용하지 않았을 때 중복되는 코드들에 수정사항이 생기면, 그 중복된 곳마다 수정을 해줘야 하는 부담을 줄일 수 있다.

### 7.2 루틴 수준의 설계
- 개별적인 루틴 수준에서는 응집성이라는 개념을 통해 설계에 도움을 받을 수 있다.
  - 루틴에서의 응집성을 루틴에 있는 연산들이 얼마나 밀접하게 연관되어 있는지를 나타낸다.
  - 즉, 루틴 내의 연산들이 얼마나 강하게 연결되어 있는지를 나타낸다.
- 루틴을 작성하는 목적은 한 가지 일을 잘하도록 하는 것이지 여러 가지 일을 처리하는 데 있지 않다.
- 가장 바람직한 응집성은 "기능적 응집성"이다. 루틴이 오직 하나의 연산만 처리하는 경우다.

### 7.3 좋은 루틴 이름
- 루틴이 하는 모든 것을 표현하라.
  - 루틴 이름에 모든 출력과 부수적인 효과를 설명하라.
  - 루틴이 가급적이면 부수적인 영향을 갖지 않도록 코드를 작성해서 루틴의 역할을 좀 더 분명하게 해야 한다.
- 의미가 없거나 모호하거나 뚜렷한 특징이 없는 동사를 사용하지 않기.
  - 해당 루틴과 관련된 루틴들을 재구성하여, 모든 루틴이 분명한 목적을 갖고 루틴의 기능을 정확하게 설명하는 이름을 갖도록 재구성하기.
- 루틴의 이름 길이에 신경 쓰지 않기.
  - 전반적으로 루틴 이름은 "명료함"에 초점을 맞춰야 한다.
  - 따라서 이름의 길이에 제약을 받지 않고 이해하기 쉽게 이름을 지어야 한다.
- 함수의 이름을 지을 때는 리턴 값에 관해서 설명하라.
- 프로시저에 객체의 이름을 포함시킬 필요가 없다.

### 7.4 루틴 길이에 대한 문제
- 결과적으로 200줄 이상의 긴 루틴을 작성하고 할 때는 주의해야 한다.

### 7.6 함수를 사용할 때 특별히 고려해야 할 사항
- 함수 이름은 언제나 함수가 반환하는 값을 고려해야 한다.


## 8장. 방어적 프로그래밍
- 방어적 프로그래밍의 핵심 개념은, 설령 다른 루틴의 잘못으로 인한 것이라도 루틴에 잘못되 데이터가 들어왔을 대 작성한 루틴에 아무런 문제가 발생하지 않도록 하는 데 있다.
  - 프로그램은 언제나 문제가 있고 지속해서 변경될 것이고, 똑똑한 개발자는 그러한 상황에 대처할 수 있는 코드를 개발할 것이다.

### 8.1 잘못된 입력으로부터 프로그램 보호
- 좋은 프로그램은 쓰레기를 입력받았더라도 절대로 쓰레기를 내보내지 않는다.
  - 쓰레기를 넣으면 아무것도 안 나오거나,
  - 쓰레기를 넣으면 오류 메시지를 출력하거나,
  - 어떤 쓰레기도 허용하지 않아야 한다.
- 엉성하고 안전하지 못한 프로그램만 "쓰레기를 넣으면 쓰레기가 나온다."
- 쓰레기 입력을 처리하기 위한 세 가지 방법
  - 외부로부터 들어오는 모든 데이터의 값을 검사한다.
  - 루틴의 모든 입력 매개변수 값을 검사한다.
  - 잘못된 입력을 어떻게 처리할지 결정한다.

### 8.2 어설션
- Assertion은 대게 루틴이나 매크로 실행 시 프로그램이 스스로 검사할 수 있도록 사용하는 코드다.
- 코드에서 가정한 것을 문서화하고 예상치 못한 조건을 찾아내기 위해서 어설션을 사용하라.
- 어설션은 일반적으로 개발 버전에서는 코드에 포함되어 컴파일되지만, 제품에서는 제외된다.

#### 어설션 사용 지침
- 발생이 예상되는 상황은 오류 처리 코드를 사용하고, 절대로 발생해서는 안 되는 조건은 어설션을 사용한다.
- 선행 조건과 후행 조건을 문서화하고 검증하는 데 어설션을 사용하라
  - 선행 조건: 루틴이나 클래스에서 다른 루틴을 호출하거나 객체를 생성하기 전에 반드시 참이어야 하는 특징. 루틴을 호출하는 쪽에서 반드시 지켜야 한다.
  - 후행 조건: 루틴이나 클래스를 호출하고 난 후에 반드시 참이어야 하는 조건. 호출된 코드나 클래스가 지켜야 한다.

### 8.3 오류 처리 기법
#### 견고함 대 정확성
- 정확성
  - 절대로 부정확한 결과를 반환할 수 없다는 것을 의미한다.
  - 부정확한 결과를 반환하는 것보다 아무 결과를 반환하지 않는 것이 더 좋다.
- 견고함
  - 부정확한 결과를 만들어 내더라도 소프트웨어가 작동할 수 있도록 계속 무언가를 하려고 애쓰는 것을 의미한다.
#### 오류 처리를 위한 상위 수준에서의 설계
- 접근 방법을 선택하고 나면 일관성 있게 따라야 한다.

### 8.4 예외
- 루틴에서 코드가 어떻게 처리해야 하는지를 모르는 예외적인 상황에 부딪히면 예외를 던진다.
- 예외를 사용해 무시되어서는 안 되는 오류를 프로그램의 다른 부분에 알린다.
- 예외는 절대로 일어나서는 안 되는 경우에 사용한다.
- 루틴에서 발생하는 예외는 다른 데이터형과 마찬가지로 루틴 인터페이스의 일부다.
- 예외를 발생시킨 모든 정보를 예외 메시지에 포함한다.

### 8.5 오류로 인한 손해를 막기 위한 방책
- 클래스의 공개 메서드는 데이터가 안전하지 않다고 가정하고 데이터를 검사하고 깨끗하게 만들어야 할 책임이 있다.
  - 데이터가 공개 메서드에 전달되고 나면 비공개 메서드는 그 데이터가 안전하다고 생각할 수 있다.
- 데이터가 입력되지마자 입력 데이터를 적절한 형태로 변환하라.
- 외부에 노출된 메서드에서는 예외를, 내부에서는 단언(어설션)을 사용하라.

### 8.6 디버깅 보조 도구
- 오류를 빠르게 발견하기 위함이다.
- 개발 중에는 개발을 좀 더 원활히 진행하도록 도와주는 도구를 사용한다.
  - 배포 버전과 동일한 제약 사항을 가할 필요는 없다.
- 예외적인 경우에는 개발 중에도 눈에 띄어야 하고 배포되는 버전의 코드가 실행 중일 때는 복구가 가능한 방법으로 처리되어야 한다.
- 배포 버전에서는 디버깅 보조 도구를 제거하라.

### 8.7 제품 코드를 얼마나 방어적으로 프로그래밍할 것인지 정하기
- 개발 과정 중에는 오류가 눈에 띄는 것이 낫다.
- 제품 개발 시에는 가능한 한 오류가 보이지 않도록 하고 프로그램이 복구되거나 품위 있게 실패하는 편이 낫다.
- 중요한 오류를 검사하는 코드는 남겨라.
- 오류가 정말로 사소하게 영향을 미친다면 오류 검사 코드를 제거한다.
- 오류 메시지가 친절한지 확인한다.
### 8.8 방어적 프로그래밍에 대해서 한 번 더 고민하기
- 모든 곳에서 매개변수를 검사하면 프로그램이 비대해지고 느려진다.
- 방어적일 필요가 있는 곳을 생각한 후, 우선순위를 정한다.


## 9장. 의사코드 프로그래밍 프로세스(PPP)
- 루틴과 클래스를 구현하기 위한 방법 중 하나.

### 9.1 클래스 및 루틴 개발 단계 요약
- 클래스 구현 방법
  1. 클래스에 대한 일반적인 설계를 작성한다.
    - 클래스의 구체적인 책임을 정의하고
    - 클래스가 숨길 "비밀"이 무엇인지 정의하고
    - 클래스 인터페이스가 추구할 추상화가 무엇인지 정확하게 정의한다.
  2. 클래스 내의 구체적인 루틴을 열거한다.
  3. 루틴을 구현한다.
  4. 전체적으로 클래스를 구현을 검사한다.
    - 각 루틴은 작성하면서 테스트한다.

### 9.2 전문가를 위한 의사코드
- 의사코드: 프로그램이 어떻게 작동할지 기술하는 자연어 문장과 같은 표기
  - 의사코드는 목적에 좀 더 초점을 맞춘다.
  - 특정 프로그래밍 언어의 문법적 요소를 피한다.
- 의사코드의 장점은, 주석 작업을 최소화할 수 있다는 것이다. (구현하면서 최소한의 의사코드로 정리한다.)

### 9.3 PPP를 이용한 루틴 구현
1. 루틴을 설계한다.
   - 선행 조건 검사
   - 루틴이 해결할 문제 정의
   - 루틴의 이름 결정
   - 루틴을 어떻게 테스트할 것인지 결정
   - 다른 코드를 재사용 가능한지 검토
   - 오류 처리를 생각
   - 자원과 속도의 목표를 설계
     - 성능에 문제가 있다고 판명되기 전까지는 미세한 부분을 개선하느라 시간을 낭비하지 않아야 한다.
   - 의사코드를 작성/검토
     - 다른 사람에게 "의사코드"를 검토받는 것 또한 의미가 있다. (코드보다 더 쉽게 읽을 수 있다.)
2. 루틴을 구현한다.
   - 루틴의 선언부 작성
   - 의사코드를 고수준의 주석으로 변환
   - 각 주석마다 코드를 작성
   - 코드를 더 나눠야 하는지 검사
     - 주석 아래의 코드가 비대해진다면, 별도의 루틴으로 나누거나 의사코드를 더 상세하게 작성한다.
3. 코드를 검사한다.
   - 구현한 코드가 정확한가?
   - 찾을 수 있는 모든 오류를 찾아야 한다. 나중에 수정하려고 하면 비용이 더 많이 든다.
   - 작동하는 루틴만으로는 충분하지 않다. 왜 작동하는지를 모른다면 알 때까지 연구하고 토론하고 다른 설계로 실험해 본다.
   - 컴파일러의 모든 오류 메시지와 경고의 원인을 제거한다.
4. 나머지를 정리한다.
5. 필요한 만큼 반복한다.


## 3부. 변수
## 10장. 변수 사용 시 고려할 사항
### 10.4 범위
- 한 번에 기억해야 하는 코드 줄 수가 적을 수록 코드는 더욱 이해하기 쉬워진다.
### 10.8 변수를 한 가지 목적으로만 사용하기
- 숨은 의미가 있는 변수를 피하라.
    - 변수를 이중 목적으로 사용하는 것이 자신에게는 명백해 보일지라도 다른 사람에게는 그렇지 않다.


## 11장. 변수 이름의 기능
### 11.1 좋은 이름을 위한 고려 사항
- 결과적으로 변수의 좋고 나쁨은 그 이름에 의해 주로 좌우된다.
- 변수 이름을 지을 때 그 이름이 변수가 나타내는 것을 완전하고 정확하게 설명하는지를 가장 중요하게 고려해야 한다.
- 변수가 표현하는 것을 단어로 서술하라.
- 이름은 가능한 한 구체적이어야 한다.
- 좋은 이름은 "어떻게"보다 "무엇"을 표현하는 경향이 있다.
- 변수 이름의 길이는 10~16자 사이가 디버깅하기에 좋다.
- 긴 이름은 거의 사용하지 않는 변수나 전역 변수에 좋고 짧은 이름은 지역 변수나 반복문 변수에 좋다.
- 코드에서 직관적으로 이해하지 못하는 부분이 있다면 변수의 이름을 다시 만들어라.
- 어떤 규약이든지 없는 것보다는 있는 게 낫다.
- 일반적으로 필요한 형식화 정도는 프로그램에서 작업하는 사람들의 수와 프로그램의 크기, 프로그램의 예상 수명에 따라서 달라진다.


## 12장. 기본 데이터형
- 크게 차이가 나는 숫자를 더해야 한다면, 우선 숫자를 구분하고 가장 작은 값부터 더한다.
- 판별식을 boolean 변수로 치환하고, 변수명으로 설명하면 가독성이 좋다.


## 4부 명령문
## 14장. 순차적 코드 구성하기
- 명령문이 특정한 순서로 작성되어야 하는 의존성을 갖고 있을 때는 의존성을 분명히 하기 위한 단계를 밟아야 한다.

### 14.2 순서가 중요하지 않은 명령문
- 기본 가이드라인: 연관된 작업을 함께 두는 근접성 원칙을 따른다.
- 프로그램을 여기저기 건너뛰지 않고 하향식으로 읽을 수 있게 개발하라.
  - 전문가들은 하향식 순서가 가독성에 가장 많은 영향을 미친다고 말한다.
- 코드를 그룹화하면 아주 밀접하면서도 전후 코드와는 아무 관계가 없는 코드를 발견하게 된다.
  - 그런 경우에는 밀접하게 연관된 코드를 별도의 루틴으로 리팩터링한다.


## 15장. 조건문 사용
- 가독성을 위한 팁
  - 일반적인 경우를 처리하는 코드를 먼저 작성하고 특별한 경우를 처리하라.
  - 정상적인 경우를 if문에 입력하기. else는 특별한 경우를 위해 쓴다.
  - else if가 들어가는 경우, 가장 흔한 경우를 첫 if에 배치하라.
- (코틀린 when, 자바 switch문) 기본값이 유효한 경우에만 default를 사용한다.
  - 오류를 발견하지 못할 가능성이 생긴다.
  - 가장 마지막 branch는 오류를 던져라.

## 16장. 반복문 제어
- 일반적으로, 모든 종료 조건을 한 곳에 입력한다.
  - 종료 조건을 분산시켜 놓으면 사실상 하나 또는 그 이상의 종료 조건을 디버깅이나 수정, 테스팅 중에 못 보고 지나치게 되기 때문이다.
- 머릿속에서 프로그램을 돌려보는 습관을 가져라.
  - 초기 코드 작성 시 오류가 적게 발생한다.
  - 디버깅 시 오류를 더 빨리 발견할 수 있다.
  - 프로그램에 대한 전체적인 이해도가 좋아진다.
  - 코드가 어떻게 동작하는지를 이해하고 있다는 것을 의미한다.
### 16.3 반복문을 쉽게 작성하는 법 - 안에서부터 밖으로
- 하나의 경우로 시작하라.
  - 그 경우를 문장으로 작성한 다음 들여쓰기 하고 그 문장 주위에 반복문을 입력한다.
  - 문장을 반목문 인덱스나 계산 표현식으로 바꾼다.
  - 기능을 완성할 때까지 이 과정을 반복한다.
  - 작업을 마치고 나서 필요한 모든 초기화 작업을 추가한다.

## 17장. 특이한 제어 구조
### 17.2 재귀문
- 재귀문은 일반적으로 문제의 작은 부분이 해결하기가 쉽고 큰 부분을 더 작게 쉽게 나눌 수 있는 경우에 사용.
- 일반적으로 유용하지 않음.

## 19장. 제어와 관련된 일반적인 이슈
### 19.4 지나치게 깊은 중첩 구조 처리
- 들여쓰기("중첩구조")의 깊이가 지나치게 깊은 코드는 25년 동안 잘못된 것으로 여겨져 왔으며 여전히 코드를 이해하기 어렵게 만드는 주범 가운데 하나다.
- 코드가 복잡하다는 것은 코드를 단순하게 작성할 수 있을 만큼 프로그램을 충분히 이해하지 못한다는 것을 의미한다.
  - 깊은 중첩 구조는 루틴을 분리하거나 복잡한 코드의 일부부분을 재설계할 필요가 있다는 경고다.
  - 반드시 해당 루틴을 수정해야 하는 것은 아니지만, 그렇게 하지 않는 경우 충분한 이유가 있어야 한다.

### 19.5 프로그래밍 기초: 구조적 프로그래밍
- 구조적 프로그래밍의 핵심은 오직 하나의 입구와 출구만이 있는 제어 구조(단일 진입점과 단일 탈출점 제어)를 사용해야 한다는 간단한 개념이다.
#### 복잡도를 줄이기 일반적인 방법
- 프로그램을 이해하기 위해 집중해야 하는 대상의 수를 줄인다.

## 5부. 코드 향상
## 20장. 소프트웨어 품질
#### 20.1 소프트웨어 품질의 특성
- 품질
  - 외적인 특성 : 사용하기 쉬운가? 정확하게 작동하는가?
  - 내적인 특성 : 변경하기 쉬운가? 코드가 읽기 쉽고 구조가 좋은가?

#### 20.2 소프트웨어의 품질을 향상시키기 위한 방법
- 품질에 대한 팀 간의 합의가 있어야 한다.
  - 빠르지만 지저분한 프로그래밍을 허용하는 팀 문화에서는 품질의 우선순위가 떨어지므로, 품질 보증이 안 될 가능성이 높다.
- 소프트웨어 품질 보증은 소프트웨어 개발 프로세스에도 초점을 맞춰야 한다.
- 품질 보증을 포함한 개발 노력이 품질 보증 작업을 하지 않는 개발 노력보다 더 훌륭한 소프트웨어를 만든다.
- 변경을 효과적으로 관리하는 것이 높은 품질을 유지할 수 있게 한다.
- 품질 보증 계획의 결과를 측정하라.
- 품질 목표를 명확하게 설정하라.
  - 다만, 일반적으로 모든 목표에 대해 잘하기란 불가능하다.

### 20.3 품질 향상 기법의 상대적 효과성
- 결함 감지 기법들은 단독으로 사용할 때보다 여러 개를 사용할 때 더 좋은 결과를 가져온다.
- 직접하는 테스트보다 코드 검토가 오류를 찾는데 시간이 덜 걸린다.

### 20.5 소프트웨어 품질의 일반적인 원칙
- 소프트웨어 품질의 일반적인 원칙은 품질의 향상으로 개발 비용을 줄일 수 있다는 것이다.
- 생산성과 품질을 향상시키기 가장 좋은 방법은 코드를 다시 작성하는 데 걸리는 시간을 줄이는 것이다.
  - 대부분의 프로젝트에서 가장 큰 활동은 정상적으로 작동하지 않는 코드를 디버깅하고 수정하는 것이다.
- 오류를 예방하여 디버깅을 줄이면 생산성이 향상된다.
- 개발 일정을 줄이는 가장 확실한 방법은 제품의 품질을 향상시키고 디버깅과 소프트웨어의 수정 작업으로 낭비되는 시간을 줄이는 것이다.
- 소프트웨어 결함 제거가 실제로 소프트웨어 개발에 있어서 가장 큰 비용을 유발하고 가장 많은 시간을 낭비하는 작업 형태다.
- 결함이 없는 소프트웨어를 작성하는 것이 결함이 있는 소프트웨어를 작성하는 것보다 더 많은 시간이 걸리는 것은 아니다. 더 적게 걸릴 수도 있다.

## 21장. 협력 구현
- 모든 협력 구현 기법은 오류 해결을 목적으로 자신의 작업 내용을 다른 사람에게 보여주는 과정을 형식화하려는 시도다.


### 21.1 협력 개발 방법 개요
- 협력 구현은 개발자들이 코드 작성과 제품 개발에 관련된 다른 작업에 대한 책임을 공유하는 데 사용하는 기법을 가르킨다.
- 개발자가 자신의 작업에 있는 문제점을 일부 보지 못한다는 점과 다른 사람들은 그 부분을 볼 수 있다는 점, 다른 개발자가 자신의 작업을 봐주는 게 도움이 된다는 개념을 기초로 한다.
- 협력 구현은 오류를 잡는 데 테스트보다 훨씬 효과적이고, 다른 종류의 오류를 발견할 수 있다.
- 협력을 구현 전 만큼이나 구현 후에도 적용하라.

### 21.2 짝 프로그래밍
- 짝 프로그래밍은 한 개발자는 키보드로 코드를 입력하고, 다른 개발자는 실수를 감시하고 코드가 정확하게 작성되고 있고 올바른 코드가 작성되고 있는지에 대해서 전략적으로 생각한다.
  - 키보드가 없는 사람이 적극적으로 프로그래밍에 참여해야 한다. 감시가 되면 안 된다.
    - 코드를 분석하고, 다음엔 어떤 코드를 작성할지 미리 생각하고 설계를 평가하고 코드를 테스트하기 위한 방법을 계획해야 한다.
  - 짝 프로그래밍을 강요하지 마라. 혼자 설계하는 것이 더 낫기도 하다.
  - 초보끼리 짝 짓지 않는다.

### 21.3 형식적인 정밀 검토
- 정밀 검토는 결함 수정이 아닌 발견에 중점을 둔다.
- 정밀 검토의 결과가 성능을 평가하기 위한 수단으로 사용되어서는 안 된다.
  - 정밀 검토 단계에서 코드는 여전히 개발 단계에 있다.
  - 성능 평가는 완성된 제품을 바탕으로 하는 것이다.
- 정밀 검토는 비판이나 논쟁이 아니다.
  - 정밀 검토가 프로그램 개선할 수 있다는 확신을 줄 수 있어야 하고, 무언가 배울 수 있는 경험이 되는 긍정적인 효과를 가져와야 한다.
  - 비판이나 논쟁이 일어난다면, 중재자는 그 발언이 부적합함을 확실하게 설명해야 한다.
- 시간은 2시간으로 제한하라. 하루 2시간이다.


## 22장. 개발자 테스트
### 22.1 소프트웨어 품질에서 개발자 테스트의 역할
- 테스트 자체는 소프트웨어 품질을 향상시키지 않는다.
  - 테스트는 오류가 없다는 것을 완벽하게 증명할 수 없다.
  - 소프트웨어 품질을 향상시키고 싶다면 테스트를 더 많이 하지 말고 개발을 더 잘해야 한다.
- 여러 개의 메서드를 작성하고 있다면 한 번에 하나씩 테스트하라.

### 22.2 개발자 테스트에 대한 바람직한 접근 방법
- 요구사항 테스트를 최대한 일찍 계획하라.
- 제품과 함께 테스트 케이스를 설계한다.
- 테스트 케이스를 먼저 작성하라. 요구사항을 살필 수 있고, 결함을 미리 발견할 수 있다.
- 개발자 테스트에는 한계가 있다. 엣지 케이스를 놓칠 수 있다.
  - 독립적인 테스트(QA)와 협력적인 구현 기법 등 다른 기법으로 보완해야 한다.

### 22.3 여러 가지 교묘한 테스트 방법
- 완전한 테스트는 불가능하다.
- 가장 오류를 잘 발견할 것 같은 테스트케이스를 선택하는 것이 테스트의 기술이다.
- 루틴을 짧고 간단하게 유지하면 테스트하기가 쉽다.
  - 하나의 메서드에 복잡한 if 조건들이 다수 있다면 그 메서드에 대해 테스트해야 할 경우의 수가 너무 많아진다.
- 대부분의 오류는 결점이 상당히 많은 루틴 몇 개에 집중되는 경향이 있다.

### 22.6 테스트를 향상시키는 방법
- 변경 후에도 변경 전의 모든 테스트를 통과할 수 있는지 확인하라. (=회귀 테스트)
- 테스트를 자동화하라. 특히 회귀 테스트는 자동화해야 한다.

## 23장. 디버깅
- 오류가 처음에는 자신의 잘못이 아닌 것처럼 보여도 자신의 잘못일 거라고 가정하는 것이 매우 중요하다.
- 디버깅은 결함을 찾고 이해하는 것이 전체 작업의 90%다.
- 과학적인 디버깅 방법
  - 오류를 재현한다.
  - 오류의 원인을 찾아낸다.
    - 결함을 만드는 데이터를 수집한다.
    - 수집된 데이터를 분석하고 결함에 대한 가설을 세운다.
    - 프로그램을 테스트하거나 코드를 살펴봄으로써 가설을 증명하거나 반증할 방법을 결정한다.
    - 가설을 증명하거나 반증한다.
  - 결함을 수정한다.
  - 수정 내용을 테스트한다.
  - 유사한 오류를 찾는다.
- 결함을 찾는 팁
  - 프로그램에 대해 다른 사람과 이야기를 나누어라. 말하다 보면 무언가를 발견한다.
  - 문제로부터 떨어져 휴식을 취하라.
  - 가설을 많이 세워보기.
  - 실험한 테스트를 통해 원인의 범위를 좁히기.

### 23.3 결함 수정
- 수정하기 전에 문제와 프로그램을 제대로 이해할 것.
- 문제를 급하게 해결하려고 하는 것은 가장 쉽게 시간을 낭비하는 것이다.
- 증상이 아니라 문제를 해결하라. 증상을 해결하는 것은 더 나빠지는 것이다.
- 코드를 이해하지 않고 코드를 변경하지 마라. 그러고도 괜찮길 바란다면, 그것은 주술적 프로그래밍이다.
- 가장 효과적인 디버깅은, 디버깅과 관련이 없는 부분을 없애는 것이다. 검색 영역을 좁혀라.

### 23.5 디버깅 도구 - 분명한 도구와 그렇지 않은 도구
- 변경사항 Diff 보기
- 컴파일러 경고 무시하지 않기. 경고를 오류로 취급하라.

## 24장. 리팩터링
### 24.1 소프트웨어 진화의 종류
- 코드를 변경해야 할 때 나중에 쉽게 변경할 수 있도록 향상시키려고 노력해야 한다.

### 24.2 리팩터링 소개
- 마틴 파울러 "리팩터링이란, 소프트뤠어를 더 쉽게 이해하고 적은 비용으로 수정할 수 있도록 외부 동작의 변화 없이 내부 구조를 변경하는 것"
- 미래에 있을, 미지의 요구사항을 대비해 미리 설계하지 마라.
  - 그저 현재 필요한 코드를 분명하고 직관적으로 작성하라.
  - 오히려 그래야 미래에 수정하기 더 쉽다.

### 24.3 구체적인 리팩터링
- 표현식의 목적을 잘 요약한 이름을 붙인 중간 변수를 활용하기

### 24.4 안전한 리팩터링 방법
- 리팩터링 전에 코드를 저장한다.
- 체크포인트를 자주 설정한다.
- 리팩터링을 작게 유지한다.
- 커밋 전에 변경 사항을 검토한다.
- 푸시 전에는 반드시 테스트+빌드
- 약간의 변경이 많이 변경하는 것보다 오류 발생 가능성이 더 높은 경향이 있다.

### 24.5 리팩터링 전략
- 80/20 규칙: 80%의 이득을 제공하는 20%의 리팩터링에 시간을 투자하라.
- 현실 세계가 혼란스럽다고 코드가 혼란스러워선 안 된다.


## 25장. 코드 튜닝 전략
- 성능은 하드웨어 제한이 있을 때 중요한 것이다. 어느 정도 성능이 나온다면, 가독성이 더 중요하다.

### 25.1 성능이란?
- 제품 성능과 코드 속도는 어느 정도만 관련이 있다.
  - 코드 속도 개선보다 제품 자체를 개선하는게 더 나을 때가 많다.
  - 그러니 코드의 속도 최적화에 시간을 많이 쓰지 마라. (ROI를 따져보라.)
- 성능 문제를 해결하는 데 시간을 투자하기 전에 먼저 해결해야 할 문제를 해결하고 있는지 확인하라.

### 25.2 코드 튜닝 소개
- 효율적인 코드가 항상 더 나은 코드인 것은 아니다.
- 우선 완성한 다음 완벽하게 만들어라. 완벽해야 하는 부분은 일반적으로 작은 부분이다.
- 짧은 코드가 더 빠른 것도 아니다.
- 성능은 측정해야 한다. 추측으로는 불명확하다.
- 코드 튜닝으로 성능이 향상되었던 것이, 다른 환경에서는 오히려 성능을 떨어뜨릴 수도 있다. (ex. 컴파일러 업데이트)
- 프로그램은 측정하기 전까지 성능 병목이 어디에 생기는지 정확히 알 수 없다.
  - 그러니 개발하면서 최적화하지 마라. 필요한 경우에만 진행하라.
  - 너무 이른 최적화 작업은 전체적으로 손해다.
- 때로는 성능 이슈가 코드가 아니라 아키텍처의 문제일수도 있다.
- 빠른 프로그램보다 정확한 프로그램이 더 중요하다.
- 프로그램을 변경하기 쉽게 만들고, 제대로 완성이 되면 성능을 검사하고, 최적화가 필요하다는 것을 알게 될 때 최적화하라.
- 통계적으로, 4% 코드가 성능 병목의 50% 이상을 차지한다.
  - 극단적으로는 1%도 안 되는 코드가 90%의 성능 병목을 차지하기도 한다.

### 25.3 느리고 비대한 부분
- 비효율적인 공통적인 원인
  - 불필요한 I/O(네트워크, DB 등): 공간이 중요하지 않다면 인메모리 DB를 활용하라.
  - 페이징(메모리 페이지 교체 연산)
  - 시스템 호출(컨텍스트 스위칭)
  - 인터프리터 언어(파이썬, PHP, ...)
  - 코드 오류: 좋은 프로그래밍 습관으로 극복할 수 있다.

### 25.4 측정
- 코드가 느린, "작은 부분"을 찾아야 한다. 최적화 후, 다시 측정해서 얼마나 향상되었는지 평가한다.
- 최적화는 측정 전까지 그 효과를 결코 장담할 수 없다.
- 성능 측정은 정확해야 한다. 측정을 위한 코드나 애플리케이션이 코드 성능에 영향을 줘서는 안 된다.

### 25.5 반복
- 한 가지 기법이 효과가 있어도 꾸준히 다른 방법을 시도하라.
- 일반적으로 원하는 만큼의 성능을 개선하기 위해서는 여러 번 시도해야 한다.


## 26장. 코드 튜닝 기법
- 크기 감소는 코드 튜닝보단 클래스와 데이터를 재설계하는 것에서 더 많은 영향을 받는다.
- 코드 튜닝은 큰 규모 설계에서의 변경보다는 작은 규모의 변경을 가리킨다.
- 리팩터링과는 다른다. 내부 구조를 향상시키지 않을수도 있다. 성능을 대가로 내부 구조를 손상시킬 수 있다.

### 26.1 논리 구조
- 가장 빠르고 참일 가능성이 가장 큰 조건식이 먼저 수행되어야 한다.
  - 정상적인 경우를 빠르게 중단하고, 비효율적인 부분은 특별히 처리하도록 한다.
- 성능을 위한 코드와 가독성을 위한 코드의 형태는 다를 수 있다.
  - 성능이 정말로 중요하다면 가독성을 포기해야 할 수도 있다.
- 최적화의 효과를 확인하려면 반드시 그 효과를 측정해야 한다. 예외란 없다.

### 26.3 데이터 변환
- 다차원 배열은 느리다는 게 일반적인 통념이다. 다차원을 1차원 배열로 만들어라.
- 데이터가 크다면 키-값을 쌍으로 하는 인덱스를 만들어 활용하라.


## 6부. 시스템 고려 사항
## 27장. 프로그램의 크기가 구현에 미치는 영향
- 소프트웨어 개발에서 규모를 키우면, 비용이 선형적으로 증가하지 않는다. 훨씬 가파르게 증가한다.

### 27.1 의사소통과 크기
- 프로젝트 참여 인원이 많을수록 의사소통 경로의 수가 증가한다. 인원의 제곱에 비례해 증가한다.
  - 의사소통의 경로가 증가할수록 소모되는 시간이 많아지고 실수의 발생 확률도 증가한다.
  - 크기가 큰 프로젝트는 의사소통을 능률적으로 진행하거나 현명한 방법으로 제한하는 조직적 기법이 필요하다.
- 능률적인 의사소통을 위해 도입된 전형적인 접근 방법 : 문서, 이미지

### 27.3 프로젝트 크기가 오류에 미치는 영향
- 프로젝트 크기가 커질수록 구현의 오류보다 설계의 오류 비중이 커진다.
- 프로젝트 크기가 클수록 1000줄 당 결함 수도 커진다.

### 27.4 프로젝트 크기가 생산성에 미치는 영향
- 작은 팀이 큰 팀보다 생산성이 더 높다.
- 작은 프로젝트가 큰 프로젝트보다 생산성이 더 높다.

### 27.5 프로젝트 크기가 개발 활동에 미치는 영향
- 프로젝트에서 기본적으로 구현의 비중이 가장 크다. (1인 개발 시, 65%)
- 프로젝트가 클수록 활동에서 구현의 비중이 작아지고, 아키텍처, 통합, 시스템 테스트의 크키가 증가한다.
- 구현 작업량은 프로젝트 크기에 대해 선형 함수에 가깝지만, 다른 작업은 비선형적으로 증가한다.
  - 의사소통, 계획 수립, 관리, 기능 설계, 명세, 테스트, 문서화 등
- 소프트웨어 크기에 따라 설계 방법은 달라져야 한다. 명시적으로 전략을 선택하라.
- 방법론을 작게 시작해서 큰 프로젝트에 맞게 확장하는 게 일반적으로 더 좋은 결과를 가져온다.

## 28장. 구현 관리
- 프로그래밍 표준은 관리자가 아닌 개발자가 직접 정한다.
- 프로젝트의 모든 영역에 최소 2명으로 구성할 것
- 모든 코드를 읽는다.
- 모든 작업은 모두의 것이다. 개인의 소유가 아니다. 따라서 모두가 수정할 수 있어야 한다.
- 일정은 주기적으로 다시 산정한다.
- 예측 기법은 다양하게.
- 세부 사항을 예측하라. 큰 사항을 예측하는 것보다 훨씬 쉽다.
- 초기 예측의 정확성이 중요하다. (물론 쉽지 않다.)

#### 일정이 늦춰졌다면
- 일정을 늦추거나 초과하는 것은 일반적으로 프로젝트 끝으로 갈수록 증가한다.
- 일반적으로 인원을 충원한다고 더 빨라지지 않는다. 다만, 독립적으로 나누어 수행할 수 있는 일을 새로운 사람을 충원해서 맡기면 빨라질 수 있다.
- 스펙 줄이기
  - 가장 중요한 것을 우선 개발하기

### 28.4 측정
- 측정하지 않는 것보다 측정하는 것이 낫다.

## 29장. 통합
- 통합: 개별적인 소프트웨어 컴포넌트를 하나의 시스템으로 결합하는 개발/행위
- 통합과 구현 순서는 중요하다. (구현되지 않은 것을 통합할 수는 없기 때문이다.)
- 잘못된 순서로 구현하고 통합하면 코드 작성/테스트/디버깅이 더 어려워진다.
- 다른 시스템과 통합하는 것 자체만으로도 문제점이 발생한다.
- 점증적 통합: 작은 단위로 컴포넌트 나누고, 그 구현이 끝나면 그때마다 통합을 한다.
  - 큰 단위의 통합보다 훨씬 오류 찾기가 쉽다.
  - 점증적으로 통합하기 위해서는 컴포넌트 구현 순서에 신중해야 한다. 구현 순서가 통합 순서와 같아야 한다.
- 하향식 통합: 계층 구조의 상위에 있는 클래스를 먼저 작성하고 통합한다.
  - 스텁 코드로 미리 구현 후, 추후에 실제 클래스로 대체된다.
  - 내부 동작이 까다로운 인터페이스의 경우, 그것이 구현되기 전까지 실제로 테스트할 수 없다.
