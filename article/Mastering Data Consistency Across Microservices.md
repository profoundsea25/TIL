# [Mastering Data Consistency Across Microservices](https://blog.bytebytego.com/p/mastering-data-consistency-across)
- 마이크로서비스에서 데이터 일관성 마스터하기

- 마이크로서비스 아키텍처에서, 각각의 서비스들은 독립적으로 운영되고, 배포되고, 확장할 수 있음.
- 그러나 이런 분리 때문에, 데이터 일관성에서 문제가 발생할 수 있음.
- 데이터 일관성이란, 모든 서비스에서 같은 시점에는 같은 데이터를 보장해야 함을 의미한다.

### 일관성 모델
1. Strong Consistency
  - 모든 노드에서 업데이트된 데이터를 트랜잭션 커밋 이후 즉시 볼 수 있어야 한다.
  - 모든 읽기 연산은 가장 최근의 쓰기 연산의 결과를 읽어야 한다.
  - 금융 거래나 재고 관리에 필수.
  - 성능과 가용성(데이터를 소유한 어느 서버라도 이상이 있으면 안 됨.) 문제를 해결해야 함.
2. Eventual Consistency
  - 모든 노드가 "결국에는" 같은 데이터를 보게 된다. (즉시가 아님.)
  - 변경사항이 비동기적으로 전파됨.
  - 일시적으로는 다른 노드끼리 다른 결과를 나타낼 수 있음.
  - 약간의 차이가 발생해도 괜찮을 때 사용
  - 다른 서비스에서 변경 중 충돌이 발생할 수 있음.
3. Casual Consistency
  - 연산의 순서가 보장됨. (인과관계를 보장함.)
  - 그러나 Strong Consistency처럼 글로벌 동기화가 안 될 수 있음.
  - 구현이 복잡하고, 높은 지연시간 문제를 해결해야 함.
4. Read-Your-Writes Consistency
  - 자신의 업데이트는 즉시 볼 수 있지만, 다른 사용자는 그것을 볼 수 없을수도 있음.
  - ex. 소셜미디어에 피드를 쓰면, 본인은 바로 볼 수 있지만 타인이 볼 때까지 시간이 걸릴 수 있음.

### 적절한 일관성 모델 선택하기
- 실시간 정확성이 아주 중요하다면, Strong Consistency
  - 뱅킹, 재고 관리
- 실시간 정확성보다 속도와 가용성이 중요하다면, Eventual Consistency
  - 소셜 미디어, 분석 대시보드
- 순서가 중요하다면, Casual Consistency
  - 채팅 애플리케이션
- 자신의 변경사항을 바로 보아야 한다면, Read-Your-Write Consistency
  - 쇼핑 장바구니, 프로필 변경