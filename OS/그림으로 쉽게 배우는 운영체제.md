# 그림으로 쉽게 배우는 운영체제
> [그림으로 쉽게 배우는 운영체제](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard) 요약입니다.

## 섹션 0. 운영체제 
### 운영체제가 하는 일
1. 프로세스를 관리
2. 메모리 관리
3. 하드웨어 관리 (하드웨어에 대한 직접적인 접근을 막음)
4. 파일 시스템 관리 (효율적인 저장)

### 운영체제 역사
- 비싼 CPU를 더 많이 사용하려고 고민한 역사 + 오퍼레이터와 프로그래머 사이의 시간을 줄이려고 노력함
- 싱글스트림 배치 시스템 : 여러 개의 프로그램을 순서대로 하나씩 실행
- 시분할 시스템 : 시간을 분할해서 사용하는 시스템
- UNIX : 멀티 프로그래밍, 다중 사용자, 파일 시스템을 구현
  - 메모리 침범 문제

### 운영체제 구조
#### 커널
- 프로세스와 메모리, 저장장치를 관리하는 핵심적인 기능을 담당
- 사용자는 운영 체제의 커널에 직접 접근할 수 없음. 인터페이스(GUI/CLI)를 통해 접근
  - GUI(Graphic User Interface) : 그래픽으로 된 인터페이스
  - CLI(Command-Line Interface) : 텍스트를 이용해 커널과 상호 작용
- 어플리케이션은 시스템 콜을 통해 커널에 접근
  - 시스템 콜이 없다면? 중요한 데이터를 덮어쓸 수 있고, 해당 사용자나 어플리케이션이 저장한 데이터를 다른 어플리케이션이 덮어 쓸 수도 있음
- 하드웨어는 드라이버를 통해 커널에 접근

### 컴퓨터 하드웨어와 구조
#### 폰 노이만 구조
- CPU와 메모리를 두고, 그 사이를 버스(데이터를 전달하는 통로)로 연결
- 프로그램 내장방식 : 프로그램은 메모리에 올려서(내장해서) 실행시킴

#### CPU의 구조
- 산술논리 연산장치 : 데이터 연산을 담당
- 제어 장치 : 모든 장치들의 동작을 지시하고 제어하는 장치
- 레지스터 : CPU 내에서 계산을 위해 임시로 보관하는 장치

#### 메모리
- RAM(Random Access Memory)
  - 랜덤으로 데이터를 읽어도 저장된 위치와 상관없이 읽는 속도가 같음
  - 전력이 끊기면 데이터를 잃어버림
  - 메인 메모리로 사용
- ROM(Read Only Memory)
  - 전력이 끊겨도 데이터를 계속 보관할 수 있음
  - 데이터를 한 번 쓰면 수정이 불가능
  - 컴퓨터의 부팅과 관련된 바이오스 저장

### 부팅 과정
1. 전원 실행
2. ROM에 저장된 바이오스 실행
3. 주요 하드웨어(CPU, RAM, 하드디스크, 키보드 등)에 이상이 없는지 체크 (이상이 있으면 부팅 불가)
4. 이상이 없다면 하드디스크에 있는 마스터 부트 레코드에 저장된 부트로더를 메모리로 가져와서 실행
5. 운영체제를 불러오고 바탕화면 실행
6. 이때부터 실행되는 모든 프로그램은 메모리에 올라와서 운영체제가 관리

### 인터럽트  
CPU가 입출력 장치의 데이터를 읽거나 쓰려고 할 때, CPU는 입출력 관리자에게 입출력 명령을 내림 
#### 폴링(Polling) 방식
- 입출력 명령이 언제 끝날지 모르기 때문에 CPU가 입출력 관리자를 주기적으로 계속 확인)
- 단점 : 주기적으로 CPU가 입출력 장치를 확인해야 하니 성능이 좋지 못 함
#### 인터럽트 방식 (하드웨어 인터럽트)
- 폴링 방식의 단점을 극복
- CPU가 입출력 명령을 내리고, 다른 작업을 계속함.
- 입출력이 완료되면 입출력 관리자가 CPU에게 신호를 주고, 그 신호를 받아 CPU는 인터럽트 서비스 루틴(ISR)을 실행시켜 작업을 완료
- 인터럽트 서비스 루틴은 특정 인터럽트(예 : 특정 키보드를 누름)가 들어오면 그 인터럽트를 처리
- 인터럽트는 비동기적으로 동작하기 때문에 성능에 이점이 있음
#### 소프트웨어 인터럽트
- 사용자 프로그램에서 발생한 인터럽트를 처리 (예 : 유효하지 않은 접근을 처리)

### Remind
- 운영체제가 하는 일
- 메모리 RAM vs ROM
- 커널에 접근하는 방법들

## 섹션 1. 프로세스와 쓰레드
### 프로그램과 프로세스
#### 프로그램
- 하드디스크 등과 같은 저장장치에 저장된 명령문의 집합체
- 앱 혹은 애플리케이션이라고도 함
- 하드디스크만 사용하는 수동적인 존재
#### 프로세스
- 실행 중인 프로그램 = 하드디스크에 저장된 프로그램이 메모리에 올라갔을 때
- 메모리, CPU, 입출력을 사용하기 때문에 능동적
#### 프로세스 구조
- Code 영역 : 자신을 실행하는 코드가 저장되어 있음
- Data 영역 : 전역 변수와 static(정적) 변수가 저장되어 있음
- Stack 영역 : 지역 변수와 함수 호출을 했을 때 필요한 정보들이 저장됨
- Heap 영역 : 프로그래머가 동적으로 메모리를 할당하는데 쓰임
#### 컴파일 과정
- 전처리기 -> 컴파일러 -> 어셈블러 -> 링커 -> exe -> 메모리로 올라가면 프로세스

### 멀티프로그래밍과 멀티프로세싱
#### 유니프로그래밍
- 메모리에 오직 하나의 프로세스가 올라온 것
#### 멀티프로그래밍
- 메모리에 여러 개의 프로세스가 올라온 것
#### 멀티프로세싱
- CPU가 여러 개의 프로세스를 처리하는 것
#### 현대 OS는
- 멀티프로그래밍과 시분할 처리를 이용한 멀티프로세싱을 모두 사용한다.
#### 스와핑(Swapping)
- 유니프로그래밍을 이용한 멀티프로세싱에서, 메모리에 있는 데이터를 다른 저장장치로 보내고 다른 저장장치에서 메모리에 올리는 것

### PCB(Process Controll Block)
- 프로세스가 만들어지면 운영체제가 해당 프로세스의 정보를 가지고 있는 PCB를 만들어 저장
- 연결리스트라(각각의 데이터가 다음 데이터를 연결하는 구조)는 자료구조로 저장됨
- 프로세스가 종료되면 연결리스트에서 해당 프로세스의 PCB 제거
#### 구조
- 포인터 : 부모와 자식 프로세스에 대한 포인터, 할당된 자원에 대한 포인터 등. 프로세스의 한 상태에서 다른 상태로 전환될 때 저장하는 포인터를 가지고 있음
- 프로세스 상태 : 현재 프로세스의 5가지 상태(생성, 준비, 실행, 대기, 완료)를 나타냄
- 프로세스 ID : 프로세스를 식별하기 위한 숫자
- 프로그램 카운터 : 다음에 실행될 명령어의 주소를 포함. 시분할 처리를 위해 꼭 있어야 함.
- 레지스터 정보 : 프로세스가 실행될 때 사용했던 레지스터 값들이 저장됨. 시분할 처리를 위해 사용
- 메모리 관련 정보 : 프로세스가 메모리에 있는 위치 정보, 메모리 침범을 막기 위한 경계 레지스터 값 등 저장
- CPU 스케줄링 정보 : CPU 스케줄링에 필요한 우선순위, 최종 실행시간, CPU 점유 시간 등 저장

### 프로세스 상태
- 생성(New) : PCB를 생성하고 메모리에 프로그램 적재를 요청한 상태
- 준비(Ready) : (메모리에 프로그램 적재를 승인 받으면) CPU를 사용하기 위해 기다리고 있는 상태. CPU스케줄러에 의해 CPU가 할당됨. 대부분의 프로세스가 있는 단계
- 대기(Waiting) : 프로세스가 입출력 요청을 하면 입출력이 완료될 때까지 기다리는 상태 (CPU의 사용율을 높일 수 있다.)
- 실행(Running) : 준비상태에 있는 프로세스가 CPU 스케줄러에 의해 CPU를 할당받아 실행되는 상태. 실행상태에 있는 프로세스의 수는 CPU의 개수만큼 있음. 부여된 시간만큼만 사용.
- 완료(Terminated) : 프로세스가 종료된 상태. 프로세스가 사용했던 데이터를 메모리에서 제거. 생성된 PCB도 제거

### 컨텍스트 스위칭(Context Switching)
- 프로세스를 실행하는 중에 다른 프로세스를 실행하기 위해 실행중인 프로세스 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 작업
- PCB의 내용이 변경됨
- 실행중인 프로세스의 작업 내용을 PCB에 저장하고 실행될 기존 프로세스의 PCB의 내용대로 CPU가 다시 세팅됨
- 프로세스 상태, 프로그램 카운터, 각종 레지스터값 등이 변경됨
- 메모리에 있는 모든 프로세스들은 컨텍스트 스위칭을 함.
- 발생 이유 : CPU 점유 시간이 다 되거나, I/O 요청이 있거나, 다른 종류의 인터럽트가 발생했을 때

### 프로세스 생성과 종료
- 부모 프로세스, fork(), 자식 프로세스, exec(), exit(), 좀비 프로세스

### 쓰레드
- 프로세스 내에 존재. 한 프로세스에 1개 이상의 쓰레드 존재 가능
- 한 프로세스 내에 쓰레드들은 그 프로세스의 PCB, 코드, 데이터, 힙 영역을 공유. 스택은 공유하지 않고 쓰레드마다 하나씩 가짐
- 쓰레드를 관리하기 위해 쓰레드ID와 TCB(Thread Control Block) 생성
- 쓰레드를 활용하면 OS 입장에서 작업을 처리하는 단위가 프로세스에서 쓰레드가 됨

### 프로세스와 쓰레드의 장단점
#### 안정성
- 프로세스 우위. 
- 프로세스는 모두 독립적이기 때문에 한 프로세스가 문제가 생기더라도 다른 프로세스에 영향이 없음
- 쓰레드는 프로세스에 종속적이기 때문에 프로세스에 문제가 생기면 모든 쓰레드에 문제가 발생
#### 속도와 자원
- 쓰레드 우위. 
- 각각의 프로세스는 고유한 자원을 가짐. 프로세스간 통신은 IPC를 이용하는데 오버헤드가 크고 속도가 느림. 
- 쓰레드는 한 프로세스 내에서 스택영역을 제외한 영역은 모두 공유하기 때문에 오버헤드가 굉장히 작음. 
- 쓰레드간의 통신은 데이터를 공유할 수 있으니 쉽게 할 수 있지만 공유되는 공간에서 문제가 발생할 수 있음 -> 프로세스 동기화
