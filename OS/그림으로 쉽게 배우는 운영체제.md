# 그림으로 쉽게 배우는 운영체제
> [그림으로 쉽게 배우는 운영체제](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard) 요약입니다.

## 섹션 0. 운영체제 
### 운영체제가 하는 일
1. 프로세스를 관리
2. 메모리 관리
3. 하드웨어 관리 (하드웨어에 대한 직접적인 접근을 막음)
4. 파일 시스템 관리 (효율적인 저장)

### 운영체제 역사
- 비싼 CPU를 더 많이 사용하려고 고민한 역사 + 오퍼레이터와 프로그래머 사이의 시간을 줄이려고 노력함
- 싱글스트림 배치 시스템 : 여러 개의 프로그램을 순서대로 하나씩 실행
- 시분할 시스템 : 시간을 분할해서 사용하는 시스템
- UNIX : 멀티 프로그래밍, 다중 사용자, 파일 시스템을 구현
  - 메모리 침범 문제

### 운영체제 구조
#### 커널
- 프로세스와 메모리, 저장장치를 관리하는 핵심적인 기능을 담당
- 사용자는 운영 체제의 커널에 직접 접근할 수 없음. 인터페이스(GUI/CLI)를 통해 접근
  - GUI(Graphic User Interface) : 그래픽으로 된 인터페이스
  - CLI(Command-Line Interface) : 텍스트를 이용해 커널과 상호 작용
- 어플리케이션은 시스템 콜을 통해 커널에 접근
  - 시스템 콜이 없다면? 중요한 데이터를 덮어쓸 수 있고, 해당 사용자나 어플리케이션이 저장한 데이터를 다른 어플리케이션이 덮어 쓸 수도 있음
- 하드웨어는 드라이버를 통해 커널에 접근

### 컴퓨터 하드웨어와 구조
#### 폰 노이만 구조
- CPU와 메모리를 두고, 그 사이를 버스(데이터를 전달하는 통로)로 연결
- 프로그램 내장방식 : 프로그램은 메모리에 올려서(내장해서) 실행시킴

#### CPU의 구조
- 산술논리 연산장치 : 데이터 연산을 담당
- 제어 장치 : 모든 장치들의 동작을 지시하고 제어하는 장치
- 레지스터 : CPU 내에서 계산을 위해 임시로 보관하는 장치

#### 메모리
- RAM(Random Access Memory)
  - 랜덤으로 데이터를 읽어도 저장된 위치와 상관없이 읽는 속도가 같음
  - 전력이 끊기면 데이터를 잃어버림
  - 메인 메모리로 사용
- ROM(Read Only Memory)
  - 전력이 끊겨도 데이터를 계속 보관할 수 있음
  - 데이터를 한 번 쓰면 수정이 불가능
  - 컴퓨터의 부팅과 관련된 바이오스 저장

### 부팅 과정
1. 전원 실행
2. ROM에 저장된 바이오스 실행
3. 주요 하드웨어(CPU, RAM, 하드디스크, 키보드 등)에 이상이 없는지 체크 (이상이 있으면 부팅 불가)
4. 이상이 없다면 하드디스크에 있는 마스터 부트 레코드에 저장된 부트로더를 메모리로 가져와서 실행
5. 운영체제를 불러오고 바탕화면 실행
6. 이때부터 실행되는 모든 프로그램은 메모리에 올라와서 운영체제가 관리

### 인터럽트  
CPU가 입출력 장치의 데이터를 읽거나 쓰려고 할 때, CPU는 입출력 관리자에게 입출력 명령을 내림 
#### 폴링(Polling) 방식
- 입출력 명령이 언제 끝날지 모르기 때문에 CPU가 입출력 관리자를 주기적으로 계속 확인)
- 단점 : 주기적으로 CPU가 입출력 장치를 확인해야 하니 성능이 좋지 못 함
#### 인터럽트 방식 (하드웨어 인터럽트)
- 폴링 방식의 단점을 극복
- CPU가 입출력 명령을 내리고, 다른 작업을 계속함.
- 입출력이 완료되면 입출력 관리자가 CPU에게 신호를 주고, 그 신호를 받아 CPU는 인터럽트 서비스 루틴(ISR)을 실행시켜 작업을 완료
- 인터럽트 서비스 루틴은 특정 인터럽트(예 : 특정 키보드를 누름)가 들어오면 그 인터럽트를 처리
- 인터럽트는 비동기적으로 동작하기 때문에 성능에 이점이 있음
#### 소프트웨어 인터럽트
- 사용자 프로그램에서 발생한 인터럽트를 처리 (예 : 유효하지 않은 접근을 처리)

### Remind
- 운영체제가 하는 일
- 메모리 RAM vs ROM
- 커널에 접근하는 방법들

## 섹션 1. 프로세스와 쓰레드
### 프로그램과 프로세스
#### 프로그램
- 하드디스크 등과 같은 저장장치에 저장된 명령문의 집합체
- 앱 혹은 애플리케이션이라고도 함
- 하드디스크만 사용하는 수동적인 존재
#### 프로세스
- 실행 중인 프로그램 = 하드디스크에 저장된 프로그램이 메모리에 올라갔을 때
- 메모리, CPU, 입출력을 사용하기 때문에 능동적
#### 프로세스 구조
- Code 영역 : 자신을 실행하는 코드가 저장되어 있음
- Data 영역 : 전역 변수와 static(정적) 변수가 저장되어 있음
- Stack 영역 : 지역 변수와 함수 호출을 했을 때 필요한 정보들이 저장됨
- Heap 영역 : 프로그래머가 동적으로 메모리를 할당하는데 쓰임
#### 컴파일 과정
- 전처리기 -> 컴파일러 -> 어셈블러 -> 링커 -> exe -> 메모리로 올라가면 프로세스

### 멀티프로그래밍과 멀티프로세싱
#### 유니프로그래밍
- 메모리에 오직 하나의 프로세스가 올라온 것
#### 멀티프로그래밍
- 메모리에 여러 개의 프로세스가 올라온 것
#### 멀티프로세싱
- CPU가 여러 개의 프로세스를 처리하는 것
#### 현대 OS는
- 멀티프로그래밍과 시분할 처리를 이용한 멀티프로세싱을 모두 사용한다.
#### 스와핑(Swapping)
- 유니프로그래밍을 이용한 멀티프로세싱에서, 메모리에 있는 데이터를 다른 저장장치로 보내고 다른 저장장치에서 메모리에 올리는 것

### PCB(Process Controll Block)
- 프로세스가 만들어지면 운영체제가 해당 프로세스의 정보를 가지고 있는 PCB를 만들어 저장
- 연결리스트라(각각의 데이터가 다음 데이터를 연결하는 구조)는 자료구조로 저장됨
- 프로세스가 종료되면 연결리스트에서 해당 프로세스의 PCB 제거
#### 구조
- 포인터 : 부모와 자식 프로세스에 대한 포인터, 할당된 자원에 대한 포인터 등. 프로세스의 한 상태에서 다른 상태로 전환될 때 저장하는 포인터를 가지고 있음
- 프로세스 상태 : 현재 프로세스의 5가지 상태(생성, 준비, 실행, 대기, 완료)를 나타냄
- 프로세스 ID : 프로세스를 식별하기 위한 숫자
- 프로그램 카운터 : 다음에 실행될 명령어의 주소를 포함. 시분할 처리를 위해 꼭 있어야 함.
- 레지스터 정보 : 프로세스가 실행될 때 사용했던 레지스터 값들이 저장됨. 시분할 처리를 위해 사용
- 메모리 관련 정보 : 프로세스가 메모리에 있는 위치 정보, 메모리 침범을 막기 위한 경계 레지스터 값 등 저장
- CPU 스케줄링 정보 : CPU 스케줄링에 필요한 우선순위, 최종 실행시간, CPU 점유 시간 등 저장

### 프로세스 상태
- 생성(New) : PCB를 생성하고 메모리에 프로그램 적재를 요청한 상태
- 준비(Ready) : (메모리에 프로그램 적재를 승인 받으면) CPU를 사용하기 위해 기다리고 있는 상태. CPU스케줄러에 의해 CPU가 할당됨. 대부분의 프로세스가 있는 단계
- 대기(Waiting) : 프로세스가 입출력 요청을 하면 입출력이 완료될 때까지 기다리는 상태 (CPU의 사용율을 높일 수 있다.)
- 실행(Running) : 준비상태에 있는 프로세스가 CPU 스케줄러에 의해 CPU를 할당받아 실행되는 상태. 실행상태에 있는 프로세스의 수는 CPU의 개수만큼 있음. 부여된 시간만큼만 사용.
- 완료(Terminated) : 프로세스가 종료된 상태. 프로세스가 사용했던 데이터를 메모리에서 제거. 생성된 PCB도 제거

### 컨텍스트 스위칭(Context Switching)
- 프로세스를 실행하는 중에 다른 프로세스를 실행하기 위해 실행중인 프로세스 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 작업
- PCB의 내용이 변경됨
- 실행중인 프로세스의 작업 내용을 PCB에 저장하고 실행될 기존 프로세스의 PCB의 내용대로 CPU가 다시 세팅됨
- 프로세스 상태, 프로그램 카운터, 각종 레지스터값 등이 변경됨
- 메모리에 있는 모든 프로세스들은 컨텍스트 스위칭을 함.
- 발생 이유 : CPU 점유 시간이 다 되거나, I/O 요청이 있거나, 다른 종류의 인터럽트가 발생했을 때

### 프로세스 생성과 종료
- 부모 프로세스, fork(), 자식 프로세스, exec(), exit(), 좀비 프로세스

### 쓰레드
- 프로세스 내에 존재. 한 프로세스에 1개 이상의 쓰레드 존재 가능
- 한 프로세스 내에 쓰레드들은 그 프로세스의 PCB, 코드, 데이터, 힙 영역을 공유. 스택은 공유하지 않고 쓰레드마다 하나씩 가짐
- 쓰레드를 관리하기 위해 쓰레드ID와 TCB(Thread Control Block) 생성
- 쓰레드를 활용하면 OS 입장에서 작업을 처리하는 단위가 프로세스에서 쓰레드가 됨

### 프로세스와 쓰레드의 장단점
#### 안정성
- 프로세스 우위. 
- 프로세스는 모두 독립적이기 때문에 한 프로세스가 문제가 생기더라도 다른 프로세스에 영향이 없음
- 쓰레드는 프로세스에 종속적이기 때문에 프로세스에 문제가 생기면 모든 쓰레드에 문제가 발생
#### 속도와 자원
- 쓰레드 우위. 
- 각각의 프로세스는 고유한 자원을 가짐. 프로세스간 통신은 IPC를 이용하는데 오버헤드가 크고 속도가 느림. 
- 쓰레드는 한 프로세스 내에서 스택영역을 제외한 영역은 모두 공유하기 때문에 오버헤드가 굉장히 작음. 
- 쓰레드간의 통신은 데이터를 공유할 수 있으니 쉽게 할 수 있지만 공유되는 공간에서 문제가 발생할 수 있음 -> 프로세스 동기화

## 섹션 2. CPU 스케줄링
### CPU 스케줄링 개요
- CPU 스케줄링 : 운영체제는 모든 프로세스에게 CPU를 할당/해제
- 스케줄러의 고려사항 (컴퓨터 성능에 직결)
  1. 어떤 프로세스에게 CPU 리소스를 주어야 하는가?
  2. CPU를 할당받은 프로세스가 얼마의 시간동안 CPU를 사용해야하는가?
- CPU Burst : CPU를 할당받아 실행하는 작업
- I/O Burst : 입출력 작업

### 다중큐
- 프로세스 상태 중 준비(Ready)와 대기(Waiting)은 큐(Queue)라는 자료구조로 관리됨
- 프로세스가 실행상태에서 준비상태로 돌아갈 때 운영체제는 해당 프로세스의 우선순위를 보고 그에 맞는 준비큐에 넣음. (정확히는 PCB가 큐에 들어감)
- CPU 스케줄러는 "준비상태의 다중큐"에 들어있는 프로세스들 중에 적당한 프로세스를 선택해서 실행상태로 전환시킴
- 프로세스에서 I/O작업이 발생하면 해당 I/O 작업의 종류별로 나뉜 큐에 넣고, CPU 스케줄러가 관리

### 스케줄링 목표
- 리소스 사용률을 높임
- 오버헤드 최소화
- 공평성 (모든 프로세스에게 공평하게 CPU가 할당되어야 함, '공평'은 의미가 달라질 수 있음)
- 처리량 (같은 시간 내에 더 많은 처리량)
- 대기시간 최소화
- 응답시간 최소화
- 동시에 모든 목표를 달성할 수 있는 것은 아님

### CPU 스케줄링 알고리즘
- 스케줄링의 성능은 "평균 대기 시간"으로 평가
- 평균 대기 시간 : 프로세스가 여러개가 실행될 때 이 프로세스들 모두가 실행되기까지 대기시간의 평균
#### FIFO(First In First Out)
- 먼저 들어온 작업이 먼저 나감
- 들어온 프로세스 순서대로 CPU를 할당받음
- 먼저 처리 중인 프로세스가 완전히 끝나야만 다음 프로세스가 실행될 수 있음
- 단순하고 직관적
- I/O작업이 있다면 I/O작업이 끝날 때까지 기다리는 동안 CPU 사용률이 떨어지는 문제가 있음
- 프로세스의 Birst Time에 따라 성능의 차이가 심함 -> 현대 운영체제에서 잘 쓰이지 않음. 일괄처리 시스템에 사용
#### SJF(Shortest Job First)
- 짧은 작업 먼저
- 이론적으로 FIFO보다 성능이 더 좋음
- 그러나 구현에 문제
  1. 어떤 프로세스가 얼마나 실행될지 예측이 힘들다.
  2. Burst Time이 긴 프로세스가 아주 오랫동안 기다리는 경우가 발생한다.
- 사용되지 않는 알고리즘
#### RR(Round Robin)
- 한 프로세스에게 일정 시간만큼 CPU를 할당하고 할당된 시간이 지나면 강제로 다른 프로세스에게 일정시간만큼 CPU를 할당
- CPU 할당을 빼앗긴 프로세스는 큐의 가장 뒤로 밀려남
- 프로세스에게 할당하는 일정 시간 = `타임 슬라이스` 혹은 `타임 퀀텀`
- 만약 RR이 FIFO와 평균 대기 시간이 비슷하다면 RR이 더 비효율적이다. RR은 컨텍스트 스위칭이 있기 때문에 켄텍스트 스위칭 시간이 더 추가됨
- RR 알고리즘의 성능은 타임 슬라이스의 값에 따라 크게 달라짐
- 타임 슬라이스가 무한대인 경우 = FIFO 알고리즘
- 타임 슬라이스가 매우 작은 경우 = 동시에 동작하는 것처럼 느껴짐 But 컨텍스트 스위칭이 너무 많이 발생함. 프로세스 처리량보다 컨텍스트 스위칭 처리량보다 많아짐 (= `오버해드가 너무 크다`)
- 최적의 타임 슬라이스 : 사용자가 느끼기에 여러 프로세스가 버벅거리지 않고 동시에 실행되는 것처럼 느껴지면서 오버헤드가 너무 크지 않는 값
#### MLFQ(Multi Level Feedback Queue)
- 오늘날 운영체제에서 가장 일반적으로 쓰이는 CPU 스케줄링 기법
- RR 알고리즘의 업그레이드 버전
- CPU Bound Process : 대부분 작업 시간이 CPU 작업인 프로세스
  - CPU 사용률과 처리량이 중요
- I/O Bound Process : 대부분 작업 시간이 I/O 작업인 프로세스
  - 응답 속도
- 타임 슬라이스가 더 작을 때 이득 but 컨텍스트 스위칭이 발생하는 손해 발생
- MLFQ는 기본적으로 CPU 사용률과 I/O 사용률이 좋게 나오는 작은 크기의 타임 슬라이스를 선택
  - CPU Bound Process에게 타임 슬라이스를 크게 할당
  - OS가 어떻게 구분? CPU 할당 시간이 부족해서 할당이 빼앗기는 작업이면 CPU Bound Process, 시간이 충분해서 먼저 반납하는 작업이면 I/O Bound Process라고 판단
  - 우선순위 큐를 여러 개 만들고, 우선순위가 높을수록 타임 슬라이스가 작음
  - 타임 슬라이스가 부족한 작업들은 우선순위가 낮은 큐로 옮겨주면서 타임 슬라이스를 더 크게 할당해줌
  - 최종적으로는 타임 슬라이스가 무한초에 가깝게 할당되기 때문에 FIFO와 비슷하게 연속적으로 작업을 마칠 수 있게 됨
