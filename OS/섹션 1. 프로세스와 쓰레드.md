> [그림으로 쉽게 배우는 운영체제](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard) 요약입니다.

## 섹션 1. 프로세스와 쓰레드
### 프로그램과 프로세스
#### 프로그램
- 하드디스크 등과 같은 저장장치에 저장된 명령문의 집합체
- 앱 혹은 애플리케이션이라고도 함
- 하드디스크만 사용하는 수동적인 존재
#### 프로세스
- 실행 중인 프로그램 = 하드디스크에 저장된 프로그램이 메모리에 올라갔을 때
- 메모리, CPU, 입출력을 사용하기 때문에 능동적
#### 프로세스 구조
- Code 영역 : 자신을 실행하는 코드가 저장되어 있음
- Data 영역 : 전역 변수와 static(정적) 변수가 저장되어 있음
- Stack 영역 : 지역 변수와 함수 호출을 했을 때 필요한 정보들이 저장됨
- Heap 영역 : 프로그래머가 동적으로 메모리를 할당하는데 쓰임
#### 컴파일 과정
- 전처리기 -> 컴파일러 -> 어셈블러 -> 링커 -> exe -> 메모리로 올라가면 프로세스

### 멀티프로그래밍과 멀티프로세싱
#### 유니프로그래밍
- 메모리에 오직 하나의 프로세스가 올라온 것
#### 멀티프로그래밍
- 메모리에 여러 개의 프로세스가 올라온 것
#### 멀티프로세싱
- CPU가 여러 개의 프로세스를 처리하는 것
#### 현대 OS는
- 멀티프로그래밍과 시분할 처리를 이용한 멀티프로세싱을 모두 사용한다.
#### 스와핑(Swapping)
- 유니프로그래밍을 이용한 멀티프로세싱에서, 메모리에 있는 데이터를 다른 저장장치로 보내고 다른 저장장치에서 메모리에 올리는 것

### PCB(Process Controll Block)
- 프로세스가 만들어지면 운영체제가 해당 프로세스의 정보를 가지고 있는 PCB를 만들어 저장
- 연결리스트라(각각의 데이터가 다음 데이터를 연결하는 구조)는 자료구조로 저장됨
- 프로세스가 종료되면 연결리스트에서 해당 프로세스의 PCB 제거
#### 구조
- 포인터 : 부모와 자식 프로세스에 대한 포인터, 할당된 자원에 대한 포인터 등. 프로세스의 한 상태에서 다른 상태로 전환될 때 저장하는 포인터를 가지고 있음
- 프로세스 상태 : 현재 프로세스의 5가지 상태(생성, 준비, 실행, 대기, 완료)를 나타냄
- 프로세스 ID : 프로세스를 식별하기 위한 숫자
- 프로그램 카운터 : 다음에 실행될 명령어의 주소를 포함. 시분할 처리를 위해 꼭 있어야 함.
- 레지스터 정보 : 프로세스가 실행될 때 사용했던 레지스터 값들이 저장됨. 시분할 처리를 위해 사용
- 메모리 관련 정보 : 프로세스가 메모리에 있는 위치 정보, 메모리 침범을 막기 위한 경계 레지스터 값 등 저장
- CPU 스케줄링 정보 : CPU 스케줄링에 필요한 우선순위, 최종 실행시간, CPU 점유 시간 등 저장

### 프로세스 상태
- 생성(New) : PCB를 생성하고 메모리에 프로그램 적재를 요청한 상태
- 준비(Ready) : (메모리에 프로그램 적재를 승인 받으면) CPU를 사용하기 위해 기다리고 있는 상태. CPU스케줄러에 의해 CPU가 할당됨. 대부분의 프로세스가 있는 단계
- 대기(Waiting) : 프로세스가 입출력 요청을 하면 입출력이 완료될 때까지 기다리는 상태 (CPU의 사용율을 높일 수 있다.)
- 실행(Running) : 준비상태에 있는 프로세스가 CPU 스케줄러에 의해 CPU를 할당받아 실행되는 상태. 실행상태에 있는 프로세스의 수는 CPU의 개수만큼 있음. 부여된 시간만큼만 사용.
- 완료(Terminated) : 프로세스가 종료된 상태. 프로세스가 사용했던 데이터를 메모리에서 제거. 생성된 PCB도 제거

### 컨텍스트 스위칭(Context Switching)
- 프로세스를 실행하는 중에 다른 프로세스를 실행하기 위해 실행중인 프로세스 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 작업
- PCB의 내용이 변경됨
- 실행중인 프로세스의 작업 내용을 PCB에 저장하고 실행될 기존 프로세스의 PCB의 내용대로 CPU가 다시 세팅됨
- 프로세스 상태, 프로그램 카운터, 각종 레지스터값 등이 변경됨
- 메모리에 있는 모든 프로세스들은 컨텍스트 스위칭을 함.
- 발생 이유 : CPU 점유 시간이 다 되거나, I/O 요청이 있거나, 다른 종류의 인터럽트가 발생했을 때

### 프로세스 생성과 종료
- 부모 프로세스, fork(), 자식 프로세스, exec(), exit(), 좀비 프로세스

### 쓰레드
- 프로세스 내에 존재. 한 프로세스에 1개 이상의 쓰레드 존재 가능
- 한 프로세스 내에 쓰레드들은 그 프로세스의 PCB, 코드, 데이터, 힙 영역을 공유. 스택은 공유하지 않고 쓰레드마다 하나씩 가짐
- 쓰레드를 관리하기 위해 쓰레드ID와 TCB(Thread Control Block) 생성
- 쓰레드를 활용하면 OS 입장에서 작업을 처리하는 단위가 프로세스에서 쓰레드가 됨

### 프로세스와 쓰레드의 장단점
#### 안정성
- 프로세스 우위. 
- 프로세스는 모두 독립적이기 때문에 한 프로세스가 문제가 생기더라도 다른 프로세스에 영향이 없음
- 쓰레드는 프로세스에 종속적이기 때문에 프로세스에 문제가 생기면 모든 쓰레드에 문제가 발생
#### 속도와 자원
- 쓰레드 우위. 
- 각각의 프로세스는 고유한 자원을 가짐. 프로세스간 통신은 IPC를 이용하는데 오버헤드가 크고 속도가 느림. 
- 쓰레드는 한 프로세스 내에서 스택영역을 제외한 영역은 모두 공유하기 때문에 오버헤드가 굉장히 작음. 
- 쓰레드간의 통신은 데이터를 공유할 수 있으니 쉽게 할 수 있지만 공유되는 공간에서 문제가 발생할 수 있음 -> 프로세스 동기화
