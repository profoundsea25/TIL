> [그림으로 쉽게 배우는 운영체제](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard) 요약입니다.

## 섹션 7. 가상메모리
### 가상메모리 개요
- 가상메모리의 크기는 이론적으로 무한대이지만 실제로는 물리 메모리 크기와 CPU의 비트 수로 결정됨
- 가상메모리의 크기가 클 경우 물리메모리 내용의 일부를 하드 디스크에 있는 스왑 영역으로 옮기고 처리가 필요할 때 물리 메모리로 가져와 실행시킴
- 동적주소변환(Dynamic Address Translation) : 메모리 관리자가 물리메모리와 스왑영역을 합쳐서 프로세스가 사용하는 가상 주소를 물리주소로 변환하는 것
  - 이를 통해 프로세스는 마음대로 사용자 데이터를 물리 메모리에 배치할 수 있음
- 가상 메모리는 세그멘테이션-페이징 혼합 방식으로 메모리 할당
- 가상 메모리 시스템에서 가상 주소는 메모리나 스왑영역 한 곳 중에 위치함
- 메모리 관리자는 가상 메모리와 물리 메모리를 1:1 매핑 테이블로 관리

### 세그멘테이션(배치정책)
- 가변분할 방식
- 세그멘테이션에서 프로그램은 함수나 모듈 등으로 세그먼트 구성
- 논리 주소 : 사용자와 프로세스, CPU가 바라보는 주소
- 실제 물리주소로 변환은 중간에서 메모리 관리자(MMU)가 세그멘테이션 테이블을 활용해 해줌
- 세그멘테이션 테이블에서 Base Address와 Bound Address 정보가 저장되고 이것을 이용해 물리 메모리 주소를 계산
#### 세그멘테이션의 주소변환 과정
1. 만약 CPU가 어떤 논리주소를 전달 해주면,
2. 메모리 관리자는 이 논리주소가 몇 번 세그먼트인지 알아내고,
3. 메모리 관리자 내의 Segment Table Base Register를 이용해 물리 메모리 내의 해당 세그멘테이션 테이블을 찾고,
4. 세그먼트 번호를 인덱스로 Base Address와 Bound Address를 찾음.
5. Bound Address는 세그먼트의 크기이고, 이를 CPU가 전달한 논리주소와 비교.
6. 만약 논리 주소가 Bound Address보다 작다면 논리주소와 Base Address를 더해 물리주소를 구하고,
7. 논리 주소가 Bound Address보다 크다면 메모리를 침범했다고 생각하고 에러를 발생시킴.
#### 세그멘테이션의 장점
- 메모리를 가변적으로 분할할 수 있음
- 코드 영역, 데이터 영역, 스택 영역, 힙 영역을 모듈로 처리할 수 있기 때문에 공유와 각 영역에 대한 메모리 접근 보호가 편리
#### 세그멘테이션의 단점
- 외부 단편화 발생

### 페이징(배치정책)
- 세그멘테이션의 외부 단편화를 해결하기 위해 고안됨
- 메모리를 할당할 때 정해진 크기의 페이지로 나눔
- 모든 페이지는 크기가 같기 때문에 관리가 굉장히 쉬워짐
- 일정한 크기로 나눴기 때문에 외부단편화 현상이 일어나지 않음
- 논리주소공간 : 사용자와 프로세스가 바라보는 주소공간
  - 페이지 : 논리주소공간을 일정한 크기로 균일하게 나눈 것
- 물리주소공간 : 실제 메모리에서 사용되는 주소공간
  - 프레임 : 페이지의 크기와 동일하게 나뉜 것
- 메모리 관리자는 페이지 테이블을 가지고 있음
#### 페이징의 주소변환 과정
1. 만약 CPU가 어떤 논리주소를 전달 해주면,
2. 메모리 관리자는 이 논리주소가 몇번 페이지인지, 오프셋은 얼마인지 알아내고,
3. 메모리 관리자 내의 Page Table Base Register(PTBR)을 이용해서 물리 메모리에 있는 해당 페이지 테이블을 찾고,
4. 페이지 번호를 인덱스로 프레임 번호를 알아냄.
    - 페이지 넘버 = 논리주소 / 페이지 크기 
5. 오프셋을 이용해 계산하여 물리주소로 변환함.
    - 오프셋 = 논리주소 % 페이지 크기 
6. 페이지 넘버(인덱스)에 해당하는 프레임에 오프셋을 더한 값이 실제 물리메모리 주소
    - 페이지 테이블에 프레임이 Invalid로 표시되어 있으면 스왑영역(하드디스크)에 저장되어 있다는 의미
#### 세그멘테이션과 페이징의 차이
- 세그멘테이션은 프로세스마다 크기가 달라 Bound Address를 가지고 있지만, 페이징은 모든 페이지의 크기가 동일해서 Bound Address를 가지고 있지 않음.
  - 따라서 페이징은 외부 단편화가 발생하지 않지만 내부 단편화가 발생함. (외부 단편화보다 상대적으로 심각하게 여기지 않음)
- 세그멘테이션은 논리적인 영역별로 세그먼트를 나눌 수 있지만, 페이징은 페이지의 크기가 고정되어 있어 페이지로 나누기 때문에 논리적인 영역별로 나눌 수 없음.
  - 따라서 페이징은 특정 영역만 딱 떼어내서 공유하거나 권한을 부여하는 것이 더 어려움
#### 페이지 테이블의 크기
- 페이징에서 가장 신경써야 하는 것
- 각 프로세스마다 페이징 테이블을 가지고 있는데, 프로세스가 많아질수록 페이지 테이블도 많아지기 때문에 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어듦.
- 실제로 메모리 관리자가 참조하는 페이지 테이블도 물리 메모리의 운영체제 영역에 저장되어 있기 때문에 페이지 테이블 크기가 너무 크면 사용자 영역이 부족해짐
- 따라서 페이지 테이블의 크기를 적절하게 유지하는 것이 굉장히 중요

### 페이지드 세그멘테이션(배치정책)
