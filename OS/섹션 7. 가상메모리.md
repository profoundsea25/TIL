> [그림으로 쉽게 배우는 운영체제](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard) 요약입니다.

## 섹션 7. 가상메모리
### 가상메모리 개요
- 가상메모리의 크기는 이론적으로 무한대이지만 실제로는 물리 메모리 크기와 CPU의 비트 수로 결정됨
- 가상메모리의 크기가 클 경우 물리메모리 내용의 일부를 하드 디스크에 있는 스왑 영역으로 옮기고 처리가 필요할 때 물리 메모리로 가져와 실행시킴
- 동적주소변환(Dynamic Address Translation) : 메모리 관리자가 물리메모리와 스왑영역을 합쳐서 프로세스가 사용하는 가상 주소를 물리주소로 변환하는 것
  - 이를 통해 프로세스는 마음대로 사용자 데이터를 물리 메모리에 배치할 수 있음
- 가상 메모리는 세그멘테이션-페이징 혼합 방식으로 메모리 할당
- 가상 메모리 시스템에서 가상 주소는 메모리나 스왑영역 한 곳 중에 위치함
- 메모리 관리자는 가상 메모리와 물리 메모리를 1:1 매핑 테이블로 관리

### 세그멘테이션
- 가변분할 방식
- 세그멘테이션에서 프로그램은 함수나 모듈 등으로 세그먼트 구성
- 논리 주소 : 사용자와 프로세스, CPU가 바라보는 주소
- 실제 물리주소로 변환은 중간에서 메모리 관리자(MMU)가 세그멘테이션 테이블을 활용해 해줌
- 세그멘테이션 테이블에서 Base Address와 Bound Address 정보가 저장되고 이것을 이용해 물리 메모리 주소를 계산
#### 세그멘테이션 과정
1. 만약 CPU가 어떤 논리주소를 전달 해주면, 
2. 메모리 관리자는 이 논리주소가 몇 번 세그먼트인지 알아내고,
3. 메모리 관리자 내의 Segment Table Base Register를 이용해 물리 메모리 내의 해당 세그멘테이션 테이블을 찾고,
4. 세그먼트 번호를 인덱스로 Base Address와 Bound Address를 찾음.
5. Bound Address는 세그먼트의 크기이고, 이를 CPU가 전달한 논리주소와 비교.
6. 만약 논리 주소가 Bound Address보다 작다면 논리주소와 Base Address를 더해 물리주소를 구하고,
7. 논리 주소가 Bound Address보다 크다면 메모리를 침범했다고 생각하고 에러를 발생시킴.
#### 세그멘테이션의 장점
- 메모리를 가변적으로 분할할 수 있음
- 코드 영역, 데이터 영역, 스택 영역, 힙 영역을 모듈로 처리할 수 있기 때문에 공유와 각 영역에 대한 메모리 접근 보호가 편리
#### 세그멘테이션의 단점
- 외부 단편화 발생
