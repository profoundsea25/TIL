# 2202-08-19
### 학습 내용
#### 코드 포맷팅, 블록 Depth 줄이기
- if 문 중, '특정 조건은 아래의 코드를 실행하지 않음'의 탈출 기능을 한다면, 그것을 최상단으로 올리고 `if(...) return;` 형태로 코딩하여 아래 코드들의 Depth를 줄이기.
- 변수를 사용하는 기준
  - 1. 이름을 통한 기능 명시
  - 2. 재사용성
  - 접근하는 메서드를 통해 가져오는 변수가 이미 어떤 기능인지 이해할 수 있고, 한번 밖에 사용하지 않는 변수는 따로 변수할당을 하지않고 하드코딩 혹은 getter 형식의 접근자를 그대로 사용하였음.

#### `CompletableFuture.runAsync()`
- `runAsync()`의 `Runnable`을 구현하는 블록에서는 Checked Exception을 던질 수 없다.
- `runAsync()`의 반환 타입은 `CompletableFuture<Void>`이며 `exceptionally()`로 `Throwable`을 처리할 수 있다.
- `runAsync()` 내에서의 Checked Exception은 try-catch 블록으로 감싸줘야 컴파일이 된다.

#### `@Slf4j`와 스택 트레이스
- log 인스턴스(`Log4jLogger` 등)으로도 Exception이 터졌을 때의 스택 트레이스를 찍을 수 있다.
- 흔히 쓰는 `e.printStackTrace()`의 경우, `System.err`을 사용하기 때문에 스택 트레이스의 비용이 비교적 크다.
  - `Throwable` 클래스에서 확인 가능, `System.err`은 `PrintStream` 객체
- info(), warn(), error(), debug(), trace() 등의 메서드들은 모두 많은 다중정의가 되어 있는데, 그중 파라미터가 `(String var1, Throwable var2)` 형태인 메서드를 통해 스택 트레이스를 활용할 수 있다.
  - 예를 들면, `log.error("에러가 있음", e)` 혹은 `log.error(e.getMessage(), e)` 같은 형식으로 임의의 문자열과 스택 트레이스를 함께 찍을 수 있다.
  - 메서드 시그니쳐에 유의하자. 파라미터 타입이 `(String var1, Throwable var2)`인 메서드만 스택 트레이스를 활용할 수 있다.
  - 실무에서는 이 방법이 가장 깔끔한 듯하다.
- 로그를 찍을 때는
  - 1) 예상되는 Exception과 관련 깊은 parameter 로그
  - 2) 스택 트레이스를 위한 로그
  - 위의 2 쌍을 기본으로 사용하려고 함.

#### 인터페이스, API, HTTP API, REST API
- [인터페이스](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4_(%EC%BB%B4%ED%93%A8%ED%8C%85))
  - 서로 다른 두 개의 시스템, 장치 사이에서 정보와 신호 교환을 하는 경계를 뜻한다.
  - 사용자가 기기를 쉽게 동작시키는데 도움을 주는 시스템을 뜻한다.
- [API (Application Programming Interface)](https://ko.wikipedia.org/wiki/API)
  - 소프트웨어의 인터페이스.
  - 컴퓨터나 컴퓨터 프로그램 사이의 연결이다.
  - 다른 종류의 소프트웨어에 서비스를 제공한다.
  - 시스템이 동작하는 방식에 관한 내부의 세세한 부분을 숨기는 것이 목적 중 하나이다.
- [HTTP API](https://ko.wikipedia.org/wiki/HTTP)
  - HTTP를 사용해 서로 정해진 스펙으로 데이터를 주고 받으며 하는 통신을 뜻한다.
- [REST API](https://ko.wikipedia.org/wiki/REST)
  - HTTP API의 장점을 최대한 활용하는 방법이다.
  - HTTP API에서 4가지 제약조건을 만족해야 한다.
    - 자원의 식별
    - 메시지를 통한 리소스 조작
    - 자기서술적 메시지
    - 애플리케이션의 상태에 대한 엔지으로서 하이퍼미디어 (HATEOAS)
  - 위의 조건을 최대한 지키면서 개발하는 것을 RESTful API라고 하는데, 특히 4번째 제약조건이 구현에 어려움이 있다. 개발 비용 대비 효과가 크지도 않다.
  - 엄격한 기준에서는 HTTP API와 다르나, 보통 거의 같은 의미로 사용된다.

### 질문
- `CompletableFuture.runAsync()` 내에서 Checked Exception은 `handle()`, `exceptionally()` 등으로 처리가 안 된다. 어떻게 처리해야 깔끔한 코딩이 될까?
  - try-catch 대신에 메서드 체인 형식의 함수형 프로그래밍으로 대처 불가능한가?
- HTTP API 통신을 위한 OkHttpClient 기반 Retrofit2 클래스를 스프링 빈으로 등록해서 관리하기 vs 사용할 때마다 new로 생성하기
  - 해당 클래스를 빈 등록 후 싱글톤으로 사용했을 때 문제점이 있는가? (예를 들면, 동시성 문제, 쓰레드 관리 문제 등)

### 고민
- try-catch에서 catch의 타입 한정짓기 vs `Exception`으로 사실상 모두 커버하기
  - 현재 작업 중인 레거시 코드 구조 상, 트랜잭션이 하나로 걸려있고(Propagation.REQUIRED 일괄 적용) 관리가 잘 되지않아 Exception이 다른 메서드로 전파될 경우 해당 트랜잭션이 모두 롤백되는 구조. 따라서 주로 방어적인 try-catch (`catch (Exception e)`)를 사용 중임.
  - 트랜잭션을 메서드마다 활용에 맞게 분리하는 작업이 필요 (트랜잭션 Propagation 및 Isolation 레벨에 대한 공부 필요)
  - 반복되는 try-catch를 지양하기 위해 커스텀 Exception은 RuntimeException을 상속하라는 팁의 유효성을 느낌
- try 블록 크기 관련
  - 최소화 -> 코드 분기가 발생 (가독성 저하 우려)
  - 하나로 묶을 수록, try 블록과 catch에서 담당해야 할 기능/책임/Exception이 많아짐, catch에서 찍어주는 log의 정보가 구체적인 것과 멀어지고 점점 일반화됨.
  - 담당 개발자의 선택의 문제인 것 같지만, 유지보수/가독성/확장성을 최대한 동시에 만족하는 좋은 코드를 만들고 싶음.
