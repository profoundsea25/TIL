# FETCH JOIN에 관하여
> 김영한님의 [자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic/dashboard) 강의 내용 정리입니다.

#### 페치 조인(Fetch join) [실무에서 자주 사용, 정말 중요]
- SQL JOIN의 종류는 아니다.
- JPQL에서 성능 최적화를 위해 제공하는 기능이다.
- 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능
- join fetch 명령어 사용
- `fetch join ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 경로`

#### JPQL의 DISTINCT의 2가지 기능
- SQL에 DISTINCT를 추가
- 애플리케이션에서 엔티티 중복 제거

#### 주의 : 1대다 JOIN이 일어나면 데이터가 '다' 쪽의 수만큼 데이터가 늘어나서 조회된다. (일명 데이터 뻥튀기)

#### 페치 조인과 일반 조인의 차이
- 일반 조인 실행시 연관된 엔티티를 함께 조회하지 않음. 즉 결과를 반환할 때 연관관계를 고려하지 않음
- 페치 조인을 사용할 때만 연관된 엔티티도 함께 조회(즉시 로딩). 페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념
-> 페치 조인으로 N+1 문제를 거의 해결한다.

#### 페치 조인의 한계
- 페치 조인 대상에는 별칭을 줄 수 없다. (하이버네이트는 가능하나, 가급적 사용하지 않는 것이 좋다.)
  - JPA 객체 그래프 사상과 맞지 않다. 정확성 이슈가 있다. 올바른 결과를 가져오지 않거나 예기치 않은 함수가 작동될 여지가 있다.
- 둘 이상의 컬렉션은 페치 조인 할 수 없다.
- 컬렉션을 페치 조인하면 페이징 API(`setFirstResult()`, `setMaxResults()`)를 사용할 수 없다.  
  - 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
  - 일대`다`, 다대`다`는 데이터를 `다` 쪽에 있는만큼 뻥튀기가 되기 때문에 일단 성능상 이슈가 발생.
  - 하이버네이트는 경고 로그를 남기고 메모리에서 페이징 (매우 위험)
  - 해결방법
    - 일대다 관계를 다대일 관계로 바꾸기
    - fetch join을 사용하지 않고, Batch 사이즈(한 번 조회할 때 얼마나 가져올지) 조정을 통해 가능 (글로벌 설정 `hibernate.default_batch_fetch_size = 1000 이하 적당한 수`)
    - 결과를 받을 DTO를 따로 만들기

#### 페치 조인의 특징
- 연관된 엔티티들을 SQL 한 번으로 조회 - 성능 최적화
- 엔티티에 직접 적용하는 글로벌 로딩 전략(예를 들면, `@OneToMany(fetch = FetchType.LAZY)`)보다 우선함
- 실무에서 글로벌 로딩 전략은 모두 지연 로딩
- 최적화가 필요한 곳은 페치 조인 적용


#### 페치 조인 정리
- 모든 것을 페치 조인으로 해결할 수는 없음
- 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적
- 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 페치 조인보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적
- 실무에서 발생하는 성능 문제는 7~80%는 N+1 문제이고, 대부분 Fetch Join으로 해결 가능하다.
