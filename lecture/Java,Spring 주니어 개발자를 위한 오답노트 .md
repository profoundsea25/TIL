# [Java/Spring 주니어 개발자를 위한 오답노트](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%A3%BC%EB%8B%88%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%98%A4%EB%8B%B5%EB%85%B8%ED%8A%B8)
- 강사: 김우근

## 오리엔테이션
- 순차 지향 프로그래밍 = Sequential Oriented Programing
  - ex. 어셈블리어
- 절차 지향 프로그래밍 = Procedure Oriented Programming
  - ex. C
  - 프로시져란? 보통 루틴, 서브루틴, 서브프로그램, 함수, 메서드 등으로 불리는 것이다.
  - 절차 지향 프로그래밍이란, 함수 지향 프로그램이다. 그래서 C가 main 함수로부터 시작한다.

## 실천 할 수 있는 컨벤션 교정
- 패키지명은 전부 소문자로 쓴다. 구분자 없다.
- id 같이 아주 관습적인 것을 제외하고는 변수명 줄여쓰지 않기.
- 축약어는 하나의 단어로 간주한다.
  - ex. LDAP, API ... -> Ldap, Api ...
- `simple`, `light`, `base`, `common` 등의 단어 쓰지 않기.
- `get` vs `find`
  - `get`은 `return T or throw`
    - 갖고 있는 정보를 단순히 가져온다는 뜻이다. 연산을 한다는 뜻이 아니다.
  - `find`는 `return Optional<T>`
- 범위를 인자로 받을 때는 start는 포함, end는 제외이다.
- verify, validate, check, is 4가지 모두 뉘앙스가 다르다.
  - is = 참/거짓을 표현
  - check = 조건이나 규칙을 만족하지 않으면 throw
  - validate = 데이터의 유효성 검사
  - verify = 기대한 대로 동작하는지 증명

## 객체 지향적인 코드 짜기 (1) : 객체의 종류, 행동
#### VO (Value Object)
- 값 객체
- 프로퍼티 불변인 객체
- 프로퍼티의 값이 항상 "유효"하다.
- 생성 시, 유효하지 않은 상태의 VO는 throw한다.

#### 생성자의 역할
- 값을 검증
- 값을 할당

#### DTO (Data Transfer Object)
- 데이터 전송 객체
- 함수, 클래스, 프로세스 간 전송에 쓰는 모든 객체를 통틀어 DTO라고 한다.
- 모든 프로퍼티가 public이다. 상태를 보호하지 않기 때문이다.

#### Entity
- 유일한 식별자가 있고, 생명 주기가 있으며, 저장소에 저장되는 것.

#### 객체의 종류는 중요하지 않다.
- 어떤 값을 불변으로 만들지, 어떤 인터페이스를 노출할 것인지가 훨씬 중요하다.

#### 클래스를 만들 때는 "행동"에 집중한다.
- 데이터 위주 사고로 클래스를 만들지 않는다. 그것은 `struct`다.
- 객체가 어떤 행동을 하는지가 중요하다. 행동 위주로 설계를 한다면 객체 지향일 가능성이 높다.
- javascript의 경우, 행동이 같다면 같은 클래스로 취급한다.

#### 순환 참조를 지양한다.
- 간접 참조(다른 엔티티의 id만 가진다.)를 하거나, 순환참조가 되는 영역을 다른 컴포넌트로 분리한다.

## 설계 (1) : 의존성이란 무엇인지? (DI vs DIP)
### 의존성이란 무엇인지?
- 인터페이스는 곧 경계/계약이다.
  - 쉽게 생각하면 public 메서드다.
- 리스코프 치환 원칙
  - = 하위 클래스는 상위 클래스의 규칙을 깨서는 안 된다.
  - = 하위 클래스는 상위 클래스로 대체될 수 있어야 한다.
- 의존성 역전 원칙
  - = 구현체에 바로 의존하지 마라.
- 의존성 주입은 의존성을 "약화"하는 것이다.
  - 여전히 의존성이 있다.

### 의존성 조언
- 의존성을 드러내라.
  - 변하는 값(시간, 랜덤 등)은 주입을 받아라.
    - 의존성을 제대로 처리하지 않으면 테스트하기 힘들다.
    - 의존성이 명확해지고, 테스트가 훨씬 수월해진다.
    - 테스트하기가 쉽다면 좋은 코드일 확률이 높다.
  - 변하는 값을 추상화시켜라
    - = 컴파일 타임 의존성과 런타임 의존성을 다르게 하라.

### CQRS (Command and Query Responsibility Segregation)
- 명령의 질의를 분리하라.
- 명령 메서드는 객체의 상태를 변경하지만, 값을 반환하지 않는다. (`return` 값이 없다.)
- 질의 메서드는 값을 반환하지만, 객체를 변경하지 않는다.

### 설계
- 설계에 정답이 없다. 모아야 할 코드를 너무 분산시키거나, 분산되어야 할 코드가 뭉쳐있는 경우가 많다.
- 책<Working Effectively with Legacy Code> 추천

## 기타 팁
- 엔지니어란, 수십년을 운영할 프로그램을 설계할 줄 아는 사람이다. 시간, 규모, 트레이드오프를 고려할 줄 아는 사람이다.
- 객체 지향이란, 역할 책임 협력

## 스프링에서 OOP와 안티 패턴 : Transaction script
- 테스트를 먼저 생각하고 개발하기
- 컨트롤러의 역할 = 어떤 서비스를 실행할지 선택하는 것
- 도메인 객체가 문제를 해결하게 하는 레이어다.
  - 서비스계층은 최대한 얇게 유지되어야 한다.
  - 오직 작업을 조정하고 아래에 위치한 계층에 도메인 객체의 협력자에게 작업을 위임한다.
- 비즈니스 로직은 서비스 계층이 아니라 도메인 계층에 있어야 한다.
- 특정 도메인 객체로 할당하기 애매한 로직들이 있다. 이러한 로직이 목적인 객체를 '도메인 서비스'라고 한다.
  - 도메인 객체들을 하나로 묶어 로직을 수행한다.
  - 보통 `Manager`라는 이름이 붙는다.
- DDD는 Domain Driven Design 이다.
  - 마지막이 Development가 아니기 때문에 개발 이상의 이야기를 해야 한다.
- OOP는 Object Oriented Programming이다.
  - 객체 지향 프로그래밍이지, 클래스 지향 프로그래밍이 아니다.

## 어디까지 추상화 해야 하는가?
- 추상화
  - 책임을 선별하는 과정
  - 인터페이스를 선별하는 과정
- 의존성 역전의 핵심
  - 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함
- 시스템 외부 연동은 추상화한다.
  - JPA, WebClient, RestClient 등
- Controller, Service, Entity, VO는 구현체로 구현되어도 상관없다. (의존성 역전하지 않아도 좋다.)
  - 컨트롤러, 서비스 등은 한 번 생성으로 영원히 같은 일을 할 수 있는 객체이기 때문이다. (그래야 한다.)
  - 따라서 서비스는 구현체여도 상관없다.
- 도메인 레이어를 만들자.
- 테스트하기 좋은 코드는 좋은 설계일 가능성이 높다.
## 서비스란 무엇인가?
- 서비스란 단어는 DDD에서 가져온 것이고, 이는 `Buisness Service Facade`를 뜻한다. by Spring 설명
- 애플리케이션 서비스는 도메인과 도메인 서비스에게 책임을 위임하는 파사드 패턴의 일종이다.
- 도메인 객체가 하지 못하는 중요한 도메인 연산을 위한 객체.
- 서비스는 가능한 적게 만들고 얇게 만들어야 한다. 도메인 객체를 풍부하게 만들어야 한다.
- 한번 생성하면 특정 작업을 하는 작은 기계처럼 영원히 실행할 수 있다. 즉, 불면이어야 한다.
  - 그래서 setter 주입이 아닌 생성자 주입으로 만들어야 한다.

## 기타 꿀팁
- JPA에서 양방향 관계를 지양할 것
- 낙관적 락은 잠금보단 충돌 방지에 가깝다.## 서비스란 무엇인가?
- 서비스란 단어는 DDD에서 가져온 것이고, 이는 `Buisness Service Facade`를 뜻한다. by Spring 설명
- 애플리케이션 서비스는 도메인과 도메인 서비스에게 책임을 위임하는 파사드 패턴의 일종이다.
- 도메인 객체가 하지 못하는 중요한 도메인 연산을 위한 객체.
- 서비스는 가능한 적게 만들고 얇게 만들어야 한다. 도메인 객체를 풍부하게 만들어야 한다.
- 한번 생성하면 특정 작업을 하는 작은 기계처럼 영원히 실행할 수 있다. 즉, 불면이어야 한다.
  - 그래서 setter 주입이 아닌 생성자 주입으로 만들어야 한다.

## 기타 꿀팁
- JPA에서 양방향 관계를 지양할 것
- 낙관적 락은 잠금보단 충돌 방지에 가깝다.

## 테스트를 해야 하는 이유와 테스트의 분류
- 레거시 코드란, 테스트코드가 없는 코드다. (다소 불완전한 정의)
- 회귀 테스트가 있어야 개발이 편하다.
- 인수 테스트는 시나리오 기반으로 사람이 직접 테스트하는 것이다.
- 우리가 집중해야 하는 것은 소형 테스트(Unit Test)이다. 전체 테스트의 80%를 차지해야 한다.

## 테스트에 필요한 개념
- SUT = System under test = 테스트하려는 대상
- 함수의 상태(반환값)을 검증하는 것이 좋다.
- Test Double
  - Dummy: 아무런 동작이 없고, 그저 코드가 정상적으로 돌아가기 위해 전달하는 객체
  - Fake: Local에서 사용하거나 테스트에서 사용하기 위해 만들어진 가짜 객체. 자체적인 로직이 있다.
  - Stub: 미리 준비된 값을 출력하는 객체
  - Mock: 메소드 호출을 확인하기 위한 객체. 자가 검증 능력을 갖춤. 사실상 테스트 더블과 동일한 의미로 사용된다.
  - Spy: 메소드 호출을 전부 기록했다가 나중에 확인하기 위한 객체
- BDDMockito는 Mockito 라이브러리를 BDD 스럽게 래핑한 것이다.
- Mock 프레임워크 사용 지양하기.
- 테스트코드의 목적
  - 회귀 버그 방지
  - 유연한 설계

## 테스트 기법 소개
### 테스트 조언
- private 메서드는 테스트하지 않는다.
  - 책임이 제대로 할당되지 않은 것일 수 있다.
  - 다른 클래스로 분리하고, 책임을 위임해서 public으로 만들어라.
- 메소드가 아니라, 행위를 기준으로 테스트해야 한다.
- 테스트할때는 서술적이고 의미 있는 문구를 사용하는 것이 좋다. 코드가 중복된다고 하더라도 그렇다.
- 테스트에 논리를 넣지 말자. (if문, for문, 덧셈, 뺄셈 등)

### 테스트 기법
- 테스트하기 어려운 의존성이 있을 때, 인터페이스로 추상화를 한다. 혹은 의존성 주입을 사용한다.
- 테스트를 위한 메서드가 프로덕션 코드에 포함되지 않도록 한다.

### 추가 팁
- 추상화는 안 하는 것보다 하는 것이 더 나을 때가 많다.
- 테스트는 행동 위주로 작성해야 한다.
- TDD도 한계가 있다.
  - 요구사항이 명확하지 않으면 적용하기 쉽지 않다.
  - 환경 제어가 힘들다.
  - 기존 코드가 TDD를 적용하기 어려울 수 있다.
  - 프로젝트가 TDD의 손익 분기점을 넘기지 못할 수 있다.

## 네트워크 용어 정리 (1) : DNS, LB, FQDN 등
- 도메인 : 네트워크 상에서 컴퓨터를 식별하는 호스트명
- DNS : 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있다.
- VIP : Virtual IP. 대표 IP(가상 IP). 로드 밸런싱도 수행
- LB : Load Balancing. 부하 분산
- SLB : Server Load Balancing. 사실상 로드 밸런서와 동일한 말
- GSLB : Global Server Load Balancing
  - 지역을 넘나드는 LB
  - LB기 때문에 도메인을 가진다.
  - LB의 Health Check 기능도 있다.
- L7 로드밸런싱 : URI나 Http 값을 기준으로 로드밸런싱 하는 것
- FQDN : 도메인은 기본적으로 서브도메인(ex. www)를 갖는다. 이러한 서브도메인을 기준으로 구분한 도메인을 FQDN(full quailified domain name)이라고 한다.

## 네트워크 용어 정리 (2) : CDN, ACL, Proxy, SSL 등
- CDN : Content Delivery Network
  - 콘텐츠를 효율적으로 전달하기 위해 여러 노드를 가진 네트워크에 데이터를 저장하여 제공하는 시스템
- ACL : Access Control List
  - 액세스 제어 목록은 개체나 개체 속성에 적용되어 있는 허가 목록이다.
  - 네트워크에 접근을 허가하는 IP 목록
- Proxy : 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터/응용 프로그램
  - 포워드 프록시 = 일반적으로 Proxy
  - 리버스 프록시 = 부하 분산
- Web Server
  - html, css 내려주는 역할
  - proxy 역할
- SSL
  - HTTPS를 사용할 수 있게 하는 프로토콜
  - 향상된 버전 = TLS

## 인프라 용어 정리 : XaaS, 컨테이너 등
- XaaS = X as a Service
- 온프레미스 : 직접 서버를 설치해 운영하여 서비스를 전달하는 방식
- 온디멘드 : 수요가 필요한 즉시 바로 서비스를 전달하는 방식
- VM : 가상 머신. 한 대의 컴퓨터에서 논리적으로 구동되는 (여러 개의) 운영 체제/컴퓨터
- Container : OS 레벨에서 애플리케이션 실행 환경을 격리하여, 마치 다른 OS에서 동작하는 것과 같은 가상 실행 환경을 제공하는 기술
  - cgroups(control groups) 기능이 있어어 컨테이너 기술을 사용할 수 있다.
    - 프로세스들의 자원 사용(CPU, 메모리, 디스크 등)을 제한하고 격리시키는 리눅스 커널 기능
- Docker : 컨테이너를 실행하고 관리하는 솔루션
  - 인프라 세팅을 획기적으로 도와주었다.
  - Docker Compose를 통해 미리 지정한 도커 이미지를 한 번에 구동시킬 수 있다.
- VPN : Virtual Private Network. 공중 네트워크를 통해 특정 네트워크와 통신할 목적으로 쓰이는 사설 통신망
- VDI : Virtual Desktop Infrastructure
  - 가상화된 데스크탑에 원격으로 접속 가능한 기술

## 운영 용어 정리 : MSA, 오픈소스, CI/CD 등
- HA = High Availability
  - 고가용성 = 가용성이 높다 = 고장 나지 않는다.
- Provisioning
  - 필요 시 시스템을 즉시 사용할 수 있는 상태로 미리 준비해 두는 것
- Failover
  - 장애 극복 기능
  - 이상이 생겼을 때 예비 시스템으로 "자동 전환"되는 기능
- Switchover
  - 사람이 수동으로 예비 시스템으로 전환하는 기능
- Failback
  - Failover 이전 상태로 되돌리는 것
- Jenkins / Ansible = 스크립트 처리기
- 오픈소스 라이센스
  - Apache, MIT는 문제 없이 사용 가능함.
- Agile
  - 문서 보단 개발에 중점을 두고, 고객의 요구사항을 충족시키고, 언제든 변화할 상태를 유지한다.
  - 절차와 규칙 보다는 팀 자체를 어떤 상황에서도 대처 가능한 팀으로 만들어야 한다. (정신 무장에 가깝다.)
- DevOps
  - 개발과 운영을 한 팀에서 한다.
  - = 소프트웨어 개발자와 정보기술 전문가의 통합
  - 크게 개발-빌드-배포 3단계로 나뉜다.
- CI/CD
  - 빌드/테스트는 CI, 패키지/배포는 CD
  - `자동 빌드 / 자동 배포` 의미에 가까움.
- Webhook
  - 이벤트가 발생했을 때 연쇄적으로 발생시키는 API 호출 (Callback)

## 쿠버네티스 맛보기
- 컨테이너 오케스트레이션
  - 컨테이너를 자동으로 배포, 관리, 스케일링할 수 있도록 도와주는 도구
  - ex. 쿠버네티스, 도커 스웜
- 쿠버네티스 핵심 구조
  - ingress -> service -> pod
  - ingress
    - WEB 서버 역할
  - service
    - 포트포워딩
  - pod
    - 배포 기본 단위
    - 컨테이너 이미지를 띄우는 곳
    - pod인 이유는 고래/돌고래의 포유류 무리를 뜻하는데, 도커 아이콘이 고래다 보니 pod
- 쿠버네티스 구조
  - object
    - ingress/service/pod에 해당
  - controller
    - object를 컨트롤하기 위함
- 배포 과정
  - 서비스 개발자가 repo에 코드 push
  - CI 도구(젠킨스, GitHub Actions)가 코드를 빌드하고 도커 이미지 생성
  - 생성된 도커 이미지를 도커 허브로 전달
  - 수동 배포 시) kubectl, ArgoCD 같은 배포 애플리케이션을 사용해서 쿠버네티스를 조작해 도커 이미지 배포
  - 자동 배포 시) ArgoCD에 hook을 걸어 배포를 자동화
- 더 알면 좋은 것들
  - probe
    - 쿠버네티스에게 헬스 체크를 어떻게 하면 할 수 있는지 알려주는 방식
  - resources
    - 도커 이미지가 사용할 수 있는 CPU, Memory를 지정하는 방식

## NoSQL 정리
### 목적에 맞는 NoSQL
- Redis
  - 재고를 보여줄 때 사용
  - 원본 DB를 직접 조회하지 않도록 방지
- 메시지 큐(Kafka, RabbitMQ, redis)
  - 병렬성과 모듈 간의 의존성을 낮추고자 할 경우
  - 통신 시 유실을 방지하고자 할 경우
	- Client에서 polling을 사용하지 않은 경우
- elasticsearch, solr
  - 검색 특화
- influxdb, openTSDB, druid
  - 시계열 데이터를 다루고 차트를 그려야 하는 경우

### Key-Value DB
- 거대한 Map
- Redis
  - 싱글 스레드
  - 샤딩과 클러스터 모드로 확장
  - keys 명령어는 지양할 것

### Wide Column DB
- 대량의 데이터를 동적인 컬럼을 갖는 테이블에 r/w
- 데이터 압축, 분산처리에 특화
- Cassandra
  - Consistent Hashing (노드를 골고루 저장)
  - 파티션 키가 매우 중요하다.
  - 쓰기 성능이 매우 빠르다.

### Document DB
- json-like Document를 읽고 저장
- Elasticsearch
	- 검색에 특화
- 인덱스라는 데이터 스키마를 사용
- 인덱스가 많아지면 좋지 않음
- update 없음 (엄밀하게, update를 하면 삭제 -> 삽입을 수행함.)
- 통계내기 좋음
- MongoDB
  - 트랜잭션 지원(4버전 이후)
  - 전문 검색 기능 제공

### Graph DB
- 관계망, 구독 모델을 표현할 떄 주로 사용
- neo4j

### Message system
- 거대한 큐. DB라고 하기엔 약간 부족
- Kafka
  - 개념 : 토픽/파티션/컨슈머 그룹/컨슈머
  - 프로듀서가 토픽을 퍼블리싱하면 토픽은 키값에 따라 특정 파티션으로 데이터를 보냄
  - 파티션을 바라보는 컨슈머들이 데이터를 들고 와서 처리
  - 하나의 파티션에는 컨슈머 그룹당 하나의 컨슈머만 통신할 수 있다.
  - 파티션이 이벤트를 발행하는 구조가 아니라, 컨슈머가 읽어가는 구조.
  - 파티션 내부 순서는 보장되지만, 메시지 순서는 보장되지 않음.
  - 파티션 키가 중요함. (메시지가 브로커에 고르게 분산되어야 한다.)
  - 파티션은 축소가 되지 않음. 그래서 처음부터 크게 구성하지 않는다.

### 더 알아볼 주제
- Hadoop : HDFS(분산 저장 시슴) + MapReduce 모듈
- Zookeeper : 분산 환경의 코디네이션을 위한 트리 형태의 데이터 저장소

## 개발 용어 정리 : OAuth, Rest, 불변성 등
### Rest API
- 리소스는 복수형을 사용하기
- 끝에 `/` 붙이지 않기
- PUT은 멱등성이 보장되고, PATCH는 멱등성이 보장되지 않는다.
- PATH에 동사를 쓰지 않는다.

### OAuth
- 인증 = 이 토큰이 유효한가? -> 실패 시 401
- 인가 = 이 토큰으로 접근할 수 있는가? -> 실패시 403

### SSO
- Single Sign-On
- 로그인 한 번으로 여러 서비스를 이용할 수 있다.

### 함수형 프로그래밍
- 자료 처리를 수학적 함수의 계산으로 취급하고, 상태와 가변 데이터를 멀리하는 프로그래밍
- 부수효과(side-effect)가 없는 immutable, pure function을 지향
- 부수효과(side-effect)
  - 함수를 수행할 때, 명시적 입출력 외에 암묵적 입출력이 발생하는 것

### 라이브러리 vs 프레임워크
- 프로그램 주도권을 누가 갖고 있느냐로 구분. = 컴포넌트 생성과 호출의 주체가 누구인가? = IoC 컨테이너 유무

### CORS
- 아무 도메인에서나 우리 서비스를 호출하는 것을 막기 위한 정책.
- 웹 페이지 상의 제한된 리소스를 최초 자원이 서비스된 도메인 밖의 다른 도메인으로부터 요청할 수 있게 허용하는 구조.
- 브라우저 단에서 동작하는 정책 = 포스트맨이나 curl을 이용하면 CORS 검증이 없다.

### 패키지 매니저
- 개발 환경을 도와주는 패키지 관리 도구 관리자.
- 중앙 저장소에서 다운로드 받는다.
