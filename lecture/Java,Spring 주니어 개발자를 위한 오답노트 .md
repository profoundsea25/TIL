# [Java/Spring 주니어 개발자를 위한 오답노트](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%A3%BC%EB%8B%88%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%98%A4%EB%8B%B5%EB%85%B8%ED%8A%B8)
- 강사: 김우근

## 오리엔테이션
- 순차 지향 프로그래밍 = Sequential Oriented Programing
  - ex. 어셈블리어
- 절차 지향 프로그래밍 = Procedure Oriented Programming
  - ex. C
  - 프로시져란? 보통 루틴, 서브루틴, 서브프로그램, 함수, 메서드 등으로 불리는 것이다.
  - 절차 지향 프로그래밍이란, 함수 지향 프로그램이다. 그래서 C가 main 함수로부터 시작한다.

## 실천 할 수 있는 컨벤션 교정
- 패키지명은 전부 소문자로 쓴다. 구분자 없다.
- id 같이 아주 관습적인 것을 제외하고는 변수명 줄여쓰지 않기.
- 축약어는 하나의 단어로 간주한다.
  - ex. LDAP, API ... -> Ldap, Api ...
- `simple`, `light`, `base`, `common` 등의 단어 쓰지 않기.
- `get` vs `find`
  - `get`은 `return T or throw`
    - 갖고 있는 정보를 단순히 가져온다는 뜻이다. 연산을 한다는 뜻이 아니다.
  - `find`는 `return Optional<T>`
- 범위를 인자로 받을 때는 start는 포함, end는 제외이다.
- verify, validate, check, is 4가지 모두 뉘앙스가 다르다.
  - is = 참/거짓을 표현
  - check = 조건이나 규칙을 만족하지 않으면 throw
  - validate = 데이터의 유효성 검사
  - verify = 기대한 대로 동작하는지 증명

## 객체 지향적인 코드 짜기 (1) : 객체의 종류, 행동
#### VO (Value Object)
- 값 객체
- 프로퍼티 불변인 객체
- 프로퍼티의 값이 항상 "유효"하다.
- 생성 시, 유효하지 않은 상태의 VO는 throw한다.

#### 생성자의 역할
- 값을 검증
- 값을 할당

#### DTO (Data Transfer Object)
- 데이터 전송 객체
- 함수, 클래스, 프로세스 간 전송에 쓰는 모든 객체를 통틀어 DTO라고 한다.
- 모든 프로퍼티가 public이다. 상태를 보호하지 않기 때문이다.

#### Entity
- 유일한 식별자가 있고, 생명 주기가 있으며, 저장소에 저장되는 것.

#### 객체의 종류는 중요하지 않다.
- 어떤 값을 불변으로 만들지, 어떤 인터페이스를 노출할 것인지가 훨씬 중요하다.

#### 클래스를 만들 때는 "행동"에 집중한다.
- 데이터 위주 사고로 클래스를 만들지 않는다. 그것은 `struct`다.
- 객체가 어떤 행동을 하는지가 중요하다. 행동 위주로 설계를 한다면 객체 지향일 가능성이 높다.
- javascript의 경우, 행동이 같다면 같은 클래스로 취급한다.

#### 순환 참조를 지양한다.
- 간접 참조(다른 엔티티의 id만 가진다.)를 하거나, 순환참조가 되는 영역을 다른 컴포넌트로 분리한다.

## 설계 (1) : 의존성이란 무엇인지? (DI vs DIP)
### 의존성이란 무엇인지?
- 인터페이스는 곧 경계/계약이다.
  - 쉽게 생각하면 public 메서드다.
- 리스코프 치환 원칙
  - = 하위 클래스는 상위 클래스의 규칙을 깨서는 안 된다.
  - = 하위 클래스는 상위 클래스로 대체될 수 있어야 한다.
- 의존성 역전 원칙
  - = 구현체에 바로 의존하지 마라.
- 의존성 주입은 의존성을 "약화"하는 것이다.
  - 여전히 의존성이 있다.

### 의존성 조언
- 의존성을 드러내라.
  - 변하는 값(시간, 랜덤 등)은 주입을 받아라.
    - 의존성을 제대로 처리하지 않으면 테스트하기 힘들다.
    - 의존성이 명확해지고, 테스트가 훨씬 수월해진다.
    - 테스트하기가 쉽다면 좋은 코드일 확률이 높다.
  - 변하는 값을 추상화시켜라
    - = 컴파일 타임 의존성과 런타임 의존성을 다르게 하라.

### CQRS (Command and Query Responsibility Segregation)
- 명령의 질의를 분리하라.
- 명령 메서드는 객체의 상태를 변경하지만, 값을 반환하지 않는다. (`return` 값이 없다.)
- 질의 메서드는 값을 반환하지만, 객체를 변경하지 않는다.

### 설계
- 설계에 정답이 없다. 모아야 할 코드를 너무 분산시키거나, 분산되어야 할 코드가 뭉쳐있는 경우가 많다.
- 책<Working Effectively with Legacy Code> 추천

## 기타 팁
- 엔지니어란, 수십년을 운영할 프로그램을 설계할 줄 아는 사람이다. 시간, 규모, 트레이드오프를 고려할 줄 아는 사람이다.
- 객체 지향이란, 역할 책임 협력

## 스프링에서 OOP와 안티 패턴 : Transaction script
- 테스트를 먼저 생각하고 개발하기
- 컨트롤러의 역할 = 어떤 서비스를 실행할지 선택하는 것
- 도메인 객체가 문제를 해결하게 하는 레이어다.
  - 서비스계층은 최대한 얇게 유지되어야 한다.
  - 오직 작업을 조정하고 아래에 위치한 계층에 도메인 객체의 협력자에게 작업을 위임한다.
- 비즈니스 로직은 서비스 계층이 아니라 도메인 계층에 있어야 한다.
- 특정 도메인 객체로 할당하기 애매한 로직들이 있다. 이러한 로직이 목적인 객체를 '도메인 서비스'라고 한다.
  - 도메인 객체들을 하나로 묶어 로직을 수행한다.
  - 보통 `Manager`라는 이름이 붙는다.
- DDD는 Domain Driven Design 이다.
  - 마지막이 Development가 아니기 때문에 개발 이상의 이야기를 해야 한다.
- OOP는 Object Oriented Programming이다.
  - 객체 지향 프로그래밍이지, 클래스 지향 프로그래밍이 아니다.

## 어디까지 추상화 해야 하는가?
- 추상화
  - 책임을 선별하는 과정
  - 인터페이스를 선별하는 과정
- 의존성 역전의 핵심
  - 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함
- 시스템 외부 연동은 추상화한다.
  - JPA, WebClient, RestClient 등
- Controller, Service, Entity, VO는 구현체로 구현되어도 상관없다. (의존성 역전하지 않아도 좋다.)
  - 컨트롤러, 서비스 등은 한 번 생성으로 영원히 같은 일을 할 수 있는 객체이기 때문이다. (그래야 한다.)
  - 따라서 서비스는 구현체여도 상관없다.
- 도메인 레이어를 만들자.
- 테스트하기 좋은 코드는 좋은 설계일 가능성이 높다.
## 서비스란 무엇인가?
- 서비스란 단어는 DDD에서 가져온 것이고, 이는 `Buisness Service Facade`를 뜻한다. by Spring 설명
- 애플리케이션 서비스는 도메인과 도메인 서비스에게 책임을 위임하는 파사드 패턴의 일종이다.
- 도메인 객체가 하지 못하는 중요한 도메인 연산을 위한 객체.
- 서비스는 가능한 적게 만들고 얇게 만들어야 한다. 도메인 객체를 풍부하게 만들어야 한다.
- 한번 생성하면 특정 작업을 하는 작은 기계처럼 영원히 실행할 수 있다. 즉, 불면이어야 한다.
  - 그래서 setter 주입이 아닌 생성자 주입으로 만들어야 한다.

## 기타 꿀팁
- JPA에서 양방향 관계를 지양할 것
- 낙관적 락은 잠금보단 충돌 방지에 가깝다.## 서비스란 무엇인가?
- 서비스란 단어는 DDD에서 가져온 것이고, 이는 `Buisness Service Facade`를 뜻한다. by Spring 설명
- 애플리케이션 서비스는 도메인과 도메인 서비스에게 책임을 위임하는 파사드 패턴의 일종이다.
- 도메인 객체가 하지 못하는 중요한 도메인 연산을 위한 객체.
- 서비스는 가능한 적게 만들고 얇게 만들어야 한다. 도메인 객체를 풍부하게 만들어야 한다.
- 한번 생성하면 특정 작업을 하는 작은 기계처럼 영원히 실행할 수 있다. 즉, 불면이어야 한다.
  - 그래서 setter 주입이 아닌 생성자 주입으로 만들어야 한다.

## 기타 꿀팁
- JPA에서 양방향 관계를 지양할 것
- 낙관적 락은 잠금보단 충돌 방지에 가깝다.

## 테스트를 해야 하는 이유와 테스트의 분류
- 레거시 코드란, 테스트코드가 없는 코드다. (다소 불완전한 정의)
- 회귀 테스트가 있어야 개발이 편하다.
- 인수 테스트는 시나리오 기반으로 사람이 직접 테스트하는 것이다.
- 우리가 집중해야 하는 것은 소형 테스트(Unit Test)이다. 전체 테스트의 80%를 차지해야 한다.

## 테스트에 필요한 개념
- SUT = System under test = 테스트하려는 대상
- 함수의 상태(반환값)을 검증하는 것이 좋다.
- Test Double
  - Dummy: 아무런 동작이 없고, 그저 코드가 정상적으로 돌아가기 위해 전달하는 객체
  - Fake: Local에서 사용하거나 테스트에서 사용하기 위해 만들어진 가짜 객체. 자체적인 로직이 있다.
  - Stub: 미리 준비된 값을 출력하는 객체
  - Mock: 메소드 호출을 확인하기 위한 객체. 자가 검증 능력을 갖춤. 사실상 테스트 더블과 동일한 의미로 사용된다.
  - Spy: 메소드 호출을 전부 기록했다가 나중에 확인하기 위한 객체
- BDDMockito는 Mockito 라이브러리를 BDD 스럽게 래핑한 것이다.
- Mock 프레임워크 사용 지양하기.
- 테스트코드의 목적
  - 회귀 버그 방지
  - 유연한 설계

## 테스트 기법 소개
### 테스트 조언
- private 메서드는 테스트하지 않는다.
  - 책임이 제대로 할당되지 않은 것일 수 있다.
  - 다른 클래스로 분리하고, 책임을 위임해서 public으로 만들어라.
- 메소드가 아니라, 행위를 기준으로 테스트해야 한다.
- 테스트할때는 서술적이고 의미 있는 문구를 사용하는 것이 좋다. 코드가 중복된다고 하더라도 그렇다.
- 테스트에 논리를 넣지 말자. (if문, for문, 덧셈, 뺄셈 등)

### 테스트 기법
- 테스트하기 어려운 의존성이 있을 때, 인터페이스로 추상화를 한다. 혹은 의존성 주입을 사용한다.
- 테스트를 위한 메서드가 프로덕션 코드에 포함되지 않도록 한다.

### 추가 팁
- 추상화는 안 하는 것보다 하는 것이 더 나을 때가 많다.
- 테스트는 행동 위주로 작성해야 한다.
- TDD도 한계가 있다.
  - 요구사항이 명확하지 않으면 적용하기 쉽지 않다.
  - 환경 제어가 힘들다.
  - 기존 코드가 TDD를 적용하기 어려울 수 있다.
  - 프로젝트가 TDD의 손익 분기점을 넘기지 못할 수 있다.
