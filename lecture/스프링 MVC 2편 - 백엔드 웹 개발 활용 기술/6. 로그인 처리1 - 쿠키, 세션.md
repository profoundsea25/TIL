> 김영한님의 [스프링 MVC 2편 - 백엔드 웹 개발 활용 기술](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-2/dashboard) 강의 내용을 정리한 것입니다.

# 6. 로그인 처리1 - 쿠키, 세션
### 도메인이 가장 중요하다.
- 도메인 = 화면, UI, 기술 인프라 등등의 영역을 제외한 시스템이 구현해야 하는 핵심 비즈니스 업무 영역
- 향후 웹(web)을 다른 기술로 바꾸어도 도메인은 그대로 유지할 수 있어야 함.
- 웹은 도메인을 알고 있지만, 도메인은 웹을 모르도록 설계해야 함. 이를 웹은 도메인에 의존하지만, 도메인은 웹을 의존하지 않는다고 표현.
- 극단적으로 웹 패키지를 모두 삭제해도 도메인에는 전혀 영향이 없도록 의존관계를 설계해야 한다.
- 즉 도메인은 웹을 참조하면 안 된다.

### 로그인 처리하기 - 쿠키 사용
- 로그인 상태를 유지하기 위해 쿼리 파라미터를 계속 유지하면서 보내는 것은 매우 어렵고 번거롭다.
- 이를 해결하기 위해 쿠키 사용
  - 서버에서 로그인에 성공하면 HTTP 응답에 쿠키를 담아서 브라우저 전달.
  - 브라우저는 앞으로 해당 쿠키를 지속해서 보내줌.
- 쿠키에는 영속 쿠키와 세션 쿠키가 있다.
  - 영속 쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유지
  - 세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료시까지만 유지

#### HomeController에서 Login 기능 만들기
- `@CookieValue`를 사용하면 편리하게 쿠키를 조회할 수 있다.
- 로그인 하지 않은 사용자도 홈에 접근할 수 있기 때문에 `required = false` 사용

### 쿠키와 보안 문제
#### 보안 문제
- 쿠키 값은 임의로 변경할 수 있다.
  - 클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 된다.
- 쿠키에 보관된 정보는 훔쳐갈 수 있다.
- 해커가 쿠키를 한 번 훔쳐가면 평생 사용할 수 있다.
#### 대안
- 쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출하고, 서버에서 토큰과 사용자 id를 매핑해서 인식한다. 그리고 서버에서 토큰을 관리한다.
- 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능 해야 한다.
- 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게(예를 들면 30분) 유지한다. 또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다.

### 로그인 처리하기 - 세션 동작 방식
- 결국 중요한 정보를 모두 서버에서 저장하고, 클라이언트와 서버는 추정 불가능한 임의의 식별자 값으로 연결해야 한다.
- 이렇게 서버에 중요한 정보를 보관하고 연결을 유지하는 방법을 세션이라 한다.
- UUID는 추정이 불가능하다.
- 클라이언트와 서버는 결국 쿠리로 연결이 되어야 한다.
- 중요한 포인트는 회원과 관련된 정보는 전혀 클라이언트에 전달하지 않는다는 것이다.
- 오직 추정 불가능한 세션 ID만 쿠키를 통해 클라이언트에 전달한다.

#### 정리
- 쿠키 값을 변조 가능 -> 예상 불가능한 복잡한 세션 ID를 사용한다.
- 쿠키에 보관하는 정보는 클라이언트 해킹시 털릴 가능성이 있다. -> 세션ID가 털려도 여기에는 중요한 정보가 없다.
- 쿠키 탈취 후 사용 -> 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 세션의 만료시간을 짧게 유지한다. 또는 해킹이 의심되는 경우 서버에서 해당 세션을 강제로 제거하면 된다.
- 즉 쿠키를 사용하는데, 서버에서 데이터를 유지하는 방법

#### 직접 만들기
- 세션 생성
  - sesionId 생성 (임의의 추정 불가능한 랜덤 값)
  - 세션 저장소에 sessionId와 보관할 값 저장
  - sessionId로 응답 쿠키를 생성해서 클라이언트에 전달
- 세션 조회
  - 클라이어트가 요청한 sessionId 쿠키의 값으로, 세션 저장소에 보관한 값 조회
- 세션 만료
  - 클라이언트가 요청한 sessionId 쿠키의 값으로, 세션 저장소에 보관한 sessionId와 값 제거

### 로그인 처리하기 - 서블릿 HTTP 세션1
- 서블릿이 공식 지원하는 세션 기능 활용하기
- `HttpSession` 기능
- `HttpSession`을 생성하면 `JSESSIONID`라는 이름의 쿠키 생성, 값은 추정 불가능한 랜덤 값
- `session.getSession(true)` : 기존 세션이 있으면 세션 반환, 없으면 세션 생성해서 반환
- `session.getSession(false)` : 기존 세션이 있으면 세션 반환, 없으면 null 반환

### 로그인 처리하기 - 서블릿 HTTP 세션2
- 스프링은 세션을 더 편리하게 사용할 수 있도록 `@SessionAttribute`를 지원
#### 세션 타임아웃 설정
- 세션은 사용자가 로그아웃을 직접 호출해서 `session.invalidate()`가 호출 되는 경우에 삭제
- 그러나 대부분의 사용자는 로그아웃을 선택하지 않고, 그냥 웹 브라우저를 종료
- 문제는 HTTP가 비연결성(ConnectionLess)이므로, 서버 입장에서는 해당 사용자가 웹 브라우저를 종료한 것인지 아닌지를 인식할 수 없다.
- 따라서 서버에서 세션 데이터를 언제 삭제해야 하는지 판단하기 어렵다.
- 남아있는 세션을 무한정 보관하면 다음과 같은 문제 발생
  - 세션과 관련된 쿠키(`JSESSIONID`)를 탈취 당했을 경우 오랜 시간이 지나도 해당 쿠키로 악의적인 요청을 할 수 있다.
  - 세션은 기본적으로 메모리에 생성된다. 메모리의 크기가 무한하지 않기 때문에 꼭 필요한 경우만 생성해서 사용해야 한다.
#### 세션의 종료시점
- 세션 생성 시점으로부터 30분 정도 
  - 30분이 지나면 세션이 삭제되기 때문에 30분마다 로그인을 직접 해줘야 하는 문제 발생
- 사용자가 최근 서버에 요청한 시간을 기준으로 30분 정도를 유지
  - 이러면 사용자가 서비스를 사용하고 있으면, 세션 생존 시간이 30분씩 계속 늘어남.
  - 따라서 30분마다 로그인해야 하는 번거로움이 사라짐
  - `HttpSession`은 이 방식을 사용
- `session.getLastAccessedTime()`(최근 세션 접근 시간) 이후로 timeout시간이 지나면, WAS가 내부에서 해당 세션을 제거

#### 세션 타임아웃 설정
- 스프링 부트로 글로벌 설정
  - `application.properties`에 `server.servlet.session.timeout=60` : 60초, 기본은 1800(30분) (글로벌 설정은 초 단위로 설정)

### 정리 - 실무에서 주의할 점
- 세션에는 최소한의 데이터만 보관해야 한다.
- 보관한 데이터 용량 * 사용자 수로 세션의 메모리 사용량이 급격하게 늘어나서 장애로 이어질 수 있다.
- 세션의 시간을 너무 길게 가져가면 메모리 사용이 계속 누적될 수 있으므로 적당한 시간을 선택하는 것이 필요하다.
- 기본이 30분이라는 것을 기준으로 고민하자.

