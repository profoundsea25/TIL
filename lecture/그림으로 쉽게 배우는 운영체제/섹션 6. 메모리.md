> [그림으로 쉽게 배우는 운영체제](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard) 요약입니다.

## 섹션 6. 메모리
### 메모리 종류
#### 레지스터
- 가장 빠른 기억 장소. CPU 내에 존재. 휘발성 메모리. 32bit, 64bit은 레지스터의 크기를 말하는 것.
- 메인 메모리의 값을 레지스터로 가져와서 계산
#### 캐시
- 레지스터와 메인메모리 사이에 존재
- 레지스터에서 사용할 메인메모리 값을 미리 가져와서 저장해놓는 곳
#### 메인메모리(RAM)
- 실제 운영체제와 다른 프로세스들이 올라가는 공간
- 휘발성 메모리 (전원이 공급되지 않으면 데이터가 사라짐)
- 데이터 저장보다는 실행 중인 프로그램만 올림
#### 보조저장장치(HDD,SSD)
- 전원이 공급되지 않아도 데이터가 지워지지않는 비휘발성 메모리

### 메모리와 주소
- 멀티프로그램 환경에선 메모리에 여러 프로그램이 올라오니 메모리 관리가 복잡해짐
- 운영체제는 메모리를 1byte 크기로 나누고 숫자를 부여 = 주소

#### 물리주소와 논리주소
- 사용자는 물리주소를 몰라도 논리주소로 물리주소에 접근할 수 있음
- 운영체제를 위한 공간은 따로 할당
- 경계 레지스터 : 하드웨어적으로 운영체제 공간과 사용자 공간을 나눈 것. CPU 내에 존재하는 레지스터. 운영체제 영역을 침범한 사용자 프로그램이 있다면 강제 종료 시킴

#### 절대주소와 상대주소
- 개발자가 메모리를 신경 쓰지 않아도 되는 이유 : 컴파일러가 컴파일 할 때 메모리의 0번지부터 실행한다고 가정하기 때문
- 재배치 레지스터를 통해 상대주소로 절대주소에 접근하거나, 절대주소가 바뀌더라도 실행할 수 있음
- 사용자가 바라본 주소 = 상대 주소 = 논리 주소 공간
- 메모리 관리자가 바라본 주소 = 절대 주소  = 물리 주소 공간

### 메모리 할당 방식
#### 메모리 오버레이
- 메모리보다 큰 프로그램을 실행시키려면? in 유니프로그래밍
- 큰 프로그램을 작게 나누어 일부만 메모리에 올려 실행하고 일부는 하드디스크의 스왑영역에 저장하여 실행시키는 방법
- 물리적으로는 더 넓은 메모리 공간처럼 느껴지지만, 하드디스크에서 메모리로 스왑하는 과정에서 시간이 소요되기 때문에 상대적으로 느림

#### 가변 분할 방식(세그멘테이션)
- 프로세스의 크기에 따라 메모리를 나누는 방식 in 멀티프로그래밍
- 한 프로세스가 메모리에 연속된 공간에 할당되기 때문에 연속 메모리 할당이라고도 함
- 장점 : 메모리가 프로세스보다 더 크게 할당돼서 낭비되는 공간인 내부 단편화가 없음
- 단점 : 외부 단편화 발생
#### 고정 분할 방식(페이징)
- 프로세스 크기와 상관없이 메모리를 정해진 크기로 할당 in 멀티프로그래밍
- 한 프로세스가 메모리에 분산되어 할당되기 때문에 비연속 메모리 할당이라고도 함
- 장점 : 구현이 간단하고, 오버헤드가 적음
- 단점 : 작은 프로세스도 큰 영역에 할당돼서 공간이 낭비되는 내부 단편화가 발생

#### 외부 단편화
- 메모리의 빈 공간이 남더라도 연속된 공간이 아니어서 프로세스에게 새로운 프로세스에게 메모리를 할당할 수 없는 상황
- 외부 단편화가 발생한 공간을 합쳐주는 조각모음을 통해 해결 가능
- 하지만 조각모음을 하려면 현재 메모리에서 실행되고 있는 프로세스들의 작업을 일시 중지해야 하고, 메모리 공간을 이동시켜야 하는 작업이 발생하기 때문에 오버헤드 발생
#### 내부 단편화
- 해결방법은 없고, 분할되는 크기를 조절해서 내부단편화를 최소화

#### 버디 시스템
- 가변 분할 방식과 고정 분할 방식을 혼합한 것
- 2의 승수로 메모리를 분할해 메모리를 할당
- 프로세스가 메모리 할당을 원하면, 해당 프로세스보다 큰 값중 가장 작은 2의 배수로 공간을 할당
- 나중에 조각모음할 때도 공간 확보가 편함 (분할했던 것을 거꾸로 수행)
- 장점
  - 가변 분할 방식처럼 프로세스 크기에 따라 할당되는 메모리 크기가 달라지고 외부 단편화를 방지하기 위해 메모리 공간을 확보하는 것이 간단
  - 고정분할 방식처럼 내부 단편화가 발생하기는 하지만 많은 공간의 낭비가 발생하지는 않음
