> 김영한님의 [스프링 DB 1편 - 데이터 접근 핵심 원리](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-1) 강의 내용 정리입니다.

# 1. JDBC 이해
### JDBC 등장 이유
- 애플리케이션을 개발할 때 중요한 데이터는 대부분 데이터베이스에 보관한다.
- 클라이언트가 애플리케이션 서버를 통해 데이터를 저장하거나 조회하면, 애플리케이션 서버는 다음 과정을 통해서 데이터베이스를 사용한다.
  - 1. 커넥션 연결 : 주로 TCP/IP를 사용해서 커넥션을 연결한다.
  - 2. SQL 전달 : 애플리케이션 서버는 DB가 이해할 수 있는 SQL을 연결된 커넥션을 통해 DB에 전달한다.
  - 3. 결과 응답 : DB는 전달된 SQL을 수행하고 그 결과를 응답한다. 애플리케이션 서버는 응답 결과를 활용한다.
- 문제는 각각의 DB마다 커넥션 연결 방법, SQL 전달 방볍, 결과 응답 받는 방법이 모두 다르다는 점이다. 이는,
  - 1.DB를 다른 종류의 DB로 변경하면 애플리케이션 서버에 개발된 DB 사용 코드도 함께 변경해야 한다.
  - 2. 개발자가 각각의 DB마다 커넥션 연결, SQL 전달, 그리고 그 결과를 응답 받는 방법을 새로 학습해야 한다.
- 이러한 문제를 해결하기 위해 JDBC라는 자바 표준이 등장한다.

### JDBC 표준 인터페이스
- JDBC(Java Database Connectivity)는 자바에서 DB에 접속할 수 있ㄷ로고 하는 자바 API다. 
- JDBC는 DB에서 자료를 쿼리하거나 업데이트하는 방법을 제공한다.
- 대표적으로 3가지 기능을 표준 인터페이스로 정의해서 제공한다.
  - `java.sql.Connection` 연결
  - `java.sql.Statement` SQL을 담은 내용
  - `java.sql.ResultSet` SQL 요청 응답
- JDBC 드라이버 : JDBC 인터페이스를 각각의 DB 벤더에서 자신의 DB에 맞도록 구현해서 제공하는 라이브러리
- JDBC 등장으로,
  - 1. 애플리케이션 로직은 이제 JDBC 표준 인터페이스에만 의존한다. 따라서 DB를 다른 종류의 DB로 변경하고 싶으면 JDBC 구현 라이브러리만 변경하면 된다. 따라서 다른 종류의 DB로 변경해도 애플리케이션 서버의 사용 코드를 그대로 유지할 수 있다.
  - 2. 개발자는 JDBC 표준 인터페이스 사용법만 학습하면 된다. 한번 배우면 수십개의 DB에 모두 동일하게 적용할 수 있다.
- 참고 - 표준화의 한계
  - 각각의 DB마다 SQL, 데이터 타입 등의 일부 사용법이 다르다. (예 : 페이징)
  - SQL은 해당 DB에 맞도록 변경해야 한다. (JPA를 사용하면 DB마다 다른 SQL을 정의해야 하는 문제도 많은 부분 해결 가능)

### JDBC와 최신 데이터 접근 기술
#### SQL Mapper
- 장점
  - JDBC를 편리하게 사용하도록 도와준다.
  - SQL 응답 결과를 객체로 편리하게 변환해준다.
  - JDBC의 반복 코드를 제거해준다.
- 단점
  - 개발자가 SQL을 직접 작성해야 한다.
- 대표 기술 : 스프링 JdbcTemplate, MyBatis
#### ORM 기술
- ORM은 객체를 관계형 DB 테이블과 매핑해주는 기술이다. 이 기술 덕분에 개발자는 반복적인 SQL을 직접 작성하지 않고, ORM 기술이 개발자 대신에 SQL을 동적으로 만들어 실행해준다.
- 각각의 DB마다 다른 SQL을 사용하는 문제도 중간에서 해결
- 대표 기술 : JPA, 하이버네이트, 이클립스 링크
- JPA는 자바 진영의 ORM 표준 인터페이스이고, 이것을 구현한 것으로 하이버네이트와 이클립스 링크 등의 구현 기술이 있다.

#### SQL Mapper vs ORM 기술
- SQL Mapper는 SQL만 작성하면 나머지 번거로운 일은 SQL Mapper가 대신 해결해준다. SQL만 작성할 줄 알면 금방 배워서 사용할 수 있다.
- ORM 기술은 SQL 자체를 작성하지 않아도 되어서 개발 생산성이 매우 높아진다. 편리한 반면에 쉬운 기술은 아니므로 실무에서 사용하려면 깊이있게 학습해야 한다.
- 이런 기술들도 내부에서는 모두 JDBC를 사용한다. 따라서 JDBC를 직접 사용하지는 않더라도, JDBC가 어떻게 동작하는지 기본 원리를 알아두어야 한다.

### JDBC DriverManager 연결 이해
- JDBC는 `java.sql.Connection` 표준 커넥션 인터페이스를 정의한다.
- JDBC가 제공하는 `DriverManager`는 라이브러리에 등록된 DB 드라이벋르을 관리하고, 커넥션을 획득하는 기능을 제공한다.
- 1. 애플리케이션 로직에서 커넥션이 필요하면 `DriverManager.getConnection()`을 호출한다.
- 2. DriverManager는 라이브러리에 등록된 드라이버 목록을 자동으로 인식한다. 이 드라이버들에게 순서대로 다음 정보를 넘겨서 커넥션을 획득할 수 있는지 확인한다.
  - URL
  - 이름, 비밀번호 등 접속에 필요한 추가 정보
  - 여기서 각각의 드라이버는 URL 정보를 체크해서 본인이 처리할 수 있는 요청인지 확인한다. 처리할 수 있다면 실제 DB에 연결해서 커넥션을 획득하고 이 커넥션을 클라이언트에 반환한다.
- 3. 찾은 커넥션 구현체가 클라이언트에 반환된다.

### JDBC 개발
- 쿼리를 실행하고 나면 리소스를 정리해야 한다. 리소스를 정리할 때는 항상 역순으로 해야한다.
- 리소스 정리는 반드시 해주어야 한다. 예외가 발생하든, 하지 않든 항상 수행되어야 하므로 `finally` 구문에서 주의해서 작성해야 한다.
- 만약 이 부분을 놓치게 되면 커넥션이 끊어지지 않고 계속 유지되는 문제가 발생할 수 있다. 이를 리소스 누수라고 하는데, 결과적으로 커넥션 부족으로 장애가 발생할 수 있다.

# 2. 커넥션풀과 데이터소스 이해
### 커넥션 풀 이해
- DB 커넥션을 획득할 때는 다음과 같은 과정을 거친다.
- 1. 애플리케이션 로직은 DB 드라이버를 통해 커넥션을 조회한다.
- 2. DB 드라이버는 DB와 TCP/IP 커넥션을 연결한다. 물론 이 과정에서 3 way handshake 같은 TCP/IP 연결을 위한 네트워크 동작이 발생한다.
- 3. DB 드라이버는 TCP/IP 커넥션이 연결되면, ID, PW와 기타 부가정보를 DB에 전달한다.
- 4. DB ID, PW를 통해 내부 인증을 완료하고, 내부에 DB 세션을 생성한다.
- 5. DB는 커넥션 생성이 완료되었다는 응답을 보낸다.
- 6. DB 드라이버는 커넥션 객체를 생성해서 클라이언트에 반환한다.
- 이렇게 커넥션을 새로 만드는 것은 과정도 복잡하고 시간도 많이 소모되는 일이다. DB는 물론이고 애플리케이션 서버에서도 TCP/IP 커넥션을 새로 생성하기 위한 리소스를 매번 사용해야 한다.
- 진짜 문제는 고객이 애플리케이션을 사용할 때, SQL을 실행하는 시간뿐만 아니라 커넥션을 새로 만드는 시간이 추가되기 때문에 결과적으로 응답 속도에 영향을 준다.
- 이런 문제를 해결하는 아이디어가 바로 커넥셔을 미리 생성해두고 사용하는 커넥션 풀이라는 방법이다.
- 애플리케이션을 시작하는 시점에 커넥션 풀은 필요한 만큼 커넥션을 미리 확보해서 풀에 보관한다. 보통 얼마나 보관할지는 서비스의 특징과 서버 스펙에 따라 다르지만 기본값은 보통 10개이다.
- 커넥션 풀에 들어있는 커넥션은 TCP/IP로 DB와 커넥션이 연결되어 있는 상태이기 때문에 언제든지 즉시 SQL을 DB에 전달할 수 있다.

### 커넥션 풀 사용
- 커넥션 풀을 통해 이미 생성되어 있는 커넥션을 객체 참조로 그냥 가져다 쓴다.
- 커넥션 풀에 커넥셔을 요청하면 커넥션 풀은 자신이 가지고 있는 커넥션 중에 하나를 반환한다.
- 애플리케이션 로직은 커넥션 풀에서 받은 커넥션을 사용해서 SQL을 DB에 전달하고 그 결과를 받아서 처리한다.
- 커넥션을 모두 사용하고 나면 이제는 커넥션을 종료하는 것이 아니라, 다음에 다시 사용할 수 있ㄷ로고 해당 커넥션을 그대로 커넥션 풀에 반환하면 된다.
- 주의할 점은 커넥션을 종료하는 것이 아니라 커넥션이 살아있는 상태로 커넥션 풀에 반환해야 한다는 것이다.

### 커넥션 풀 정리
- 적절한 커넥션 풀 숫자는 서비스의 특징과 애플리케이션 서버 스펙, DB 서버 스펙에 따라 다르기 때문에 성능 테스트를 통해서 정해야 한다.
- 커넥션 풀은 서버당 최대 커넥션 수를 제한할 수 있다. 따라서 DB에 무한정 연결이 생성되는 것을 막아주어서 DB를 보호하는 효과도 있다.
- 이런 커넥션 풀은 얻는 이점이 매우 크기 때문에 실무에서는 항상 기본으로 사용한다.
- 커넥션 풀은 개념적으로 단순해서 직접 구현할 수도 있지만, 사용도 편리하고 성능도 뛰어난 오픈소스 커넥션 풀이 많기 때문에 오픈소스를 사용하는 것이 좋다.
- 성능과 사용의 편리함 측면에서 최근에는 `hikariCP`를 주로 사용한다. 스프링 부트 2.0 부터 기본으로 제공한다.

### DataSource 이해
- `DataSource`는 커넥션을 획득하는 방법을 추상화하는 인터페이스이다. 
- 이 인터페이스의 핵심 기능은 커넥션 조회이다.
- 대부분의 커넥션 풀은 `DataSource` 인터페이스에 이미 구현되어 있으므로, 구현체의 코드를 직접 의존하는 것이 아니라 `DataSource` 인터페이스에만 의존하도록 애플리케이션 로직을 작성하면 된다.
- 커넥션 풀 구현 기술을 변경하고 싶으면 해당 구현체로 갈아끼우기만 하면 된다.

### DriverManager와 DataSource의 차이
- `DriverManager`는 커넥션을 획득할 때 마다 URL, USERNAME, PASSWORD 같은 파라미터를 계속 전달해야 한다.
- 반면 `DataSource`를 사용하는 방식은 처음 객체를 생성할 때만 필요한 파라미터를 넘겨두고, 커넥션을 획득할 때는 단순히 `dataSource.getConnection()`만 호출하면 된다.

#### 설정과 사용의 분리
- 설정 : `DataSource`를 만들고 필요한 속성들을 사용해서 URL, USERNAME, PASSWORD 같은 부분을 입력하는 것을 말한다. 이렇게 설정과 관련된 속성들을 한 곳에 있는 것이 향후 변경에 더 유연하게 대처할 수 있다.
- 사용 : 설정은 신경쓰지 않고, `DataSource`의 `getConnection()`만 호출해서 사용하면 된다.
- 이 부분이 큰 차이를 만들어내는데, 필요한 데이터(URL, USERNAEM, PASSWORD)를 `DataSource`가 만들어지는 시점에 미리 다 넣어두게 되면, 사용할 때는 이러한 데이터(속성)들에 의존하지 않아도 된다.
- 쉽게 말해서 리포지토리는 `DataSource`만 의존하고, 이런 속성들을 몰라도 된다.
- 애플리케이션을 개발하면 보통 설정은 한 곳에서 하지만, 사용은 수 많은 곳에서 하게 된다.
- 덕분에 객체를 설정하는 부분과, 사용하는 부분을 좀 더 명확하게 분리할 수 있다.

#### connection adder
- 별도의 쓰레드를 사용해서 커넥션 풀에 커넥션을 채운다.
- 커넥션 풀에 커넥션을 채우는 것은 상대적으로 오래 걸리는 일이다. 애플리케이션을 실행할 때 커넥션 풀을 채울 때까지 대기하고 있다면 애플리케이션 실행 시간이 늦어진다. 따라서 이렇게 별도의 쓰레드를 사용해서 커넥션 풀을 채워야 애플리케이션 실행 시간에 영향을 주지 않는다.

# 3. 트랜잭션 이해
### 트랜잭션 - 개념 이해
- DB에 저장하는 이유는, DB는 트랜잭션이라는 개념을 지원하기 때문.
- 트랜잭션은 하나의 거래(transaction)을 안전하게 처리하도록 보장하는 것을 뜻한다.
- 모든 작업이 성공해서 DB에 정상 반영하는 것을 커밋(Commit)이라고 하고, 작업 중 하나라도 실패해서 거래 이전으로 되돌리는 것을 롤백(Rollback)이라고 한다.

### 트랜잭션 ACID
- 원자성(Atomicity) : 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다.
- 일관성(Consistency) : 모든 트랜잭션은 일관성 있는 DB 상태를 유지해야 한다. 예를 들어, DB에서 정한 무결성 제약 조건을 항상 만족해야 한다.
- 격리성(Isolation) : 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 예를 들어, 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation level)을 선택할 수 있다.
- 지속성(Durability) : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 DB 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.
- 트랜잭션은 원자성, 일관성, 지속성을 보장한다.
- 문제는 격리성인데 트랜잭션 간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 순서대로 실행해야 한다. 이렇게 하면 동시 처리 성능이 매우 나빠진다. 이런 문제로 인해, ANSI 표준은 트랜잭션의 격리 수준을 4단계로 나누어 정의했다.

### 트랜잭션 격리 수준 - Isolation Level
- READ UNCOMMITED (커밋 되지 않은 읽기)
- READ COMMITED (커밋된 읽기)
- REPEATABLE READ (반복 가능한 읽기)
- SERIALIZABLE (직렬화 가능)

### DB 연결 구조와 DB 세션
- 사용자는 웹 어플리케이션 서버(WAS)나 DB 접근 툴 같은 클라이언트를 사용해서 DB 서버에 접근할 수 있다. 클라이언트는 DB 서버에 연결을 요청하고 커넥션을 맺게 된다. 이때 DB 서버는 내부에 세션이라는 것을 만든다. 그리고 앞으로 해당 커넥션을 통한 모든 요청을 이 세션을 통해서 실행하게 된다.
- 즉 개발자가 클라이언트를 통해 SQL을 전달하면 현재 커넥션에 연결된 세션이 SQL을 실행한다.
- 세션은 트랜잭션을 시작하고, 커밋 또는 롤백을 통해 트랜잭션을 종료한다. 그리고 이후에 새로운 트랜잭션을 다시 시작할 수 있다.
- 사용자가 커넥션을 닫거나, 또는 DBA가 세션을 강제 종료하면 세션은 종료된다.
- 커넥션 풀이 10개의 커넥션을 생성하면, 세션도 10개 만들어진다.

### 트랜잭션 사용법
- 데이터 변경 쿼리를 실행하고 DB에 그 결과를 반영하려면 커밋 명령어인 commit을 호출하고, 결과를 반영하고 싶지 않으면 롤백 명령어인 rollback을 호출하면 된다.
- 커밋을 호출하기 전까지는 임시로 데이터를 저장하는 것이다. 따라서 해당 트랜잭션을 시작한 세션(사용자)에게만 변경 데이터가 보이고 다른 세션(사용자)에게는 변경 데이터가 보이지 않는다.

### 자동 커밋 vs 수동 커밋
- 자동 커밋으로 설정하면 각각의 쿼리 실행 직후에 자동으로 커밋을 호출한다.
- 따라서 커밋이나 롤백을 직접 호출하지 않아도 되는 편리함이 있다.
- 하지만 쿼리를 하나하나 실행할 때마다 자동으로 커밋이 되어버리기 때문에 트랜잭션 기능을 제대로 사용할 수 없다.
- `commit`, `rollback`을 직접 호출하면서 트랜잭션 기능을 제대로 수행하려면 자동 커밋을 끄고 수동 커밋을 사용해야 한다.
- 보통 자동 커밋 모드가 기본으로 설정된 경우가 많기 때문에, 수동 커밋 모드로 설정하는 것을 트랜잭션을 시작한다고 표현할 수 있다.
- 수동 커밋 설정을 하면 이후에 꼭 `commit`, `rollback`을 호출해야 한다.
- 수동 커밋모드나 자동 커밋모드는 한번 설정하면 해당 세션에서는 계속 유지된다. (중간에 변경하는 것은 가능)

### DB 락
- 유저1이 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데, 유저2가 동시에 같은 데이터를 수정하게 되면 트랜잭션의 원자성이 깨진다.
- 이런 문제를 방지하려면, 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정할 수 없게 막아야 한다.

### DB 락 - 조회
- 일반적인 조회는 락을 사용하지 않는다.
- DB마다 다르지만, 보통 데이터를 조회할 때는 락을 획득하지 않고 바로 데이터를 조회할 수 있다.
- `select ~ for update` 구문을 사용하면 조회할 때도 락을 획득한다. (당연히 트랜잭션을 커밋하면 락을 반납한다.)
- 조회 시점에 락이 필요한 경우는 트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 등이 있다.

### 트랜잭션 - 적용
- 애플리케이션에서 트랜잭션을 어떤 계층에 걸어야 하는가? 트랜잭션은 비즈니스 로직이 있는 서비스 계층에서 시작해야 한다. 비즈니스 로직이 잘못되면 해당 비즈니스 로직으로 인해 문제가 되는 부분을 함께 롤백해야 하기 때문이다.
- 그런데 트랜잭션을 시작하려면 커넥션이 필요하다. 결국 서비스 계층에서 커넥션을 만들고 트랜잭션 커밋 이후에 커넥션을 종료해야 한다.
- 애플리케이션에서 DB 트랜잭션을 사용하려면 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야 한다. 그래야 같은 세션을 사용할 수 있다.
- 애플리케이션에서 같은 커넥셔을 유지하는 방법 중 가장 단순한 방법은 커넥션을 파라미터로 전달해서 같은 커넥션이 사용되도록 유지하는 것이다.
- 그럴 경우 서비스 계층이 매우 지저분해지고, 복잡한 코드를 요구된다. 커넥션을 유지하도록 코드를 변경하는 것도 쉬운 일이 아니다.

# 4. 스프링과 문제 해결 - 트랜잭션
### 애플리케이션 구조
- 프레젠테이션 계층
  - UI와 관련된 처리 담당
  - 웹 요청과 응답
  - 사용자 요청을 검증
  - 주 사용 기술 : 서블릿과 HTTP 같은 웹 기술, 스프링 MVC
- 서비스 계층
  - 비즈니스 로직을 담당
  - 주 사용 기술 : 가급적 특정 기술에 의존하지 않고, 순수 자바 코드로 작성
- 데이터 접근 계층
  - 실제 DB에 접근하는 코드
  - 주 사용 기술 : JDBC, JPA, File, Redis, Mongo 등

### 순수한 서비스 계층
- 애플리케이션 구조중 가장 중요한 곳은 핵심 비즈니스 로직이 들어있는 서비스 계층이다.
- 시간이 흘러 UI(웹)와 관련된 부분이 변하고, 데이터 저장 기술을 다른 기술로 변경해도, 비즈니스 로직은 최대한 변경없이 유지되어야 한다.
- 따라서, 서비스 계층을 특정 기술에 종속적이지 않게 개발해야 한다.
- 애플리케이션을 3계층으로 나눈 이유도 서비스 계층을 최대한 순수하게 유지하기 위한 목적이 크다. 기술에 종속적인 부분은 프레젠테이션 계층, 데이터 접근 계층에서 가지고 간다.
- 프레젠테이션 계층은 클라이언트가 접근하는 UI와 관련된 기술인 웹, 서블릿, HTTP와 관련된 부분을 담당해준다. 그래서 서비스 계층을 이런 UI와 관련된 기술로부터 보호해준다.
- 데이터 접근 계층은 데이터를 저장하고 관리하는 기술을 담당해준다. 그래서 JDBC, JPA와 같은 구체적인 데이터 접근 기술로부터 서비스 계층을 보호해준다. 서비스 계층에서 데이터 접근 계층을 직접 접근하는 것이 아니라, 인터페이스를 제공하고 서비스 계층은 이 인터페이스에 의존하는 것이 좋다.
- 서비스 계층이 특정 기술에 종속되지 않기 대문에 비즈니스 로직을 유지보수 하기도 쉽고, 테스트하기도 쉽다.
- 정리하자면 서비스 계층은 가급적 비즈니스 로직만 구현하고 특정 구현 기술에 직접 의존해서는 안된다. 이렇게 하면 향후 구현 기술이 변경될 때 변경의 영향 범위를 최소화 할 수 있다.

### 지금까지 예제의 문제점들
- 트랜잭션 문제
- 예외 누수 문제
- JDBC 관련 코드 반복 문제

#### 트랜잭션 문제
- JDBC 구현 기술이 서비스 계층에 누수되는 문제
  - 트랜잭션을 적용하기 위해 JDBC 구현 기술이 서비스 계층에 누수됨
  - 서비스 계층은 순수해야 한다. 즉, 구현 기술을 변경해도 서비스 계층 코드는 최대한 유지할 수 있어야 한다. 변화에 대응하기 위함이다.
  - 서비스 계층은 특정 기술에 종속되지 않아야 한다. 지금까지 그렇게 노력해서 데이터 접근 계층으로 JDBC 관련 코드를 모았는데, 트랜잭션을 적용하면서 결국 서비스 계층에 JDBC 구현 기술의 누수가 발생한다.
- 트랜잭션 동기화 문제
  - 같은 트랜잭션을 유지하기 위해 커넥션을 파라미터로 넘겨야 한다.
  - 똑같은 기능도 트랜잭션용 기능과 트랜잭션을 유지하지 않아도 되는 기능으로 분리해야 한다.
- 트랜잭션 적용 반복 문제

#### 예외 누수
- 데이터 접근 계층의 JDBC 구현 기술 예외가 서비스 계층으로 전파된다.
- `SQLException`은 체크 예외이기 때문에 데이터 접근 계층을 호출한 서비스 계층에서 해당 예외를 잡아서 처리하거나 명시적으로 `throws`를 통해서 다시 밖으로 던져야 한다.
- `SQLException`은 JDBC 전용 기술이다. 향후 JPA나 다른 접근 기술을 사용하면, 그에 맞는 다른 예외로 변경해야 하고, 결국 서비스 코드도 수정해야 한다.

#### JDBC 반복문제
- 유사한 코드의 반복이 너무 많다.
- `try`, `catch`, `finally` 등과 커넥션을 열고, PreparedStatement를 사용하고, 결과를 매핑하고, 실행하고, 커넥션과 리소스를 정리하는 과정의 반복이다.

### 트랜잭션 추상화
- 트랜잭션을 사용하는 코드는 데이터 접근 기술마다 다르다. 따라서 특정 기술에 종속되도록 서비스 계층을 구현하면 기술이 바뀌게 되었을 때 트랜잭션을 처리하는 코드도 모두 함께 변경해야 한다.
- 이러한 문제를 해결하기 위해 트랜잭션 기능을 추상화한다.
- 트랜잭션은 단순하다. 트랜잭션을 시작하고, 비즈니스 로직의 수행이 끝나면 커밋하거나 롤백하면 된다.
- 서비스는 특정 트랜잭션 기술에 직접 의존하는 것이 아니라, 트랜잭션이 추상화된 인터페이스에 의존하도록 한다. 원하는 구현체를 DI를 통해서 주입하면 된다.
- 클라이언트인 서비스는 인터페이스에 의존하고 DI를 사용한 덕분에 OCP 원칙을 지킬 수 있게 된다. 즉, 서비스 코드를 전혀 변경하지 않아도 된다.
- 스프링이 제공하는 트랜잭션 추상화 기술을 사용하면 된다. 스프링 트랜잭션 추상화의 책심은 `PlatformTransactionManager`인터페이스이다.

### 트랜잭션 동기화
- 스프링이 제공하는 트랜잭션 메니저는 크게 2가지 역할을 한다.
  - 트랜잭션 추상화
  - 리소스 동기화

#### 리소스 동기화
- 트랜잭션을 유지하려면 트랜잭션의 시작부터 끝까지 같은 DB 커넥션을 유지해야 한다.
- 스프링은 트랜잭션 동기화 매니저를 제공한다. 이것은 쓰레드 로컬(ThreadLocal)을 사용해서 커넥션을 동기화(맞추어 사용)해준다. 트랜잭션 매니저는 내부에서 이 트랜잭션 동기화 매니저를 사용한다.
- 트랜잭션 동기화 매니저는 쓰레드 로컬을 사용하기 때문에 멀티 쓰레드 상황에 안전하게 커넥션을 동기화할 수 있다. 따라서 커넥션이 필요하면 트랜잭션 동기화 매니저를 통해 커넥션을 획득하면 된다.

### 트랜잭션 매니저 동작 방식
1. 트랜잭션을 시작하려면 커넥션이 필요하다. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 만들고 트랜잭션을 시작한다.
2. 트랜잭션 매니저는 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 보관한다.
3. 리포지토리는 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용한다. 따라서 파라미터로 커넥션을 전달하지 않아도 된다.
4. 트랜잭션이 종료되면 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료하고, 커넥션도 닫는다.

### 트랜잭션 문제 해결 - 트랜잭션 매니저
- `DataSourceUtils.getConnection()`
  - 트랜잭션 동기화 매니저가 관리하는 커넥션이 있으면 해당 커넥션을 반환한다.
  - 트랜잭션 동기화 매니저가 관리하는 커넥션이 없는 경우 새로운 커넥션을 생성해서 반환한다.
- `DataSourceUtils.releaseConnection()`
  - 트랜잭션을 사용하기 위해 동기화된 커넥션은 커넥션을 닫지 않고 그대로 유지해준다.
  - 트랜잭션 동기화 매니저가 관리하는 커넥션이 없는 경우 해당 커넥션을 닫는다.

#### 트랜잭션 매니저 동작 흐름 (예제 참고, `DataSourceTransactionManager` 동작 방식)
0. 클라이언트의 요청으로 서비스 로직을 실행한다.
1. 서비스 계층에서 `transactionManager.getTransaction()`을 호출해서 트랜잭션을 시작한다.
2. 트랜잭션을 시작하려면 먼저 DB 커넥션이 필요하다. 트랜잭션 매니저는 내부에서 데이터소스를 사용해서 커넥션을 생성한다.
3. 커넥션을 수동 커밋 모드로 변경해서 실제 DB 트랜잭션을 시작한다.
4. 커넥션을 트랜잭션 동기화 매니저에 보관한다.
5. 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관한다. 따라서 멀티 쓰레드 환경에 안전하게 커넥션을 보관할 수 있다.
6. 서비스는 비즈니스 로직을 실행하면서 리포지토리의 메서드들을 호출한다. (이때 커넥션을 파라미터로 전달하지 않는다.)
7. 리포지토리 메서드들은 트랜잭션이 시작된 커넥션이 필요하다. 리포지토리는 `DataSourceUtils.getConnection()`을 사용해서 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용한다. 이 과정을 통해서 자연스럽게 같은 커넥션을 사용하고, 트랜잭션도 유지된다.
8. 획득한 커넥션을 사용해서 SQL을 DB에 전달해서 실행된다.
9. 비즈니스 로직이 끝나고 트랜잭션을 종료한다. 트랜잭션은 커밋하거나 롤백하면 종료된다.
10. 트랜잭션을 종료하려면 동기화된 커넥션이 필요하다. 트랜잭션 동기화 매니저를 통해 동기화된 커넥션을 획득한다.
11. 획득한 커넥션을 통해 DB에 트랜잭션을 커밋하거나 롤백한다.
12. 전체 리소스를 정리한다. (트랜잭션 동기화 매니저를 정리한다. 쓰레드 로컬은 사용 후 꼭 정리해야 한다. 커넥션풀을 고려해 오토 커밋으로 되돌린다. 커넥션을 종료한다. 커넥션 풀을 사용하는 경우 커넥션 풀에 반환된다.)

### 트랜잭션 문제 해결 - 트랜잭션 템플릿
- 트랜잭션을 사용하는 로직을 살펴보면 패턴이 반복되는 것을 확인할 수 있다.
  - 트랜잭션을 시작하고, 비즈니스 로직을 실행하고, 성공하면 커밋하고, 예외가 발생해서 실패하면 롤백한다.
  - `try ~ catch ~ finally` 구문이 반복된다.
  - 이러한 형태는 트랜잭션을 이용하는 각각의 서비스에서 반복된다. 달라지는 부분은 비즈니스 로직 뿐이다.
- 이때 템플릿 콜백 패턴을 활용하면 반복 문제를 깔끔하게 해결할 수 있다.
- 템플릿 콜백 패턴이 적용된 클래스를 스프링에서 `TransactionTemplate` 라는 템플릿 클래스를 제공한다.
- 트랜잭션 템플릿을 사용하면 트랜잭션을 사용할 때 반복하는 코드를 제거할 수 있다.
- 하지만 서비스 계층에 비즈니스 로직 뿐만 아니라 트랜잭션을 처리하는 기술 로직이 함께 포함된다.
- 애플리케이션을 구성하는 로직을 핵심 기능과 부가 기능으로 구분하자면 서비스 입장에서 비즈니스 로직은 핵심 기능이고, 트랜잭션은 부가 기능이다.
- 이렇게 비즈니스 로직과 트랜잭션을 처리하는 기술 로직이 한 곳에 잇으면 두 관심사를 하나의 클래스에서 처리하게 된다. 결과적으로 코드를 유지보수하기 어려워진다.
- 서비스 로직은 가급적 핵심 비즈니스 로직만 있어야 한다.

### 트랜잭션 문제 해결 - 트랜잭션 AOP 이해
- 트랜잭션 템플릿 덕분에 트랜잭션을 처리하는 반복 코드는 해결할 수 있었지만, 서비스 계층에 순수한 비즈니스 로직만 남긴다는 목표는 달성하지 못헀다.
- 이 때 스프링 AOP를 통해 프록시를 도입하면 문제를 깔끔하게 해결할 수 있다.
- 프록시를 도입하면 트랜잭션 프록시가 트랜잭션 처리 로직을 모두 가져간다. 그리고 트랜잭션을 시작한 후에 실제 서비스를 대신 호출한다. 트랜잭션 프록시 덕분에 서비스 계층에는 순수한 비즈니스 로직만 남길 수 있다.
- 개발자는 트랜잭션 처리가 필요한 곳에 `@Transactional` 애노테이션만 붙여주면 된다. 스프링의 트랜잭션 AOP는 이 애노테이션을 인식해서 트랜잭션 프록시를 적용해준다.
- `@Transactional`은 메서드에 붙여도 되고, 클래스에 붙여도 된다. 클래스에 붙이면 외부에서 호출 가능한 public 메서드가 AOP 적용 대상이 된다.

### 트랜잭션 문제 해결 - 트랜잭션 AOP 정리
- 선언적 트랜잭션 관리(Declarative Transaction Management)
  - `@Transactional` 어노테이션 하나만 선언해서 매우 편리하게 트랜잭션을 적용하는 것을 선언적 트랜잭션 관리라고 한다.
  - 해당 로직에 트랜잭션을 적용하겠다고 어딘가에 선언하기만 하면 트랜잭션이 적용되는 방식이다.
- 프로그래밍 방식의 트랜잭션 관리(Programmatic Transaction Management)
  - 트랜잭션 매니저 또는 트랜잭션 템플릿 등을 사용해서 트랜잭션 관련 코드를 직접 작성하는 것을 프로그래밍 방식의 트랜잭션 관리라 한다.
- 선언적 트랜잭션 관리가 프로그래밍 방식에 비해서 훨씬 간편하고 실용적이기 때문에 실무에서는 대부분 선언적 트랜잭션 관리를 사용한다.
- 프로그래밍 방식의 트랜잭션 관리는 스프링 컨테이너나 스프링 AOP 기술 없이 간단히 사용할 수 있지만 실무에서는 대부분 스프링 컨테이너와 스프링 AOP를 사용하기 때문에 거의 사용되지 않는다.
- 프로그래밍 방식 트랜잭션 관리는 테스트 시에 가끔 사용될 때는 있다.

### 스프링 부트의 자동 리소스 등록
- 기존에는 데이터소스와 트랜잭션 매니저를 직접 스프링 빈으로 등록했어야 했으나, 스프링 부트가 나오면서 많은 부분이 자동화되었다.
- 데이터소스 자동 등록
  - 스프링부트는 데이터소스(`DataSource`)를 스프링 빈에 자동 등록한다.
  - 등록되는 스프링 빈 이름은 `dataSource`
  - 개발자가 직접 데이터소스를 빈으로 등록하면 스프링 부트는 데이터소스를 자동으로 등록하지 않는다.
  - 이때 스프링 부트는 `application.properties`에 있는 속성을 사용해서 `DataSource`를 생성하고 스프링 빈에 등록한다.
  - 스프링 부트가 기본으로 생성하는 데이터소스는 커넥션풀을 제공하는 `HikariDataSource`이다. 커넥션 풀과 관련된 설정도 `application.properties`를 통해서 지정할 수 있다.
  - `spring.datasource.url` 속성이 없으면 내장 DB(메모리 DB)를 생성하려고 시도한다.
```properties
application.properties
spring.datasource.url=jdbc:h2:tcp://localhost/~/jdbc
spring.datasource.username=sa
spring.datasource.password=
```
- 트랜잭션 매니저 자동등록
  - 스프링 부트는 적절한 트랜잭션 매니저(`PlatformTransactionManager`)를 자동으로 스프링 빈에 등록한다.
  - 등록되는 스프링 빈 이름은 `transactionManager`
  - 개발자가 직접 트랜잭션 매니저를 빈으로 등록하면 스프링 부트는 트랜잭션 매니저를 자동으로 등록하지 않는다.

# 5. 자바 예외 이해
### 예외 계층
- `Object` : 예외도 객체이다. 모든 객체의 최상위 부모는 `Object` 이므로 예외의 최상위 부모도 `Object` 이다.
- `Throwable` : 최상위 예외이다. 하위에 `Exception`과 `Error`가 있다.
- `Error` : 메모리 부족이나 심각한 시스템 오류와 같이 애플리케이션에서 복구 불가능한 시스템 예외이다. 애플리케이션 개발자는 이 예외를 잡으려고 해서는 안된다.
  - 상위 예외를 catch로 잡으면 그 하위 예외까지 함께 잡는다. 따라서 애플리케이션 로직에서는 `Throwable`예외도 잡으면 안되는데, 앞서 이야기한 `Error` 예외도 함께 잡을 수 있기 때문이다. 애플리케이션 로직은 이런 이유로 `Exception`부터 필요한 예외로 생각하고 잡으면 된다.
  - `Error`도 언체크 예외이다.
- `Exception` : 체크 예외
  - 애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외이다.
  - `Exception`과 그 하위 예외는 모두 컴파일러가 체크하는 체크 예외이다. 단 `RuntimeException`은 예외로 한다.
- `RuntimeException` : 언체크 예외, 런타임 예외
  - 컴파일러가 체크하지 않는 언체크 예외이다.
  - `RuntimeException`과 그 자식 예외는 모두 언체크 예외이다.
  - `RuntimeException`의 이름을 따서 `RuntimeException`과 그 하위 언체크 예외를 런타임 예외라고 많이 부른다.

### 예외 기본 규칙
- 예외는 잡아서(catch) 처리하거나, 처리할 수 없으면 밖으로 던져야 한다.
- 예외를 처리하면 이후에는 애플리케이션 로직이 정상 흐름으로 동작한다.
- 예외를 처리하지 못하면 호출한 곳으로 예외를 계속 던지게 된다.
- 예외를 잡거나 던질 때 지정한 예외뿐만 아니라 그 예외의 자식들도 함께 처리된다.
  - 예를 들어서 `Exception`을 `catch`로 잡으면 그 하위 예외들도 모두 잡을 수 있다.
  - 예를 들어서 `Exceptoin`을 `throws`로 던지면 그 하위 예외들도 모두 던질 수 있다.

#### 예외를 처리하지 못하고 계속 던지면 어떻게 될까?
- 자바 `main()`쓰레드의 경우 예외 로그를 출력하면서 시스템이 종료된다.
- 웹 애플리케이션의 경우 여러 사용자의 요청을 처리하기 때문에 하나의 예외 때문에 시스템이 종료되면 안된다. WAS가 해당 예외를 받아서 처리하는데, 주로 사용자에게 개발자가 지정한 오류 페이지를 보여준다.

### 체크 예외 기본 이해
- `Exception`과 그 하위 예외는 모두 컴파일러가 체크하는 체크 예외이다. 단 `RuntimeException`은 예외로 한다.
- 체크 예외는 잡아서 처리하거나, 또는 밖으로 던지도록 선언해야 한다. 그렇지 않으면 컴파일 오류가 발생한다.
- `Exception`을 상속 받으면 체크 예외가, `RuntimeException`을 상속받으면 언체크 예외가 된다. (By 자바 문법)
- 예외는 오류 메시지를 보관하는 기본 기능이 있다. 생성자를 통해서 해당 기능을 그대로 사용하면 편리하다.
- 체크 예외를 잡아서 처리하려면 `catch`를 사용해서 예외를 잡으면 된다. `catch`는 해당 타입과 그 하위 타입을 모두 잡을 수 있다.
- 체크 예외를 처리할 수 없을 때에는 `method() throws 예외`를 사용해서 밖으로 던질 예외를 필수로 지정해주어야 한다. `throws`는 지정한 타입과 그 하위 타입 예외를 밖으로 던진다.
- `throws`를 지정하지 않으면 컴파일 오류가 발생한다.
- 따라서 체크 예외의 경우 예외를 잡아서 처리하거나 또는 `throws`를 지정해서 예외를 밖으로 던진다는 선언을 필수로 해주어야 한다.

### 체크 예외의 장단점
- 체크 예외는 예외를 잡아서 처리할 수 없을 때, 예외를 밖으로 던지는 `throws 예외`를 필수로 선언해야 한다. 그렇지 않으면 컴파일 오류가 발생한다.
- 장점 : 개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 문제를 잡아주는 훌륭한 안전 장치이다.
- 단점 : 개발자가 모든 체크 예외를 반드시 잡거나 던지도록 처리해야 하기 때문에 너무 번거로운 일이 된다. 크게 신경쓰지 않은 예외까지 모두 챙겨야 한다. 추가로 의존관계에 따른 단점도 존재한다.

### 언체크 에외 기본 이해
- `RuntimeException`과 그 하위 예외는 언체크 예외로 분류된다.
- 컴파일러가 예외를 체크하지 않는다.
- 언체크 예외는 체크 예외와 기본적으로 동일하다. 차이가 있다면 예외를 던지는 `throws`를 선언하지 않고 생략할 수 있다. 이 경우 자동으로 예외를 던진다.
- 체크 예외 vs 언체크 예외
  - 체크 예외 : 예외를 잡아서 처리하지 않으면 항상 `throws`에 던지는 예외를 선언해야 한다.
  - 언체크 예외 : 예외를 잡아서 처리하지 않아도 `throws`를 생략할 수 있다.

### 언체크 예외의 장단점
- 언체크 예외는 예외를 잡아서 처리할 수 없을 때, 예외를 밖으로 던지는 `throws 예외`를 생략할 수 있다.
- 장점 : 신경쓰고 싶지 않은 언체크 예외를 무시할 수 있다. 체크 예외의 경우 처리할 수 없는 예외를 밖으로 던지려면 항상 `throws 예외`를 선언해야 하지만, 언체크 예외는 이 부분을 생략할 수 있다. 신경쓰고 싶지 않은 예외의 의존관계를 참조하지 않아도 되는 장점이 있다.
- 단점 : 언체크 예외는 개발자가 실수로 예외를 누락할 수 있다. 반면에 체크 예외는 컴파일러를 통해 예외 누락을 잡아준다.

### 체크 예외 활용
- 기본적으로 언체크(런타임) 예외를 사용하자.
- 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용하자.
  - 이 경우 해당 예외를 잡아서 반드시 처리해야 하는 문제일 때만 체크 예외를 사용해야 한다.
    - 예) 계좌 이체 실패, 결제시 포인트 부족, 로그인 ID/PW 불일치 등

### 체크 예외의 문제점
- 복구 불가능한 예외
  - 대부분의 예외는 복구가 불가능하다. 특히 대부분의 서비스나 컨트롤러는 문제를 해결할 수 없다. 따라서 일관성 있게 공통으로 처리해야 한다. 오류 로그를 남기고 개발자가 해당 오류를 빠르게 인지한느 것이 필요하다. 서블릿 필터, 스프링 인터셉터, 스프링의 `ControllerAdvice`를 사용하면 깔끔하게 공통으로 해결할 수 있다.
- 의존 관계에 대한 문제
  - Exception이 특정 기술에 의존관계를 맺고 있을 경우, 다른 기술로 변경했을 때, 관련된 Exception들을 모두 수정해야 한다. 즉 서비스나 컨트롤러 입장에서는 처리할 수도 없는 예외를 의존해야 한다는 단점이 발생한다. 결과적으로 OcP, DI를 통해 클라이언트 코드의 변경 없이 대상 구현체를 변경할 수 없게 된다.
  - 처리할 수 있는 체크 예외라면 서비스나 컨트롤러에서 처리하겠지만, DB나 네트워크 통신처럼 시스템 레벨에서 올라온 예외들은 대부분 복구가 불가능하다. 그리고 실무에서 발생하는 대부분의 예외들은 이러한 시스템 예외들이다.
  - 이런 경우에 체크 예외를 사용하면 아래에서 올라온 복구 불가능한 예외를 서비스, 컨트롤러 같은 각각의 클래스가 모두 알고 있어야 한다. 그래서 불필요한 의존관계 문제가 발생하게 된다.
- 만약 여러 체크 예외들을 모두 명시하기 어려워 `throws Exception`을 사용하면, 코드가 깔끔해지는 것 같지만 다른 체크 예외를 체크할 수 있는 기능이 무효화되고, 중요한 체크 예외를 다 놓치게 된다. 중간에 중요한 체크 예외가 발생해도 컴파일러는 `Exception`을 던지기 때문에 문법에 맞다고 판단해서 컴파일 오류가 발생하지 않는다. 따라서 체크 예외를 의도한 대로 사용하는 것이 아니기 때문에 이러한 표현은 지양해야 한다.

### 언체크 예외 활용
- 런타임 예외는 서비스, 컨트롤러에서 해당 예외를 처리할 수 없다면 별도의 선언 없이 그냥 두면 된다.
- 체크 예외를 런타임 예외로 전환할 때는 기존 예외를 포함해주어야 예외 출력시 스택 트레이스에서 기존 예외도 함께 확인할 수 있다.
- 럼타임 예외를 사용하면 서비스나 컨트롤러가 복구 불가능한 예외를 신경쓰지 않아도 된다. 물론 이렇게 복구 불가능한 예외는 일관성 있게 공통으로 처리해야 한다.
- 런타임 예외는 해당 객체가 처리할 수 없는 예외는 무시하면 된다. 따라서 체크 예외처럼 예외를 강제로 의존하지 않아도 된다. (= 컨트롤러와 서비스에서 해당 예외에 대한 의존관계가 발생하지 않는다.)
- 런타임 예외를 사용하면 중간에 기술이 변경되어도 해당 예외를 사용하지 않는 컨트롤러, 서비스에서는 코드를 변경하지 않아도 된다.
- 구현 기술이 변경되는 경우, 예외를 공통으로 처리하는 곳에서는 예외에 따른 다른 처리가 필요할 수 있다. 하지만 공통 처리하는 한 곳만 변경하면 되기 때문에 변경의 영향 범위는 최소화된다.
- 런타임 예외의 경우 로그는 공통으로 예외를 처리하는 것에서 남기는 것이 좋다. 어차피 복구할 수 없는 예외는 예외를 공통으로 처리하는 부분까지 전달되기 때문이다.

### 예외 트렌드
- 처음 자바를 설계할 당시에는 체크 예외가 더 나은 선택이라 생각했다. 그래서 자바가 기본으로 제공하는 기능들에는 체크 예외가 많다.
- 그러나 시간이 흐르고 라이브러리가 많아지면서, 복구할 수 없는 예외가 너무 많아졌다. 모든 예외를 처리할 수 없을 때마다 `throws`에 예외를 덕지덕지 붙여야 했다.
- `throws Exception`이라는 방법도 사용하기도 했는데, 이러면 어떤 예외를 잡고 어떤 예외를 던지는지 알 수 없게 된다. 체크 예외를 사용한다면 잡을 건 잡고 던질 예외는 명확하게 던지도록 선언해야 한다.
- 이러한 체크 예외의 문제점 때문에 최근 라이브러리들은 대부분 런타임 예외를 기본으로 제공한다.
- 런타임 예외도 필요하면 잡을 수 있기 때문에 필요한 경우에는 잡아서 처리하고, 그렇지 않으면 자연스럽게 던지도록 둔다. 그리고 예외를 공통으로 처리하는 부분을 앞에 만들어서 처리하면 된다.
- 런타임 예외는 놓칠 수 있기 때문에 문서화가 중요하다. 혹은, 코드에 `throws 런타임예외`를 남겨서 중요한 예외를 인지할 수 있도록 해야 한다.

### 예외 포함과 스택 트래이스
- 예외를 전환할 때는 꼭! 기존 예외를 포함해야 한다. 그렇지 않으면 스택 트레이스를 확인할 때 심각한 문제가 발생한다.
- 로그를 출력할 때 마지막 파라미터에 예외를 넣어주면 로그에 스택 트레이스를 출력할 수 있다. 실무에서는 항상 로그를 사용하자. (`.printStackTrace()`를 사용하면 `System.out`에 스택 트레이스를 출력할 수 있기는 하나, 권장하지 않음)

# 6. 스프링과 문제 해결 - 예외 처리, 반복
### 체크 예외와 인터페이스
- 서비스 계층은 가급적 특정 구현 기술에 의존하지 않고, 순수하게 유지하는 것이 좋다. 따라서 예외에 대한 의존도 함께 해결해야 한다.
- 서비스가 처리할 수 없는 예외는 체크 에외를 런타임 예외로 전환해서 서비스 계층에 던져야 한다. 이렇게 하면 서비스 계층이 해당 예외를 무시할 수 있기 때문에, 특정 구현 기술에 의존하는 부분을 제거하고 서비스 계층을 순수하게 유지할 수 있다.

### 인터페이스 도입
- 서비스 단이 특정 기술에 의존하지 않도록 하기 위해, 특정 기술에 종속적이지 않은 인터페이스에 의존하도록 코드를 수정한다. 그 인터페이스를 기반으로 특정 기술을 사용하는 구현체를 만들면 된다.
- 체크 예외를 사용하려면 인터페이스에도 해당 체크 예외가 선언되어 있어야 한다. 특정 기술에 의존하는 Exception을 인터페이스에 선언할 경우, 그것은 구현체를 쉽게 변경할 수 있는 순수한 인터페이스가 아니다.
  - 참고로 구현 클래스의 메서드에 선언할 수 있는 에외는 부모 타입에서 던진 예외와 같거나 하위 타입이어야 한다.
- 따라서 인터페이스에 예외를 따로 선언하지 않아도 되는 런타임 예외를 사용하면 인터페이스가 특정 기술에 종속적일 필요가 없어진다.
- 코드에서 핵심은 체크 예외를 런타임 예외로 변환해서 던지는 것이다.
- 기존 예외를 생성자를 통해서 포함해야 한다. 예외는 원인이 되는 예외를 내부에 포함할 수 있는데, 반드시 이렇게 작성해야 한다. 그래야 예외를 출력했을 때 원인이 되는 기존 예외도 함께 확인할 수 있기 때문이다.
- 기존 예외를 무시하고 작성하면 절대 안 된다.
- 체크 예외를 런타임 예외로 변환하면서 인터페이스와 서비스 계층의 순수성을 유지할 수 있게 된다.
- 구현 기술을 변경하더라도 서비스 계층의 코드를 변경하지 않고 유지할 수 있다.

### 스프링 예외 추상화 이해
- 스프링은 데이터 접근 계층에 대한 수십 가지 예외를 정리해서 일관된 예외 계층을 제공한다.
- 각각의 예외는 특정 기술에 종속적이지 않게 설계되어 있따. 따라서 서비스 계층에서도 스프링이 제공하는 예외를 사용하면 된다.
- JDBC나 JPA를 사용할 때 발생하는 예외를 스프링이 제공하는 예외로 변환해주는 역할도 스프링이 제공한다.
- 데이터 접근 계층 예외의 최상위는 `DataAccessException`이다. 런타임 예외를 상속 받기 때문에 스프링이 제공하는 데이터 접근 계층의 모든 예외는 런타임 예외이다.
- `DataAccessException`은 크게 2가지로 구분한다.
  - `Transient` : 일시적이라는 뜻이다. `Transient` 하위 예외는 동일한 SQL을 다시 시도했을 때 성공할 가능성이 있다. (예. 쿼리 타임아웃, 락 관련 오류들)
  - `NonTransient` : 일시적이지 않다는 뜻이다. 같은 SQL을 그대로 반복해서 실행하면 실패한다. (예. SQL 문법 오류, DB 제약조건 위배 등)
- 스프링은 DB에서 발생하는 오류 코드를 스프링이 정의한 예외로 자동으로 변환해주는 변환기를 제공한다.
- 서비스 계층에서 예외를 잡아 복구해야 하는 경우, 예외가 스프링이 제공하는 데이터 접근 예외로 변경되어서 서비스 계층에 넘어오도록 만들고, 필요한 경우 예외를 잡아서 복구하면 된다.

### JDBC 반복 문제 해결 - JdbcTemplate
- JDBC를 사용하면서 반복되는 코드들은 다음과 같다.
  - 커네션 조회, 커넥션 동기화
  - `PreparedStatement` 생성 및 파라미터 바인딩
  - 쿼리 실행
  - 결과 바인딩
  - 예외 발생시 스프링 예외 변환기 실행
  - 리소스 종료
- 이러한 반복되는 코드들을 효과적으로 처리하는 방법이 템플릿 콜백 패턴이다.
- 스프링은 JDBC의 반복 문제를 해결하기 위해 `JdbcTemplate`이라는 템플릿을 제공한다.
- `JdbcTemplate`은 JDBC로 개발할 때 발생하는 반복을 대부분 해결해주며, 트랜잭션을 위한 커넥션 동기화와 스프링 에외 변환기도 자동으로 실행해준다.

### 정리
- 완성된 코드는 다음과 같은 목표를 달성했다.
- 서비스 계층의 순수성
  - 트랜잭션 추상화 + 트랜잭션 AOP 덕분에 서비스 계층의 순수성을 최대한 유지하면서 서비스 계층에서 트랜잭션을 사용할 수 있다.
  - 스프링이 제공하는 예외 추상화와 예외 변환기 덕분에, 데이터 접근 기술이 변경되어도 서비스 계층의 순수성을 유지하면서 예외도 사용할 수 있다.
  - 서비스 계층이 리포지토리 인터페이스에 의존한 덕분에 향후 리포지토리가 다른 구현 기술로 변경되어도 서비스 계층을 순수하게 유지할 수 있다.
- 리포지토리에서 JDBC를 사용하는 반복 코드가 `JdbcTemplate`으로 대부분 제거되었다.
